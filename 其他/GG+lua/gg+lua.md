# 初识GG

## 1.GG介绍

软件全名:  [GameGuardian ](https://gameguardian.net/forum/files/)
game : 游戏    	guardian : 守护者, 卫士
常用中文名:  [GG修改器](https://gameguardian.net/forum/files/)
官方网址:  https://gameguardian.net/forum/files/
(不建议下官网的GG,因为各游戏都对它有针对检测,一打开就被检测到了)
使用要求:  需要超级管理员权限,一般叫"ROOT权限".
使用设备: 

* 已获取root的安卓手机
* 安卓虚拟机.   例如 "光速虚拟机" , "Vmos Pro" ...
* windows电脑上的安卓模拟器. 例如 "雷电模拟器" , "夜神模拟器" ......



## 2.GG的基本按钮 

启动GG,点击开始,它会自动缩小,变成一个悬浮窗.

选择游戏进程，如果看见有好几个同名的，选占用最大的。

最上面,有七个可以点击的. 

分别是1[游戏进程].  2[ GG设置],  3[搜索列表],  4[保存列表],  5[地址],  6[更多选项],  7[缩小]

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229360736-b62b9381-1fc1-40bd-be29-9981c491cc6c.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_698%2Climit_0)

第一步,是选择游戏进程.如果看见有好几个同名的，选占用最大的。

第二步,选择内存范围,对于大部分游戏，勾上前七个.  只是参考,不是必须这样.

第三步,对游戏隐藏GG. 勾选2和3.   有特殊情况,再考虑勾上4.

第四步,旁路模式,点击,没有.

第五步,运行守护,级别3.

## 3.其他设置

变速: 速度这里可以自己填,记得用分号隔开. 
0.1;1;5;10;100;10000     单机游戏大多可以加速。
先缩小,长按悬浮窗,会出现左右的箭头,就是变速.
再次长按,可以隐藏箭头.

键盘： 手机默认是内置。  
我用模拟器所以选外置，电脑用键盘输入更方便。

## 4.常用按钮 

 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229367692-eb63d0ec-1f10-4947-aa15-46e3f975e093.png?x-oss-process=image%2Fformat%2Cwebp)

模糊搜索. 有无变化,是增是减. 



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229369907-cf7bc1e2-072c-47f3-8c94-4d520ff5b17d.png?x-oss-process=image%2Fformat%2Cwebp)

改善搜索. 有确定的数字或数字的范围



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229371876-8f4e25e6-2c6a-42d4-8a98-c947a6266475.png?x-oss-process=image%2Fformat%2Cwebp)

选定为搜索结果.  会清空已存在的列表.只放你勾选的列表.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229373947-bf43bac3-4be2-494b-98df-0a442f33d27d.png?x-oss-process=image%2Fformat%2Cwebp)

全部勾选.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229377302-89ce3944-58f7-4f28-a064-5db13bfc2d1f.png?x-oss-process=image%2Fformat%2Cwebp)

反向勾选.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229379614-5c6e25a1-f9a6-4504-a020-a3f80a276d3d.png?x-oss-process=image%2Fformat%2Cwebp)

取消勾选.



Y

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229382089-a63592b2-5f60-4c39-8034-01a502ff9ac6.png?x-oss-process=image%2Fformat%2Cwebp)

 恢复数值. 只能后退一步.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229384672-9abb3b53-2f69-4caa-863a-16aae385c847.png?x-oss-process=image%2Fformat%2Cwebp)

保存到列表.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229388173-fdd3abf3-b373-4af7-bb34-1a21c0233591.png?x-oss-process=image%2Fformat%2Cwebp)

移除.   移除全部, 先恢复再移除, 移除已勾选的.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229391395-59f23e1d-c248-418f-b5f9-232976264e6f.png?x-oss-process=image%2Fformat%2Cwebp)

修改数值.  可以选择冻结.



 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229396232-f5dd2df7-148c-465e-ad75-194abd699678.png?x-oss-process=image%2Fformat%2Cwebp)

执行脚本. 一般是lua文件. 



![image.png](https://cdn.nlark.com/yuque/0/2023/png/29650418/1673229401462-544c2ab5-a4b6-4c0c-b28c-c28800c5ddfa.png?x-oss-process=image%2Fformat%2Cwebp)

 计算偏移量. 要先勾上多个地址.



对于搜出来的一个地址， 点一下，可以修改数值,可以冻结,可以转到，

可以上下看附近的地址，点一下，数据类型看情况,一般整数是D类,小数是F类.

点右上角三横线,往下拉,点击[数值格式],可以选择显示什么类型数值.

# 搜索和跳转地址

## 1.数值类型

![image.png](https://cdn.nlark.com/yuque/0/2022/png/29650418/1661732129521-288d764b-1aa5-4c83-b6ee-5c7ae3c4c658.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_418%2Climit_0)

你想要找到游戏里的一个数字,

那么有2个是必选的.

第一,选择内存范围. 

第二,选择数值类型.  



内存范围,默认勾上前7种即可. 
只是参考,其他的,也可能要用,  以后再说.



![image.png](https://cdn.nlark.com/yuque/0/2022/png/29650418/1661732135078-8e0a914e-767c-4335-be41-ac9ada8599ae.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_242%2Climit_0)

A:Auto    

搜全部，最耗时间。

当你完全不知道数字是什么时,就可以搜A类.

5个整数：
D: Dword   ,整数   ,取值范围 [ -2147483648，+4294967295 ] 
W: Word   ,整数   ,取值范围 [ -32768 , +65535 ] 
B: Byte   ,整数   ,取值范围 [ -128 , +255 ]
Q: Qword   ,整数   ,取值范围特别特别大.不方便写出来.
X：Xor     ,整数   ,跟D类相同. [ -2147483648，+4294967295 ]  



其中
W类,数字比较小,一般小游戏,小单机游戏,可能是这个.
D类是最最常见的,大部分游戏都可能是这个.
Q类,相对较少用, 大型游戏,可能是这个.
B类和X类,没见过,可以忽略.
2个有小数点的：
F:Float     单精度浮点型     正负的,  2的128次方
E:Double   双精度浮点型     范围特别特别大.不方便写出来.

F类,是最常见的,绝大多数是这个.
E类,也很常见,大多数网游 会用这个.

经验之谈,仅供参考,不一定准确： 
D类,W类,Q类,可能存在的是:  关卡,血量,弹匣,子弹,伤害,货币,距离.......
F类,E类 可能存在的是:  后坐力,冷却,人物坐标,物品爆率,强化成功率,技能百分比.......

## 2.模糊搜索

带一个问号的搜索，叫模糊搜索。
选择要搜索的数值类型, 
关于数值类型,在第2课讲得很清楚了,
不知道的人,去看看第2课.

一般来说，小的游戏、小的单机游戏, 搜整数选D类，搜小数选F类 。只是参考,不一定准确.
举个例子, 你想搜武器的伤害值,是一个整数.所以搜D类试试.
你想搜技能的百分比,那就是小数.所以搜F类试试.
当你完全不知道,或者不确定的话, 那就搜A类,这是搜索全部,最耗时间.

搜索完成, 搜到几千万或几十亿个结果,都是正常的.

右上角括号（/），
斜杠左边,是当前界面的一列,显示几个结果.
斜杠右边,是总共搜出了几个结果。
你可以点一下斜杠，修改当前界面的一列,显示几个.
还可以,指定勾选当前界面的,指定范围内的数.
比如:  ≤0   ,就是只勾选负数和0
≥1  ,就是只勾选大于或等于1的.

模糊搜索的4个选项，有变化、无变化，增加了、减少了。 

有些游戏数值，有特殊加密，比如你肉眼可见游戏数字增加了，但实际上对应数字是减少的。
为了避免这种加密情况，我们可以直接用，有变化、无变化。就是不管它增减,只管它是不是改变了.
这样筛选，速度会较慢，而且最后剩余的地址特别多，这个只用于初步筛选，后续还要配合其他筛选。

这个游戏,作者已经帮你们测试过了,
选择Ca内存,模糊搜索D类数值.
我们以萝卜的血量为例子,
去试试能不能找到代表萝卜血量的数值.

暂停,无变化这里,选1次就可以了.
现在,剩下的结果已经不多了,先看看哪个可能是目标.
保存一下, 放到列表这边.  试试 ,冻结.
没错,就是这个了. 
冻结了这个地址,萝卜就不会掉血了. 这就是无敌的萝卜.

前面只用了有变化和无变化.   那么再试试 增加了 减少了

## 3.精确搜索&冻结

放大镜,没问号，叫改善搜索。
肉眼可见的属性数字，大多数可以用改善搜索。


例如，现在，游戏是第1波怪，我们就明确一个数字: 1
同时，在不知道是否有特殊加密的情况下，选择勾上‘此值被加密’.
避免被加密的，搜不出来。
勾上被加密，结果会相对比较多。

Bao Wei Luo Bo 2 这个游戏的关卡数，没加密，能直接搜到。

现在是第1波，搜1 。 
还没到下一波的时候,它还是1,没有变化.
所以可以继续改善1,
相当于模糊的"无变化".
然后2.3.4.5...一直搜索改善。
只剩余几个搜索结果，可以挨个试试，最终找到目标.  
找到了,就这个地址.  保存一下,放到保存列表这边.
我发现,改成超过最终轮数的话，就会直接胜利。

这个关卡数,每一局游戏都会自动归零,从0开始加.
所以,让秒通关效果一直能用,我们应该把这个地址,冻结住,不让它改变.
冻结,就是让它保持指定的数字.不再改变.


举个例子，弹匣有20发，你找到地址，并冻结，你怎么打都是20.
举个例子，你有500货币，冻结为1万，怎么花都是1万。
但是注意，单价2万的东西是买不起的。

提醒，
(1)有些数值不需要冻结，比如改10亿货币,你改一次就够用了.
(2)有些不冻结的话，可能过一会就归零了.
比如当前怪的轮数，你重开一局，它会自动变0.
(3)有一些数值，你冻结的话，会导致程序崩溃.
所以有些时候，冻结需谨慎，避免崩溃。

然后,2,3,4,5,一直搜索改善
如果你的搜索列表不是空的, 存在一些结果.
其实,你不需要清空列表.
改善搜索这里,可以点击'新搜索'.
点击新搜索,它会帮你清空再重新搜索.

## 4.联合搜索

这里再复习一下，W: Word ，整数型 ，取值范围是负32768 到 65535 ，是一个小范围整数。更大范围是D类。

已知一个东西的好几个属性值，可以试试用联合搜索，数字用分号; 隔开    
注意是英文符号，不是中文符号。
已知瓶子炮对应的123级升级消耗金币数， 可搜索：   100;180;260
用联合搜索，你会发现比以前用模糊搜的结果少得多。
缺点是,有些数字,超出了联合范围,就搜不到了.
因为联合搜索的范围是有限制的.

不变的值，可以继续改善，效果相当于使用模糊的“无变化”。
再试试改善搜180，因为我想先改2级瓶子。
结果不是特别多的话，可以批量修改。
现在有18个地址，我们改1是成功了，但是到底哪个才是目标地址呢？
提醒一下，尽量避免一次修改太多地址。比如一次改10个还好，要一次改1千个，可能让游戏崩溃。
批量修改，可以点‘更多’‘增量’。
举个例子，比如1,3,5  .这个数组，增量写2 ，那么就是
1+2 ，
3+2+2 ，
5+2+2+2 ，
结果修改得到3,7,11 
再举个例子，比如1;1;1;1  这个数组 增量写1  得到2;3;4;5 
使用增量，可以更快找到准确地址。  提醒，记得“恢复”其他无关地址。



### 拓展内容

“数组的长度，或者说，组列大小”
随便给两个地址，比如C5580000 和 C5580004  ，这两地址的长度，或者说组列大小是多少呢？
不理解的话，直接写出来，就很直观的看见了：
C5580000 →  C5580001  →  C5580002  →  C5580003  →  C5580004
这个长度、大小就是5 。现在，大概明白什么是组列大小吗？
地址是用十六进制显示，关于十六进制，以后再说。你也可以自行百度，十六进制的加减法。
对于我们已经搜出来的地址，可以勾选后，点第5个图标“两个叠加的方框”，再点添加组列大小。它会自动复制地址的对应数值，并且在最后会显示组列大小。

使用联合搜索的时候，可以限定组列大小，在后面用冒号和数字表示。
例如:  100;180;260:65 
**冒号65意思是：联合搜100和180和260，同时限定这3个数对应的地址总长度，不超过65，超出的话，排除掉。**

更精确的话，用**两个冒号，是按顺序排列的意思**，就是指3个对应地址，必须100开头，180中间，260结尾

如果不用双冒号，那么结果可以是180开头，260中间，100结尾。


现在基本上可以确定这个就是瓶子的三个等级所需金币。

在保存列表的地址，怎么放回搜索列表？
点击右上角三   选定为搜索结果

添加组列大小，我们会看见这个数组的长度是65 ，这是精确值。
我们搜的时候，也可以放大这个值，比如搜100;180;260:500 

如果你不写组列大小,它默认会限定为512
即你搜1;2;3  它会自动搜1;2;3:512
那么我们限定范围的话，它最大长度是多少呢?  是65535 . 
联合搜索是有限制的，地址之间超过了65535 ，就搜不到了。

当我们真正找到了目标数组时，就可以得到准确的组列大小。
100;180;260::65
以后，通过联合搜索这个，就会得到精确地址，不会有其他无关地址，做到精确修改。

## 4.跳转地址

通过第五期的联合搜索，我这里直接给一个数组，100;180;260::65
对了，直接点搜素、新搜索就行。不需要先用模糊去搜类型。
最终搜出3个地址，就是正确的。
对应瓶子的一二三级所需金币。
然后，保存一下3个地址。点击100这个地址，转到。我们要看的是D类。
100, 往下翻，是180，接着是260 。
首先我们知道这游戏有伤害，距离，冷却，升级金币，炮塔分3级，
例如瓶子炮，我们现在明确了一二三级的对应金币地址是挨着很近的。
那么瓶子炮的伤害，距离，冷却......是不是也在这附近呢？
不知道，那就找一下试试看。看什么呢？看一些有规律的、特别的、疑似属性的。
往下看，貌似没有太特别的。
回头，转到，往上看看，有没有可疑的。
看见了180 ，100 ，300 ，240 ，190 ，250 ，400 ，600 ，100 ，80 ，60
是不是很激动？我们应该是找到瓶子炮的所有属性了，都是挨着非常近的，这就很友好。
（偷偷补充一句，用官网原版游戏的话，不同属性值不是挨近的。）
根据三级制，直接给这些数字分组，
60;80;100  伤害
600;400;250 冷却
190;240;300  距离
100;180;260 （已知第4组是升级所需金币）
经过一番修改、测试。确定了，四组数据依次是“伤害，冷却，距离，金币”。
作者总结发现，其他炮塔也是一样的方式。有4组属性，且挨得近，排列也同上。
(例外：魔法球是持续输出，本身无冷却)。 

全部勾选，然后点第5个图标，添加组列大小，复制
60;80;100;600;400;250;190;240;300;100;180;260:449
后面这个449就是组列的精确大小，有了这个数值，我们就可以更精确的搜到目标地址。

# Lua

## 1.入门

### 变量

先去下载好MT或NP管理器，我们使用它来编写lua脚本。

常量:已知的、固定的、不可改变的
比如数字/汉字/标点符号   圆周率π/自然底数e/  Lua提供的函数 等等
变量: 与前者相反，可变的。

> 大致这么理解就行。

**变量在使用前，需要在代码中进行声明，即创建该变量。**
创建变量,就先要给变量取一个名字.
变量取名规则: 
开头只能是: 字母  _下横线
后面只能是: 字母  _下横线  数字
注意,Lua语言是区分大小写的, 大A和小a,不一样.

正确变量名:  A   C_1   _Aa01    O_O   T_T  D_D  SB
错误变量名:  7   x/2   3+4    [a1   k!   50%   @   
提醒: Lua的保留字/关键词，无法用作变量名. 
例如 and	 or 		nil 		not 	true 	local

Lua的变量,默认都是全局变量. 变量的默认值均为 nil  (意思为"空",表示无效值.) 

所谓全局,就是指在程序里的任何地方都可以被调用,不受限制.



局部变量,则是仅局限于某一个区域内,在区域之外的地方是无法调用的,若调用,会发现是nil 无效值. 

局部变量的作用域为"从声明位置开始,到所在语句块结束。"

应该尽可能的使用局部变量，有两个好处：

1. 避免命名冲突。

2. 访问局部变量的速度比全局变量更快。

使用方法是:在变量名前面加上 local  注意有一个空格,跟变量隔开,不可连在一起写.

local 变量名     例如 local A      这样写,变量A就是一个局部变量



### 字符串

Lua 语言中字符串可以使用以下三种方式来声明：

1.单引号间的一串字符    ' '

2.双引号间的一串字符    " "

3.双中括号间的一串字符  [[ ]]

第三种比较不好写,一般不用. 

但是第三种可以 直接打印换行符, 打印多行内容.

如果你需要打印多行内容的话,可以考虑用第三种符号.比如说,打印一首诗歌.



两个小数点..  用于连接两个字符串    

例如  "你好".."吗"       跟    "你好吗"    是相同的打印结果.

### 井字符#

**井字符#  返回字符串或表的长度**。单位是 字节 bit

MT管理器,默认是UTF-8编码格式.

一个英文字母/英文符号/数字, 是占用1个字节长度.

汉字/中文符号 占用3个字节长度.

\#555  返回值为3      #abcde 返回值为5

\#"你好"  返回值是6     #'www.baidu.com'  返回值是13

### print

**用于打印输出的函数print()   **

先新建一个Lua文件,打开

输入你想写的代码   

print('Hello World')   

要习惯点一下右上角的保存.

启动GG修改器,目标进程的话,随便吧.

点击三角形一样的图标,就是执行脚本.

点右边的三个点, 右上角箭头是返回上一层目录,

SD Card      就是内部存储.

找到你之前创建的文件夹和文件.点击执行即可.

第一行是脚本已结束:: 这句话是固定句式.

我们现在打印出来的内容,就是  Hello World.

底下的重启,是重新再执行一次这个脚本.

复制,是复制脚本打印的内容.

确定,就是关闭这个提示框.



print("你好,Lua语言.")
print(A)  

因为你并没有给变量A赋值,所以它是空,无效值.

变量默认都是nil

### 注释

**注释,就是写笔记/解释/声明**

单行注释,用两条短横线  --

多行注释,用--[[    ]]--

## 2.变量赋值&函数

### 变量 

变量名的开头,只能是: 字母 _ 

后面可以是:字母 _ 数字

例如:  xy  xyz   x_y   ab   _a1   

这些都是正确的变量名.

### 赋值&计算

程序代码的整体执行顺序,是从上往下.

 (整体是从上往下执行,局部可能有跳转和循环.)

a=1    --第一行,变量a被赋值为1
a=2    --第二行,变量a被赋值为2
print(a)   --打印a,结果是2
a=3        --第四行,变量a被赋值为3
print(a)   --打印a,结果是3

这就说明,程序是从上往下执行的.



x=2  y=1    --注意,写代码的过程中,符号不能随意用. 这里不能用逗号隔开, 如果写x=1,y=2  加了逗号就会报错. 正确方式,是加空格或换行.
c1=x+y+2*x*y   --这里的意思是x加y加2乘x乘y,计算后赋值给变量c1.可能会有人习惯把x乘y ,写成xy ,这样写会报错.
c2=xy   --因为xy就是一个变量.而x*y是算术式.变量默认值都是nil ,打印xy就是nil .
print(c1,c2) --打印多个变量,需要用逗号隔开.
c3=xy+1  --报错的原因是,算术式中是不可以使用nil去计算的.



如果是多个变量,能不能一起赋值呢?   

注意,不可以写a=b=c=1 ,这样是错误的.  Lua语言禁止连等于

--可以这样写:

a,b=1,2

--这样写的意思是,把1赋值给a ,把2赋值给b  .

--即,把右边第一个数,赋值给左边第1个变量.

a,b,c,d,e=1,2,3,4,5

--这里d的值是多少呢?是4 .   

--总的来说,就是第1个对应第1个,第2个对应第2个,这样对应下去.

如果两边不是正好对应的,怎么办?

a,b,c=1,2

--这样的话,c就是nil ,即为空值.

a,b=1,2,3

--这样的话,3不会被拿来用,相当于是多余的.

a,b=b,a

--这样就是,把b原来的值给a,把a原来的值给b. 两者进行交换.

### 字符串 

使用单引号,或者,双引号.  字符串内容可以写中文和符号.

a1="大家好." 
a2='这网站有好康的 : www.baidu.com'



a3=   5        +    5      --这里,我加好多空格,是为了告诉你们,加多个空格不影响程序执行.a3就是等于10.

顺便提醒一下,  第1课说过,空格和换行可以随便加,说的不太对. 空格和换行随便加的前提,是不能破变量名的完整性.



a=1+1
p  r     i n t  (a) 

--空格把一个完整的函数名都分开了,是不行的.



a=1  b=2   

这样的, 可以这样加换行:

a=1


b=2

--不破坏变量名的完整,就可以随便加换行的.



可以这样加空格:

a=        1  
b       =        2
print(    a      , b       )

除非空格是在字符串内的,否则会被程序忽略掉.





a3 = 5 + 5
a4 = " 5+5 "
print(  a3, a4 )      --对于字符串,程序会把引号里的内容打印出来,而不会去计算里面的算术式.

### 转义字符

转义字符:表示不能直接显示的字符，比如后退键，回车键，等 

\n   是换行.  这个符号之后的字符串内容,会放到下一行.  其他转义字符少用,先不提了.

提醒:  \n  作为转移字符,必须用在字符串中, 更直观的说就是写在引号中.否则会报错.



print( '大\n家\n好' )

print(a  \n  b)  --这样写就会报错.

正确写法是  print( a .. '\n' .. b )    --连接字符串,需要两个小数点..



另外补充一点:

..   两个小数点是用来 连接字符串 的字符

一定要注意它的使用对象.

常规用法,只有两种:

第一种     用来连接两个字符串          比如   '你' .. '好'

第二种     用来连接字符串和数字      

比如   '结果个数: '  .. k       --这个变量k是 数值型.  是一个数字.

比如   '搜出 '  .. k .. '个结果'      --假设k=8,那么打印结果就是    搜出 8个结果

(为什么 明明说是 "用来连接字符串" ,却能用来连接数字呢?  那是因为 Lua语言可以自动转换.  自动把"数值型"转为"字符串型")

### 函数



function 函数名(参数)
	语句块
end



函数名=function(参数)
	语句块
end



函数名也是一个变量名,取名规则是一样的.

(这个函数名,会自动设置为 局部变量 .  参数可以不写, 如果写了,参数也会自动设为 局部变量)

"语句块"就是执行代码,

你想让这个函数执行什么,做什么,都可以写进去.

两种函数写法,是一样的,看个人习惯吧.

函数名在后面的,对于新手来说,更方便理解.



function k()
print('你好啊')
end
k()	--调用函数k

函数可以不写参数.

在这里,我们定义了一个函数,名为k ,作用是打印"你好啊"这个字符串.

最后写的k()   就是调用函数.

这点非常重要,请谨记,很重要: 

程序不会主动去执行一个函数的语句块,只是把函数存起来,在调用的时候,才去执行这个函数的语句块.

如果你并没有调用这个函数,程序就不会执行这个函数.

例如现在这个函数k,如果你不调用,程序就不会执行里面的打印"你好啊".

就好像程序是瞎子,看不见一样,不知道你想做什么.



function A(i)
local  i = i * i  
print( i )
print( i .. '你好啊' )
end

A(3)
print(i)  



这里,自定义一个函数A,参数是i.

这是一个局部变量i,i的值只在这个函数内有效.

这行代码是计算i的平方,再赋值给i

打印这里,我使用了连接符号,就是两个小数点,用于连接字符串.

A(3)的意思,就是调用函数A,你给了参数,为3,

程序就会根据你给的参数,3,调用函数,去执行语句块.



在这个函数外调用 i  会发现i是nil,  即无效值,它就是一个全新的,没有赋值的变量i.

函数的返回  return  



思考: 自定义一个函数,有两个参数,用来计算两个参数的平方和.



function Y(m,n)
local P=m*m+n*n 
return P 
end

Y(2,3)  --这里就是你在告诉程序,要调用函数Y,而且你给了参数为2和3,程序开始调用,并执行语句块,计算P=2*2+3*3得13. 然后retrun P , 就是把P的值返回给函数.此时Y(2,3)的值就是13.
y=Y(2,3)  --然后,再随便拿一个变量来接收这个值.

print(y)  --最后,打印出这个值.



再回过头来看一看, 在Y(2,3)这里,可能有人会有一些疑问,比如,我能不能写Y(2),当然不能.

函数是你自己去定义的,是你规定要有两个参数, 就不能破坏规矩了. 不给两个参数,都会报错.



其实代码可以更精简,爱学习的可以看看,自己思考一下:

function Y(m,n)
return m*m+n*n
end
print(   Y(2,3)  )

## 3.流程结构

### 判断

**if  判断的满足条件   then   语句块     end**

一句话描述就是:
如果满足了条件,就执行语句块,不满足就结束.

注意  end 作为结束的声明, 必须写出来,别忘了.

(补充:下面的所有变量a,都属于数值.就是一个数字)

思考一下怎么写,
如果a是负数,就打印"这是一个负数".

~~~lua
a=-5
if a<0 then   
    print('这是一个负数')   
end 
~~~

判断语句的第一种写法,是满足就执行,不满足就结束了.

那么,不满足条件,我也想执行语句块,怎么办?

那就加入else 

~~~lua
if  判断的满足条件 then
    语句块1
else  
    语句块2
end
~~~

用一句话描述:
如果满足了条件,就执行语句块1, 否则就去执行语句块2.



最后是第三种判断语句.

如果我想让每一次的判断,都执行一个语句块,要怎么办?

加入 elseif 

~~~lua
if 满足的条件 then  语句块
elseif 满足的条件   then  语句块
else 满足的条件   then  语句块
 ------(可以写很多个 elseif ... then...)
end
~~~

### 循环

#### while

~~~lua
while 满足的条件 do
	循环语句块
end
~~~

思考一下,怎么把1到9的整数打印出来.

~~~lua
k=1
while k<=9 do
	print(k)
	k=k+1
end
~~~

#### **repeat**

这个循环,跟while是相反的.  不是满足条件就继续, 而是恰恰相反 ,  是不满足条件才继续,要是满足就停止了.

用俗话来说, 就是你在做一件事,要做到令人满意为止, 不合格就要一直做下去,直到令人满意就不用做了.

~~~lua
repeat  
    先循环语句块
until  停止的条件.
~~~

repeat 循环语句,
是先不看条件,先执行一次语句块,然后去看条件,
不满足就继续,一直到满足才结束.注意这个不需要end作为结束.
repeat 是一直执行到满足为止.

~~~lua
--打印1到9的整数
k=1
repeat  
    print(k)  
    k=k+1
until k>9
~~~

#### for

~~~lua
for 变量=初始值,终止值,步长 do    
	语句块
end
~~~

用一个比较形象的比喻来说,
就是几个人按顺序排好队,依次跳水.
比如有9个人要跳水.
从1号开始,一直到9号,一个个跳进水里.
这个1号,叫做'初始值'.9号,叫做'终止值'
他们排队的间隔距离,叫'步长', 这个不写的话, 默认是1
步长, 可以省略不写, 不写的话,就等于1.

~~~lua
for  A=1,9   do
	print(A)
end

for D=10,2,-2 do
	print(D*D) 
end
~~~

把小学的乘法口诀表,打印出来. (提示,请使用两个for do 循环)

~~~lua
for a=1,9 do
	H=''
	for b=1,9 do
		if a>=b then 
            H=H..a..'×'..b..'='..a*b..'   ' end 
		end
	print(H)
end 
~~~

## 4.type&table

> 补充：
>
> Lua 是动态类型语言
> 变量不需要去定义类型,可以直接给变量赋值。
> 比如,变量k,
> 你不需要声明k是什么类型.
> 你想给什么值,就给什么.
> 你让k是字符串,还是布尔值,还是数值,等等, 
> 随便你.不需要提前声明.

### type

type(变量名)   作用是'获取该变量的类型'
例如 type(k)

Lua语言的所有变量,默认值都是nil     .
"变量默认都是无效值"

~~~lua
print(k,  type(k)  ..'类型'  )

k='你好'
print(k,  type(k)  ..'类型'  )

k=123
print(k,  type(k)  ..'类型'  )

k=false
print(k,  type(k)  ..'类型'  )

k=function() end
print(k,  type(k)  ..'类型'  )  

k={3;5;7}
print(k[3],  type(k)  ..'类型'  )
~~~

Lua语言的变量,有6种类型.
分别是布尔型,字符串型,函数型,数字型,nil,表

### table

lua语言,表是非常非常重要的.
1,表用大括号{ } 来构造 . 可以是多维的.例如二维表 {  { }  }
2,表是一个关联数组.每个值也可称为元素.
3,表有类似于门牌号的索引,称为"键".
4,表默认的键,是正整数,1,2,3,4,5......
5,表可以自定义键名,取名规则跟变量名一样.
6,表中的每一个元素,都会有一个对应的,唯一的键.
7,表中元素的删除,就是把该元素设为nil
8,表可以传递, 跟变量的赋值一样. 
9,表的元素有多少个,可以用#来获取.但不一定准确.

> \#k 用井号获取表的元素个数时,
> 必须是程序默认分配的键.  从1开始的正整数.
> 否则无法用# 获取正确的个数,会得到错误答案.
> 比如有键[1] [2] [3]还有键'a' 'b' 'c'  这样用#获得到个数是3 是错误的答案.
> 只有键是[1] [2] [3]...... 是按顺序的正整数,而且中间没有缺损 没有中断, 才能用#获取正确个数.

~~~lua
k={ '华硕' ,'微星' , '技嘉' , '七彩虹'  }
print(k)
~~~

可以看出,程序自动为这个表,分配了键,
是从1开始的正整数.
键1, 值为 华硕
键2, 值为 微星
键3, 值为 技嘉
键4, 值为 七彩虹



怎么打印表中的某个键对应的值呢?
k,中括号,1,就表示键1的值.

~~~lua
print( k[1] )
print( k[2] ,k[3] ,k[4]  ) 

k={  '铭瑄' ,  '昂达' ,  s='华擎'  }
print(k)
~~~

> 我们自定义了一个键,
> 这个键,不是默认分配的数字,而是s
> 所以注意了,要打印这个值, 
> 使用中括号时,里面记得加引号, 应该写 k['s']
> 其实,还有另一个方法.
> 不用中括号,直接用一个小数点.
> k.s      ,也可以表示键s的值
> 用小数点的,只能用于自定义的键,
> 默认分配的数字键,不能用小数点,必须用中括号.
> 不能写k.1,只能写k[1]

~~~lua
k={  10 , 20  , c=30 ,  a=40 ,  _=50  ,  '猪'  }
print(k)
~~~

> 程序分配键的时候,会跳过自定义键.再接着分配.
> 所以,键1对应10   ,键2对应20,  键3对应猪.
> 中间有3个自定义键,跳过了.
> 打印表时,它会自动排序,先打印数字,
> 然后是_,最后是字母.
> 并不是按照你看见的,从左往右的顺序打印表.

~~~lua
k={  '3060显卡' ,  '首发2499元' }
print(k)

--想修改某个键的值,直接用等号就行.
k[2]='50元包邮'
print(k)

k[1]=''3070''
print(k)

--删除某个元素,就是让该元素为nil
--但是,程序并不会重新分配.键；这点要注意,原来是键2的,并不会变成键1
k[1]=nil
~~~

Lua语言提供了一个专门的函数,用于实现删除元素.
table.remove(表名,键位)

~~~lua
table.remove(k,1])  
~~~

> 这个效果,跟上面的k[1]=nil ,是有区别的.
> 用remove函数删除键之后,整体会往前移动,取代删除的位置.



获取表的元素有多少个. 可以用#

> \#k 用井号获取表的元素个数时,
> 必须是程序默认分配的键.  从1开始的正整数.
> 否则无法用# 获取正确的个数,会得到错误答案.
> 比如有键[1] [2] [3]还有键'a' 'b' 'c'  这样用#获得到个数是3 是错误的答案.
> 只有键是[1] [2] [3]...... 是按顺序的正整数,而且中间没有缺损 没有中断, 才能用#获取正确个数.

新元素的加入.
\#k ,是元素有几个. 
再+1就是在最后的位置,新增一个值.

~~~lua
k[#k+1]='BTC归零'   
print(k)
~~~



Lua语言提供了一个专门的函数,用于实现加入新元素.
table.insert(表名,放在哪个键位, 新加的值)

~~~lua
--不写键位的话,默认就是加到最后面.
table.insert(k ,  2 , '矿难到来' )
~~~

> 这里意思是,给表.k.加入新元素, 键是2,值是'矿难到来' .
> 那么原来的键值怎么办?会集体往后挪动一个位置.
> 原来的键2变成键3了. 以此类推.

**表可以是多维的. **

# GG常用函数

> 通用法则: ⑴Lua语言区分大小写, 使用数字, 英文/ 标点符号, 不可使用中文/ 符号. ( 字符串文本内容除外) ⑵用一个空格,还是无数个空格,是否换行,到换无数行,这种'分隔手段','排版方式'均不影响程序运行. ⑶一个函数的不同参数之间, 使用逗号作为分隔. 作为最后一个参数的, 就不需要加逗号了. ⑷Lua用几个单词合成的函数名,第2个单词或之后的单词,都要首字母大写.例如getTargetPackage. ⑸一个函数有多个参数时, 当指定了某个参数, 则这个参数之前的参数都必须写出来, 不可忽略, 在这 个已指定参数后的, 都可以忽略不写. 例如一个函数有7个参数, 当你指定参 数3, 则必须写出参数1/2, 但可以忽略不写参数4/5/6/7. 例如gg.toast("555") 只写参数1, 省略 参数2 . 不省略的话, 则是gg.toast("555",false) 两者运行结果完全一致.

## 1.提示

### toast

瞬时的消息提示。 此提示不太起眼, 不属于置顶层, 且不可触摸. 大约显示1秒钟就会消失. 

~~~lua
gg.toast( 
	string text, --参数1, 字符串文本 . 记得加引号 
    bool fast=false --参数2, 布尔值. 默认是false .可填true, 显示时间更短暂. 
) 
~~~

 这个参数几乎没有写出来的必要，因为不管是false还是ture，感官上都只是一瞬间，区别不大。 提醒，当连续使用多个toast 无间隔的话，只能显示最后一个提示，前面的会被覆盖。 

实际例子:

 一, 字符串需要加 单引号' ' 或 双引号" " gg.toast(' 这里是叶子Jinn, 写的教程',false) 

二, 连续多次的toast, 只显示最后一句. gg.toast("555") gg.toast("777") --这样运行后, 只能看见777的提示. 

三, gg.toast(“ 开启成功”,ture)

### alert

警示框，显示一个、两个、三个按钮的置顶的弹出式的对话框。 默认自带一个' 确定' 按钮。 

返回: 数字0 1 2 3 中的一个. 取决于按下了哪个按钮。分别是: 右1 中2 左3 对话框取消是0 

可以使用“手机自身的返回按 钮"或"点击对话框外的区域"取消对话框。（返回0） 

~~~lua
alert(
    string text, --参数1，字符串文本。 警示的文本内容 ，记得加引号 
    string positive, --参数2，字符串。 按钮1 默认是”确定”2字。在右侧 返回值是1 
    string negative,  -- 参数3，字符串。按钮2 在中间偏右侧 返回值是2 
    string neutral --参数4，字符串。按钮3 在左侧 返回值是3 
) 
~~~

> 参数值为`nil`，则不显示相关按钮

实际例子: 

一, gg.alert('a1' ） 

二, gg.alert(" 是否接受可能存在的使用风险并自愿承担使用后果？"," 我接受"," 我拒绝") 

三, gg.alert("",a,nil," 再见") -- 引号内留空，就是空白内容。a是空值，相当于填的是nil 

四, k=gg.alert(" 返回值的测试"," 右"," 中"," 左") print(k) gg.getRanges( ) 获取内存区域。 

返回： 数字. 有15种。 总共有15种内存范围。写在括号内的, 别忘记加 gg. 数字形式：print(gg.getRanges()) 打印出来的是数字

1. REGION_JAVA_HEAP →2 
2. Jh 内存：Jh=2 REGION_C_HEAP →1 
3. Ch 内存：Ch=1 REGION_C_ALLOC →4 
4. Ca 内存：Ca=4 REGION_C_DATA →8 
5. Cd 内存：Cd=8 REGION_C_BSS →16 
6. Cb 内存：Cb=16 REGION_PPSSPP →262144 
7. PS 内存：PS=262144 REGION_ANONYMOUS → 32 
8. A 内存：A=32 REGION_JAVA →65536 
9. J内存：J=65536 REGION_STACK →64 
10. S内存：S=64 REGION_ASHMEM→524288 
11. As内存：As=524288 REGION_VIDEO →1048576 
12. V内存：V=-2080896 REGION_OTHER→-2080896 
13. O内存：O=-1032320 REGION_BAD →131072 
14. B内存: B=131072 REGION_CODE_APP →16384 
15. Xa内存：Xa=16384 REGION_CODE_SYS →32768 
16. Xs内存：Xs=32768

## 2.基本

### setRanges

设置内存区域。 

设定进行搜索的内存区域范围 . 可以用数字形式, 或者形如gg.REGION\_* 

返回: 数字, 有15种.

`gg.setRanges(int ranges)` 只有参数1： gg.REGION_* 共有15种( 可用数字形式表示) ，具体看最后面。 

选多种内存，用竖线隔开 | 常见的是A,Ca,Cb,Cd,Ch,PS,Jh （GG前7种） 

实际例子： 

一、设置为Ca内存 gg.setRanges(gg.REGION_REGION_C_ALLOC) 

二、设置为Ca/A内存 gg.setRanges(gg.REGION_REGION_C_ALLOC | gg.REGION_ANONYMOUS) 

总共有15种内存范围： ( 别忘了 前面加上gg.) 

1. REGION_ANONYMOUS 
2. REGION_ASHMEM 
3. REGION_BAD
4. REGION_C_ALLOC 
5. REGION_C_BSS 
6. REGION_C_DATA
7. REGION_C_HEAP 
8. REGION_CODE_APP 
9. REGION_CODE_SYS
10. REGION_JAVA 
11. REGION_JAVA_HEAP 
12. REGION_OTHER
13. REGION_PPSSPP 
14. REGION_STACK 
15. REGION_VIDEO

### getRangesList

获取所选进程的内存区域。 

返回： 带有内存区域的表。 

表每个元素带有6个参数：state 、start 、end、type 、name、internalName 。 

1. state : 15 种内存区域 英文简写之一. Jh . Ca. Ch. Cd. Cb. A. PS. J . S. As. O. V. B. Xa. Xs 
2. start : 起始值，是一个数字。 
3. end : 终值，是一个数字。 
4. type : 权限, r--p r--xp rw--p r--s ---p r 读 w 写 x执行 
5. name、internalName : 两个参数是一样的。 输出的是一个路径. 

实际例子： 

一、获取Ca内存区域的前100个元素的'start'参数，并打印输出。 

~~~lua
gg.setRanges(4) 
A=gg.getRangesList() 
for i=1,100 do 
    print(A[i].start) 
end 
~~~



二、参数中 含有 libc.so 的元素 `print(gg.getRangesList('libc.so')) `

三、参数中，形如 lib\*.so 的元素 `print(gg.getRangesList('lib*.so')) `

> `*` 是正则匹配字符，"匹配前一个字符0次或多次，最长匹配"。

四、参数中有以/data/ 开头的元素 `print(gg.getRangesList('^/data/')) `

> ^ 是正则匹配字符，"匹配字符串开头"。 

五、参数中有以.so 结尾的元素 

`print(gg.getRangesList('.so$'))` 

> $ 是正则匹配字符，"匹配字符串结尾"。 

六、获取Ca内存区域的第1000~1050个元素的'state' 和'end' 参数，并打印输出。 

~~~lua
gg.setRanges(4) 
A=gg.getRangesList() 
for i=1000,1050 do 
    print(A[i]['state']..'→'..A[i]['end']) 
end
~~~

### searchNumber

使用指定的参数执行数字搜索。 

如果结果列表是空的，则执行新搜索; 若列表不是空的, 则优化搜 索( 改善搜索). 

返回: true 或字符串错误.

~~~lua
gg.searchNumber(
    string text, 
    int type=gg.TYPE_AUTO, 
    bool encrypted=false, 
    int sign=gg.SIGN_EQUAL, 
    long memoryFrom=0, 
    long memoryTo=-1, 
    long limit=0 ) 
~~~

> 一共有7个参数, 参数之间用逗号 , 作为分隔 。依次为： 
>
> 1. 参数1. text 字符串文本。 注意加引号。 
> 2. 参数2. type 数值类型。可用常量gg.TYPR\_* 表示, 可用数字形式. 注意英文形式, 不可省略gg. 
> 3. 参数3. encrypted 运行搜索加密值的标志。 此值已加密, 用true. 默认是false 此值不加密 
> 4. 参数4. sign 标志。其中常量gg.SIGN_* 默认gg.SIGN_EQUAL是' 标记相同' , 不可略写gg. 
> 5. 参数5. memoryFrom 开始搜索的内存地址 , 默认是0 , 不限制开始 
> 6. 参数6. memoryTo 结束结束的内存地址 , 默认是-1, 不限制结束 
> 7. 参数7. limit 限度. 找到指定数量的结果后停止搜索。默认是0, 表示搜索所有结果. 
>
> 提醒：在已 指定参数之前的参数不可略写, 之后的参数可以略写。

1. ['TYPE_AUTO'] = 127	A类：AUTO=5 
2. ['TYPE_DWORD'] = 4	D类：DWORD=4 
3. ['TYPE_FLOAT'] = 16 	F类：FLOAT=16 
4. ['TYPE_DOUBLE'] = 64	E类：DOUBLE=64 
5. ['TYPE_WORD'] = 2	W类：WORD=2 
6. ['TYPE_BYTE'] = 1	B类：BYTE=1 
7. ['TYPE_QWORD'] = 32	Q类：QWORD=32 
8. ['TYPE_XOR'] = 8	X类：XOR=8

实际例子： 

一、数值为700，D类 gg.searchNumber('700',4) --省略的参数，分别为默认的false,SIGN_EQUAL,0，-1,0 若 是参数不省略，可以写成 gg.searchNumber('700',4,false,gg.SIGN_EQUAL,0,-1,0) 

二、数值只知范围是-1到1，F 类 gg.searchNumber('-1~1',16) 

三、只知数组的范围59~61;80;99~101::65 ，W 类 gg.searchNumber("59~61;80;99~101::65",2) 

四、搜W 类，数值是400，从 0xBCB70000 到 0xBCB7FFFF , 不加密 gg.searchNumber('400',2,false,gg.SIGN_EQUAL,0xBCB70000,0xBCB7FFFF) 

五, 数组60;80;100 ,W 类, 只需要搜出前12个结果. gg.searchNumber("60;80;100",2,false,gg.SIGN_EQUAL,0,-1,12)

### getResults

加载结果。 将搜索结果加载到结果列表中，并将其作为表返回。 

（勾选目标，并读取目标地址对应的 数值、字节长度、常量类型，存储为表的形式） 

返回结果： 包含结果的表或包含错误的字符串。 每个元素都是一个包含三个键的 表：['address'] 地址、['flags'] 类型、['value'] 数值 

根据这个返回的结果, 可以实现' 偏移 写法' \

~~~lua
gg.getResults( 
    int maxCount, -- 参数1，加载结果的最大计数 
    int skip = 0, -- 参数2，跳过/ 省略 前几个搜索结果。默认是0个。也可填nil 
    long addressMin = nil, -- 参数3，地址的最小值。或 nil 空 
    long addressMax = nil, -- 参数4，地址的最大值。或 nil 空 
    string valueMin = nil, -- 参数5，值的最小值。或 nil 空 
    string valueMax = nil, -- 参数6，值的最小值。或 nil 空 
    int type = nil, -- 参数7，值的类型 gg.TYPE_* 或数字形式。或 nil 空 
    string fractional = nil, -- 参数8，按分数值过滤。如果第一个字符是“！”，过滤器将排除小数部分与 指定部分匹配的所有值。 
    int pointer = nil -- 参数9，指针。 gg.POINTER_* 。或 nil 空
)
~~~



实际例子： 

一、加载前12个搜索结果。 

gg.searchNumber(100,4) gg.getResults(12)

二、加载前4个结果，并跳过前3个 

gg.searchNumber(100,4) gg.getResults(4,3) 

三、加载前100个结果，并已知值范围 是1.5~1.6 ，是F类数值。 gg.searchNumber("1.1~2.1",16) gg.getResults(100,nil,nil,nil,1.5,1.6,16) 

四、如果搜索列表是空的，将返回一个空表 

{ --table( ) } A=gg.getResults(10) print(A) 
脚本已结束： { -- table(1b2d242) } 

五、 返回值。 

gg.searchNumber(444,4) A=gg.getResults(1) print(A) 
脚本已结束：: { -- table(e6de086) [1] = { -- table(cd59d47) ['address'] = 0x78f49f90788c, ['flags'] = 4, -- gg.TYPE_DWORD ['value'] = 444, },

### clearResults

清空搜索结果列表。

### getResultsCount

获取结果计数。 获取当前搜索结果列表, 总共有几个结果。若列表是空，则是0个。 

返回： 数字。找到的结果的数量。

实际例子 

一, 获取搜索结果有几个. 

gg.searchNumber('555',2) print(gg.getResultsCount()) -- 我的打印结果是: 22 

二, 判断搜索列表是否为空, 是空列表则发出警告. A=gg.getResultsCount() 

if A==0 then print("当前没有任何搜索结果！请检查" ) end

### editAll

修改所有加载过的搜索结果。 

在调用此函数之前，必须通过gg.getResults() 加载结果。 

返回: 数字, 改了几个值. 或者 字符串错误 

~~~lua
gg.editAll( 
    string value, --参数1，字符串值。填写: 你想要改成的值. （可用数组，看实例三的说明。） 
    int type -- 参数2，要修改的数值类型 。可用数字形式, 有8种.
)
~~~



实际例子： 

一、 数值是10，D类，只要前5个，全改成88 gg.searchNumber("10",4) --D 类可用数字4来表示 gg.getResluts(5) -- 加载前5个搜索结果 A=gg.editAll("88",4) -- 把加载的5个地址的D类值都改成88 print(A) -- 打印结果是5. 意思是修改了5个值. 

二、 数值是55，W 类，只要前3个，依次改成10 20 30 gg.searchNumber("55",2) --W 类可用数字2来表示 gg.getResluts(3) -- 加载前3个搜索结果 gg.editAll("10;20;30",2) -- 把加载的3个地址的W 类值 依次改成10,20,30 

三、数值 是55，W 类，要前9个结果，改成99,99,99,1,1,1,99,99,99 gg.searchNumber("55",2) gg.getResults(9)--加载前9个搜索结果 gg.editAll("99;99;99;1;1;1",2) -- 加载计数> All 数组数量，则会循环排列赋值。 -- 循环 排列赋值的意思是：把All 数组接着排列下去，直到跟加载计数一致，再一一对应赋值。 -- 例如加载计数5个，editAll 数组是'3;7' 则会循环排列为3;7;3;7;3 而对应赋值。 gg.getResults(5) gg.editAll("3;7",2) -- 这样的5个结果将改成3 7 3 7 3

### loadResults

重新加载结果. 从表中加载搜索结果, 现有搜索结果将被清除。 

返回: true 或错误字符串。 

实际例子: 

一, 搜索555 ,D 类, 重新加载前3个结果. gg.searchNumber('555',4) A=gg.getResults(3) gg.loadResults(A) print(A)

### removeResults

删除搜索结果的列表. 清空列表. 

返回: true 或 字符串错误.

## 3.单选&多选

### choice

选择框。 显示列表中的选择对话框。列表是由项目表组成的。 

返回： 根据用户点击了表项第几项，返回一个数字。 不选则返回: nil

~~~lua
gg.choice(
    table items, --参数1，是一个项目表 { }
    string selected, --参数2，填数字或nil。显示一个勾选框，若数字等于表项数则勾选该项，否则均不勾选。
    string message --参数3，字符串标题 。 可略写
)
~~~

实际例子： 

一、 gg.choice({" 开启秒杀"," 关闭秒杀"," 退出" }) 

二、 gg.choice({" 开杀"," 关杀"," 退出" }nil," 作者：叶子" ) 

三、 gg.choice({" 透视 开"," 透视 关" },3,"*** 游戏脚本" ) -- 因为项目表只有 第1、第2项，所以参数2写3 则均不勾选。 若参数2写1，则勾选第1项"透视 开" 

四、print(gg.choice({" 第一项"," 第二项"," 第三项",' 第四项' })) 

五、A=gg.choice({"1. 金","2. 木","3. 水","4. 火","5. ?" },0) if A==5 then print(" 五行缺土" ) end

### multiChoice

多项选择对话框。 

返回： 已选择的项，则该键值返回true, 其他均为nil 

~~~lua
gg.multiChoice( 
    table items, --参数1，表项 . { } 多项用逗号, 隔开 
    table selection=, --参数2，表项的选择状态。选中则为键值=true,全都不选中可写 {}, 
    string message = nil --参数3，字符串信息、标题。可不写
)
~~~



 实际例子: 

T=gg.multiChoice ( {' 瓶子',' 粑粑',' 关闭脚本'}, {[1]=true}, ' 萝卜2脚本' ) if T[1]==true then a1=gg.choice({' 伤害',' 冷却' },1) end if T[2]==true then a2=gg.choice({' 伤害',' 冷却' },0) end if T[3]==true then os.exit() end

## 4.查/改值&特征码

### 偏移量

简单说一下,什么是偏移量.
通俗来说,从地址1走到地址2,要走几步,才能到达?
这个走几步,就是偏移.
地址1 + 偏移量 = 地址2

我们一般使用的地址,都是十六进制的. 
(什么是十六进制,十六进制加减法,自己去百度吧,这里就不教了.)
要注意一下.跟我们日常生活的十进制不一样.
当然,都是用计算器来算.不需要我们口算.

2个或者以上的地址,
在搜索列表这里的话,先勾上你想计算的地址,点击右上角的三横线,点击计算偏移,点击偏移量: 即可看见计算结果,
点这一行字,可以复制这个计算结果.  拿去粘贴.
在保存列表的话,直接点第4个小图标即可.

已知一个地址,想计算某个偏移量之后的地址是多少.
点击右上角的三横线,点击偏移量计算器. 写一个地址,写偏移,即可看到计算后的地址...

0x22C00004 + 0xC = 0x22C00010 
用俗语来说,就是从地址22C00004开始,要往前走C步,就走到了地址0x22C00010

可以反方向走,是用减号.
0x22C00010 - 0xC = 0x22C00004
用俗语来说,就是从地址0x22C00010开始,后退C步,就到了地址0x22C00004

在GG的界面上看,一个地址,往下就是加,往上就是减

0x22C00004
0x22C00008
0x22C0000C
0x22C00010
0x22C00014

### getValues

获取搜索列表项目的值。 

注意: 这个函数, 若是调用GG公共函数的返回值, 则只能用gg.getResulte() 加载得到的返回值. 

当然, 也可以自己创建新的表, 注意是有三个键的表 : address flags value 

返回: 带有Results 结果的新表( 二维数组). 或者 字符串错误. 

二维数组的每个元素是一个具有三个键的表: address flags value 

1. address: 地址/ 基址. 返回的是十进制数. 要转成十六进制可用函数string.format("%X",\*) 
2. flags : 15 种数据类型 ( 常量TYPE_* ). 返回的是数字形式 
3. value : 数值 

实际例子: 

一, 输出搜索结果列表的地址/ 值/ 类型 gg.clearResults() gg.setRanges(4) gg.searchNumber("999",4) A=gg.getResultCount() B=gg.getResults(A) C=gg.getValues(B) for i=1,A do print('地址:'..string.format("%08X",C[i].address)..'值:'..C[i].value..' 类型: '..C[i].flags) end 

脚本已结束：: 地址: C7CE0108 值: 999 类型: 4 地址: C8A7C018 值: 999 类型: 4

二, 加载搜索结果第一个地址, 偏移+0x4 , 新地址的值打印 A=gg.getResults(1) B=gg.getValues({{ address=A[1].address+0x4, flags=4, }}) print(B) 

脚本已结束：: { -- table(c46625b) [1] = { -- table(951caf8) ['address'] = 0x1342cbe0, ['flags'] = 4, -- gg.TYPE_DWORD ['value'] = 2, }, }

三, 自定义一个表, 再获取输出. 提醒, 必须用二维数组, 一维是无法给value 赋值的. 

K={{ value=480, address=0xC5580000, flags=16}} gg.getValues(K) print(K) print('地址:'..string.format("%08X",K[1].address)..'值: '..K[1].value..' 类型: '..K[1].flags) 

脚本已结束：: { -- table(facc9d6) [1] = { -- table(3955457) ['address'] = 0xc5580000, ['flags'] = 16, -- gg.TYPE_FLOAT ['value'] = 480, }, } 

地址: C5580000 值: 480 类型: 16 

### 特征值

1. 通过函数getValues 获取目标周围的2千个值.
2. 复制打印结果, 粘贴到一个文本 1.txt 中
3. 彻底重启游戏.  重新获取目标周围2千个值.
4. 复制打印结果, 粘贴到一个文本 2.txt 中
5. 去对比 两个文本的数字.
6. 从对比的结果中,寻找一些特别的数,尝试搜索,是否具有唯一性.
7. 若具有唯一性,则可以当做'特征码'. 记下偏移量,即可用于'偏移写法'.

> 最后：
>
> 1. 一般习惯是: 找目标附近的  比较特殊的几个数, 来当”特征码”。一般不考虑有规律的数...   ,没有规律的 反而更好找...
> 2. 试试联合搜索 这个数组.  ,最好搞清楚组列大小；要确定是不是一直有效,还得彻底重启游戏 再搜搜看；反复几次,依然可以准确地搜到. 这基本就可以说明是正确的,可用的
> 3. 最后: 直接搜出目标, 用计算器,去计算偏移量  即可。取特征码地址,只需要取第一个就行.

~~~lua
--这是一个简易的文本对比的代码. 直接复制 到.lua  即可使用.
--偶尔会报错,很正常.重新运行几次,不行就重启GG,换一个GG.
local readFile = function (pathname)
	local Jinn = {}
	for i=1,math.huge do
		Jinn[i] = pathname:read('*l')
		if Jinn[i] == nil then
			return Jinn
		end
	end
end

local File = gg.prompt({'文件1路径','文件2路径'},{gg.getFile(),gg.getFile()},{'file','file'})
if File then
	    local C1 = io.open(File[1],'r')
	    local C2 = io.open(File[2],'r')
	if C1 == nil or C2 == nil then
		local C1 = io.open(File[1],'w')
		local C2 = io.open(File[2],'w')
	end
	    local C1 = io.open(File[1],'r'):read('*a')
		local C2 = io.open(File[2],'r'):read('*a')
		local File1 = readFile(io.open(File[1],'r'))
		local File2 = readFile(io.open(File[2],'r'))
	io.open('对比之后.txt','w')
	for i=1,math.huge do
		if File1[i] == nil and File2[i] ~= nil then
			io.open('对比之后.txt','a+'):write('\n')
		elseif File1[i] ~= nil and File2[i] == nil then
			io.open('对比之后.txt','a+'):write('\n')
		elseif File1[i] ~= File2[i] and File1[i] ~= nil and File2[i] ~= nil then
			io.open('对比之后.txt','a+'):write('\n')
		elseif File1[i] == File2[i] and File1[i] == '0' then
		    io.open('对比之后.txt','a+'):write('\n')
		elseif File1[i] == File2[i] and File1[i] ~= nil and File2[i] ~= nil and File1[i] ~= '0' then
			io.open('对比之后.txt','a+'):write(File1[i]..'\n')
		else
			gg.alert('对比完成  文件在同目录  "对比之后.txt"','懂了')
			print('注意  0 已被过滤......\n 对比的文件在同目录下  "对比之后.txt"\n ')
			os.exit()
		end
	end
end
~~~

**最好使用E类特征码，因为E类数据长度长，更容易找到特征值**

~~~lua
--这个脚本的作用: 先自己搜出目标,放在搜索列表第一位, 然后获取前100个,后100个值.打印出来
if gg.getResultsCount()==0 then
gg.alert('自己先搜出目标\n并放在搜索列表第一位','先自己去找出目标','自己先搜') os.exit() 
else  k=gg.getResults(1) end
for i=-100,100 do
local y=gg.getValues( {[1]={ address=k[1].address+i*0x4 , flags=64, value=nil }})
print(y[1].value)    
end

-- local KK={  前面的200个E类值  }
for i=1,#KK do 
gg.searchNumber(  KK[i] , 64 ) 
local yy=gg.getResultsCount() 
if yy==1  then print(  KK[i]  )  end 
gg.clearResults() 
end
~~~



### setValues 

设置/ 修改 项目表的参数. 

所设置的项目表, 是一个包含三个键的表/ 二维数组: address value flags 

返回: True 或字符串错误。

实际例子: 

一, 实现基址偏移写法

gg.clearResults() gg.setRanges(4) gg.searchNumber("60;80;120::65",2)  X=gg.getResults(1) gg.setValues({ { address=X[1]. address+0x80, flags=4, value=999 }})

二, 已知( 联合搜索) 特征码, 且要修改50个目标, 已知地址之间的偏移量是固定值, 为20  

gg.clearResults() gg.setRanges(4)  gg.searchNumber("30029;12131;25975;16943;27764;28781::21",2) --2是W类 A=gg.getValues(gg.getResults(1))  B={{address=A[1].address+0x2AC}}--把2AC改成特征码到第一个目标地址的偏移量,注意 正负 R= 50 -- 一共要改几个地址 R=R+1 for i=2,R do Y=(i-2)*0x20 -- 20 是你的固定偏移量. 是负的话, 下一行用 - Y gg.setValues({{  address=B[1].address+Y, value=999, flags=4 }}) end ---999是你想要的值, 4 是值类型

三, 不使用setValues 函数, 其实也可以实现一些该函数类似的设 置/ 修改项目表的功能. K={ } K[1]={ } K[1].address=0xABCD1234 K[1].flags=4 K[1].value=999 R=11 for i=2,R do Y=(i-1)*0x4 -- K[i]={ } K[i].address=K[1].address+Y K[i].value=999 K[i].flags=4  end print(K)

## 5.UI可见性

### isVisible

UI 可见性。 检查GG修改器的UI 界面 是否打开。 

返回： 布尔值。 true / false GG 界面打开，是true 。 GG界面关闭，是false 

A=gg.isVisible() print(A)

### setVisible

设定打开或关闭GG用户界面。true/false 

返回： 布尔值。 true / false 

GG 界面打开，是true , 否则是false  

一般用于点击列表选择框 时，隐藏GG界面。 

A=gg.choice({"1","2","3","4"},0) if A<1 or A>4 then gg.setVisible(true) else gg.setVisible(false) end

## 6.保存列表

### addListItems

添加到'' 保存列表'', 将搜索结果列表的项目添加到保存列表中。 注意单词是add list items 

返回: true 或字符串错误. 

~~~lua
gg.addListItems(
    table items	--一个表,二维数组. 表的每个元素有8个参数.
) 
~~~

> 1. `.address` (long), 地址 
> 2. `.value` (number), 数值 
> 3. `.flags` (one of the constants TYPE_*),数值类型, 返回的是数字形式
> 4. `.name` (string), 字符串
> 5. `.freeze` (boolean), 布尔值 冻结是true , 默认是false 不冻结
> 6. `.freezeType` 其中的常数 是 FREEZE__* 默认FREEZE_NORMAL 
> 7. `.freezeFrom` (string), 字符串 
> 8. `.freezeTo` (string),字符串

### getListItems

将保存列表的内容作为表返回。 

注意单词是get list items 

`gg.getListItems()`

### saveList

将保存列表的内容, 保存到文件中。 

返回: true 或字符串错误. 

~~~lua
gg.saveList( 
    string file, --参数1, 文件路径 
    int flags = 0 --参数2, 属性. 默认是0. 可以写 SAVE_AS_TEXT 保存为文本格式.
)
~~~

实际例子 一, 不写参数2的 

Var #C7EB4634|c7eb4634|4|3c|0|0|0|0|rw-p|[anon:libc_malloc]|b4634 

二, 参 数2写,0 的 

Var #C7EB4634|c7eb4634|4|3c|0|0|0|0|rw-p|[anon:libc_malloc]|b4634 

三, 参 数2写, gg.SAVE_AS_TEXT 的 

Ca; C7EB4634; Var #C7EB4634; 60; Dword 

四, 获取搜索结果计数, 加载, 并放到保存列表, 最后导出到txt 文件. 

A=gg.getResultCount() B=gg.getResults(A) gg.addListItems(B) gg.saveList( '/storage/emulated/0/Download/自制的脚本/保存 列表的输出1.txt',gg.SAVE_AS_TEXT)

### clearList

清空保存列表。 

返回： true 或 字符串错误

### removeListItems

从保存的列表中删除项目。 

返回: true 或错误字符串。 

`gg.removeListItems(table items)` 

实际例子: 

t = {}
t[1] = 0x18004030 t[2] = 0x18004040 gg.removeListItems(t) print(t)

## 7.其他

### Sx小按钮

**`gg.showUiButton()`**

显示UI 按钮。 只有当你打开GG界面时才会看到UI 按钮, 有一个" Sx”的小图 标. 

按钮是浮动的, 可移动位置，显示在GG界面的上层 

返回: true 或 false . 按钮被点击了返回true , 否则 返回false.

实际例子: 

一, 

function M() gg.alert("点击了" ) end while true do gg.showUiButton() if gg.isClickedUiButton() == true then M() end end 

二, 

function T() T=gg.multiChoice ( {' 瓶子',' 粑粑',' 关闭脚本'}, {[1]=true}, ' 萝卜2脚本' ) if T[1]==true then a1=gg.choice({'伤害','冷却' },1) end if T[2]==true then a2=gg.choice({'伤害','冷却' },0) end if T[3]==true then os.exit() end end while true do gg.showUiButton() if gg.isClickedUiButton() == true then T() end end

### 时间日期

### 输入框

**`gg.prompt()`**

输入框。 显示数据输入对话框。 

返回： 如果对话框已被取消，则为nil ，或者为带有提示键和输入字段值的表。 

~~~lua
gg.prompt(
    table prompts, --参数1，该表指定了每个输入字段的键和说明。 
    table defaults, --参数2，该表指定了提示中每个键的默认值。 要想留空可写nil 
    table types = {} --参数3，有八种输入类型. 
)
~~~

> 注意三个参数在数量上要一致。参数2可用nil 表示空
>
> 三个参数只能用表{}的形式每个参数内的多个键之间用逗号,隔开。并依次为[1],[2] ,[3] 等等
>
> 参数3的八种类型：
>
> 1. number 数值 
> 2. text 文本 
> 3. path 文件路径 
> 4. file 文件 
> 5. new_file 新文件 
> 6. setting 背景 
> 7. speed 速度 
> 8. checkbox 复选框

   

实际例子: 

一, 

T=gg.prompt( {' 卡密' }, {nil}, {'text'} ) if T[1]=='123' then gg.alert('验证成功' ) else gg.alert('卡密错误' ) os.exit() end

二, 

A=gg.prompt( {" 欢迎使用叶子登陆器","",' 口令' }, {[1]=' 账号',[2]=' 密码',[3]= nil}, {[1]="number",[2]="text",[3]='text' }) --print(A[1]..'\n'..A[2]) if A[1]=='1' and A[2]=='2' and A[3]=='是' then gg.setVisible(false) gg.alert(" 验证通过，欢迎使用。" ) else gg.alert("输入错误，请检查。" ) end

三,

local A=gg.prompt( {[1]="欢迎使用" }, {[1]="输入口令" }, {[1]="text"}) print(A) local A=gg.prompt( {[1]="选择文件路径" }, {[1]="/sdcard/"}, {[1]="path"} ) print(A) local A=gg.prompt( {[1]=" 文件路径" }, {[1]="/sdcard/"},{[1]="file"}) print(A) local A=gg.prompt( {[1]="选择一个文件" }, {[1]=false}, {[1]="checkbox"} ) print(A) local A=gg.prompt( {[1]="886"}, {[1]=false},{[1]="checkbox" }) print(A)

### 保存变量

**`gg.saveVariable()`**

保存变量. 将变量保存到文件中。 

执行的结果将是得到一个. lua 文件 只储存strings, numbers, tables . 

参考链接( 表序列化) http://lua-users.org/wiki/TableSerialization 

返回: true 或者字符串错误. 

~~~lua
gg.saveVariable( 
    mixed variable, -- 要保存的变量 
    string filename -- 保存文件的完整路径。
)
~~~



实际例子: 

t = {} t['test1'] = {1, 2, 3, 4} t['test2'] = 33 t['test3'] = 88.88 t['test4'] = "www" t[4] = t['test1'] gg.saveVariable(t, "/storage/emulated/0/Download/实际例子. lua") 

运行后得到的lua 文件内容: 

local a,b,c,d,e,f,g,h,v,t='address','value','flags','name','freeze','freezeType' ,'freezeFrom','freezeTo',nil v={{['test3']=88.88;['test4']='www';['test2']=33;[4]=nil;['test1']=nil;}; {1;2;3;4;};} t=v[1] t[4]=v[2] t['test1']=v[2] return v[1]

### 搜索指针

**`gg.searchPointer()`**

搜索指针. 搜索可能是指向当前搜索结果元素的指针的值。 

只能接受二维数组. 数组至少有2个参数: address 和flags (value 可以没有) 

返回: true 或错误字符串 

~~~lua
gg.searchPointer ( 
    int maxOffset , -- 指针的最大偏移量。有效值为0 ~ 65535 
    long memoryFrom = , -- 搜索的起始内存地址. 默认0 是无限制 
    long memoryTo = , -- 结束搜索的内存地址。 默认-1 是无限制 
    long limit = 0 -- 找到指定数量的结果后停止搜索。0表示搜索所有结果。
)
~~~



实际例子: 

一:  gg.searchNumber('60;80;100;600;400;250;190;240;300;100;180;260::449',4) gg.searchNumber('180',4) gg.searchPointer(100) 

二:

A=gg.getResultsCount() gg.getResults(A) gg.searchPointer(100) print(gg.getResults(10)) 

三: 

T = {} T[1] = {} T[1].address = 0x18004030 T[1].flags = gg.TYPE_DWORD T[2] = {} T[2].address = 0x18004040 T[2].flags = gg.TYPE_BYTE gg.loadResults(T) gg.searchPointer(999)

### 杀死进程

**`gg.processKill()`**

杀死进程. 强制终止选定的进程。 

返回: 成功后返回true , 否则为false. 

注意事项: 如果调用这个太频繁，脚本可能会被中断. 可能会导致应用数据丢失。 

实际例子: 一般用于验证卡密, 输入错误后, 杀死进程 A=gg.prompt({' 输入卡密' },{nil},{'text'}) if A[1]=='11' then gg.alert('验证成功' ) else gg.processKill() gg.alert(' 卡 密错误! 应用被关闭.' ) end

### 获取目标进程信息

**`gg.getTarget()`**

获取目标程序信息. 

返回: 一个表. 包含目标程序的各种信息. 或者返回nil 

参数有很多, 例如: 

1. firstInstallTime 首次安装时间. 
2. lastUpdateTime 最后更新时间. 
3. packageName 包名. 
4. versionName 版本号. 
5. x64 true 是64位软件, false 为32位软件 . 
6. 等等, 具体参数往下看打印实例结果.

~~~lua
A=gg.getTargetInfo()
print(A)
if A.x64==true then
    gg.alert('这是64位软件' ) else gg.alert('这是32位软件' ) end
~~~
打印结果如下:
~~~tex
脚本已结束：:
{ -- table(4e31368)
    ['RSS'] = 225644,
    ['activities'] = { -- table(f092381)
        [ 1] = { -- table(67b9c26)
            ['label'] = ' 保卫萝卜2',
            ['name'] = 'com.carrot.iceworld.CarrotFantasy',
        }, -- 为节省篇幅, 已省略[2]-[10].
        [11] = { -- table(a7efbac)
            原创作者: 叶子Jinn
            叶子Jinn 叶子Jinn
            叶子Jinn
            ['label'] = ' 保卫萝卜2',
            ['name'] = 'cn.uc.paysdk.SDKActivity',
        },
    },
    ['className'] = 'com.carrot.iceworld.CmgameApplication',
    ['cmdLine'] = 'com.carrot.iceworld',
    ['dataDir'] = '/data/user/0/com.carrot.iceworld',
    ['descriptionRes'] = 0,
    ['enabledSetting'] = 0,
    ['firstInstallTime'] = 1651373085136.0,
    ['flags'] = 948485700,
    ['icon'] = 2131099795,
    ['label'] = '保卫萝卜2',
    ['labelRes'] = 2131492917,
    ['lastUpdateTime'] = 1651373085136.0,
    ['logo'] = 0,
    ['name'] = 'com.carrot.iceworld.CmgameApplication',
    ['nativeLibraryDir'] = '/data/app/com.carrot.iceworldJQCbpbWNnylk0rbfNyGtWw==/lib/x86',
    ['packageName'] = 'com.carrot.iceworld',
    ['pid'] = 26077,
    ['processName'] = 'com.carrot.iceworld',
    ['publicSourceDir'] = '/data/app/com.carrot.iceworldJQCbpbWNnylk0rbfNyGtWw==/base.apk',
    ['sharedUserLabel'] = 0,
    ['sourceDir'] = '/data/app/com.carrot.iceworldJQCbpbWNnylk0rbfNyGtWw==/base.apk',
    ['targetSdkVersion'] = 26,
    ['taskAffinity'] = 'com.carrot.iceworld',
    ['theme'] = 16973838,
    ['uid'] = 10064,
    ['versionCode'] = 790,
    ['versionName'] = '5.0.0',
    ['x64'] = false,
~~~

### 获取目标进程包名

**`gg.getTargetPackage()`**

获取目标进程的包名. 

返回: 软件包名 . 一般是 com. 为开头. 

实际例子: 

print(gg.getTargetPackage()) 
打印结果: com.carrot.iceworld

## 常量参数附录

官方文档：[gg Class Reference - GG help - GameGuardian](https://gameguardian.net/help/classgg.html)

### 内存范围

| 名称         | 常量名=常量值               |
| ------------ | --------------------------- |
| Jh内存       | ['REGION_JAVA_HEAP'] = 2    |
| Ch内存       | ['REGION_C_HEAP'] = 1       |
| Ca内存       | ['REGION_C_ALLOC'] = 4      |
| Cd内存       | ['REGION_C_DATA'] = 8       |
| Cb内存       | ['REGION_C_BSS'] = 16       |
| Ps内存       | ['REGION_PPSSPP'] = 262144  |
| A内存        | ['REGION_ANONYMOUS'] = 32   |
| J内存        | ['REGION_JAVA'] = 65536     |
| S内存        | ['REGION_STACK'] = 64       |
| As内存       | ['REGION_ASHMEM'] = 524288  |
| V内存        | ['REGION_VIDEO'] = 1048576  |
| O内存(慢)    | ['REGION_OTHER'] = -2080896 |
| B内存(危险)  | ['REGION_BAD'] = 131072     |
| Xa内存(危险) | ['REGION_CODE_APP'] = 16384 |
| Xs内存(危险) | ['REGION_CODE_SYS'] = 32768 |

### 数据类型

| 类型          | 常量名=常量值        |
| ------------- | -------------------- |
| A：Auto（慢） | ['TYPE_AUTO'] = 127  |
| D：Dword      | ['TYPE_DWORD'] = 4   |
| F：Float      | ['TYPE_FLOAT'] = 16  |
| E：Double     | ['TYPE_DOUBLE'] = 64 |
| W：Word       | ['TYPE_WORD'] = 2    |
| B：Byte       | ['TYPE_BYTE'] = 1    |
| Q：Qword      | ['TYPE_QWORD'] = 32  |
| X：Xor        | ['TYPE_XOR'] = 8     |
| 其他省略...   |                      |

### searchNumber

gg.searchNumber的第4个参数：

| 常量名                   | 解释              |
| ------------------------ | ----------------- |
| gg.SIGN_EQUAL            | 标记_相同的       |
| gg.SIGN_GREATER_OR_EQUAL | 标记_更大或相同的 |
| gg.SIGN_LESS_OR_EQUAL    | 标记_更小或相同的 |
| gg.SIGN_NOT_EQUAL        | 标记_不相同的     |

### searchFuzzy

gg.searchFuzzy()的第2个参数：

| 常量名                  | 解释   |
| ----------------------- | ------ |
| gg.SIGN_FUZZY_EQUAL     | 等于   |
| gg.SIGN_FUZZY_NOT_EQUAL | 不等于 |
| gg.SIGN_FUZZY_LESS      | 小于   |
| gg.SIGN_FUZZY_GREATER   | 大于   |

### 指针常量

gg.getResults() 的参数8 :  形如 POINTER_

| 常量名                      | 解释                       |
| --------------------------- | -------------------------- |
| POINTER_NO                  | 非指针                     |
| POINTER_READ_ONLY           | 指向只读内存的指针         |
| POINTER_WRITABLE            | 指向可写内存的指针         |
| POINTER_EXECUTABLE          | 指向可执行内存的指针       |
| POINTER_EXECUTABLE_WRITABLE | 指向可执行和可写内存的指针 |

### IO权限

| 字符串 | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| r      | 以只读方式打开文件，该文件必须存在。                         |
| w      | 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 |
| a      | 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） |
| r+     | 以可读写方式打开文件，该文件必须存在。                       |
| w+     | 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 |
| a+     | 与a类似，但此文件可读可写                                    |
| b      | 二进制模式，如果文件是二进制文件，可以加上b                  |
| +      | 号表示对文件既可以读也可以写                                 |

### 日期时间

函数os.data的指示符：

| 表达式 | 解释                                          |
| ------ | --------------------------------------------- |
| %y     | 取最后两位数的年份。 例如  98  ，范围 [00~99] |
| %Y     | 完整的年份。例如  2022                        |
| %m     | 月份数。 例如  09  ，范围 [01~12]             |
| %d     | 一个月中的第几天。 例如  16  ，范围 [01~31]   |
| %H     | 24小时制中的小时数。 例如  23  ，范围 [00~23] |
| %I     | 12小时制中的小时数。 例如  11  ，范围 [01~12] |
| %M     | 分钟数。 例如  49  ，范围 [00~59]             |
| %S     | 秒数。 例如  10  ，范围 [00~59]               |
| %p     | 上午是  AM      下午是  PM                    |
| %j     | 一年中的第几天。 例如  259  ，范围 [001~366]  |
| %w     | 一星期中的第几天。 例如  3  ，范围 [0~6]      |
| %a     | 一星期中天数的简写。 例如  Wed                |
| %A     | 一星期中天数的全称。 例如 Wednesday           |
| %b     | 月份的简写。 例如  Sep                        |
| %B     | 月份的全称。 例如  September                  |
| %c     | 日期和时间。 例如   Thu Jul 21 11:11:05 2022  |
| %x     | 日期。 例如   07/21/22                        |
| %X     | 时间。 例如   23:48:10                        |

