## element-ui

### dialog

- 使用`<el-dialog>` 时出现了遮罩层把弹框都遮住的情况。解决方法：给标签加上 `append-to-body`

- 出现了页面（元素）的移动，它的遮罩层会给body加上`padding-right=20px`。问题分析：[element e-dialog弹窗导致页面偏移，body上多了样式"padding-right: 17px" 解决办法 - 掘金 (juejin.cn)](https://juejin.cn/post/7008495519794200612) 解决方法：标签上加上`:lock-scroll="false"`

### el-form

如果使用了表单的`resetFields`方法，即使属性不需要使用rules校验，也要加上prop属性，不然该表单value无法被重置。

## vue

### $refs

使用$refs获取组件时，获取的对象为null 或 调用获取对象的方法/属性报错 该函数/属性不存在。

原因：组件还未渲染出来

解决方法：

- 使用`this.$nextTick(() => { 之前的代码写在这 })`
  - nextTick：该方法保证在下次事件循环中执行
- vue2中：可以使用`setTimeout(() => { 代码 }, 0)`，以让代码在下一次事件循环中执行

### 非响应式数据

添加/追加的动态属性，是不具备响应式特定的。

解决方法：可以用`this.$set(目标对象, 属性名称, 初始值)`

~~~vue
<script>
  export default {
    name: '',
    data() {
      return {
				obj: {}
      }
    },
    methods: {
      getObj() {
        // 这样添加的数据是响应式的
        this.obj = {
          name: 'lisi',
          age: 12
        }
        // 这样添加的数据不是响应式的
        this.obj.sex = '男'
        // 应该这么添加
        this.$set(obj, sex, '男')
      }
    }
  }
</script>
~~~

### 刷新404

history模式下，vue-router 使用浏览器的History API来管理路由，可以在不重新加载页面的情况下修改URL；但也正因为如此，页面的url并不是真实存在的，所以刷新会404。

解决方法：如果使用了nginx，可以将所有页面代理到index.html（根页面），注意解决某些路径时真的不存在的问题（最后加一个路由：{ path: '*', component: NotFoundComponent }）

### useRouter().xxx报错

vue3中setup里面，useRouter() 返回的是一个响应式的路由对象，而直接访问 .xxx 可能会在路由初始化之前被执行，从而导致未定义错误或其他问题。

通过 `const router = useRouter(); router.xxx` 的方式可以确保 useRouter() 被调用，并将路由实例保存在 router 变量中。这样，通过 `router.xxx` 就能在正确的时机、在路由初始化之后获取到当前的路由信息。

另一种解决方法是直接引入router：`import router from '@/router'`

### push方法报错

在非vue文件，如`js/ts`中，是不能使用`useRouter`来获取router对象的，需要直接引入router来使用

## 浏览器

### sockjs报错

解决方法：找到/node_modules/sockjs-client/dist/sockjs.js中的`self.xhr.send(payload)`，把这行注释掉即可

## element-plus

### ElMessage不显示

描述：自动导入时，请求拦截器中使用ElMessage.error()不显示（访问`"/"`时）

解决方法：检查一下是不是vscode给你自动加上了`import { ElMessage } from 'element-plus'`，把该自动导入删除掉。

原因：当配置了自动导入时，如果手动导入了某组件时，一定要手动把该组件的样式已导入；不然由于组件缺少样式，导致无法显示

## TS

### 导入ts类型报错

具体：Uncaught SyntaxError: The requested module '/node_modules/.vite/deps/vue-router.js?v=7c8084c9' does not provide an export named 'RouteRecordRaw'

原因：使用了export type方式的导出类型，需要用import type方式导入。

~~~ts
// 方法1：
import { type RouteRecordRaw } from 'vue-router'
// 方法2：
import type { RouteRecordRaw } from 'vue-router'
~~~

补充：Typescript 3.8`版本中专门引入了`import type`和`export type，[使用原因]([import 和 import type的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7111203210542448671))。在TypeScript中，import type是一种特殊的导入形式，它只导入类型，而不导入值。这意味着**在运行时，这种导入不会产生任何实际的代码**。这对于避免在JavaScript输出中产生不必要的代码，或者解决循环依赖问题非常有用。
