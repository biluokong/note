# 数据结构和算法

### 行先列后

遍历数组时，外层循环应该先遍历行，内层循环遍历列。这样能充分利用空间的局部性原理，提升程序的性能。

原理：

* cpu 读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了
* 缓存的最小存储单位是缓存行（cache line），一般是 64 bytes，一次读的数据少了不划算啊，因此最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其**临近的数据**，这就是所谓**空间局部性**

### 不用charAt

字符串的charAt方法获取字符的效率比较低，可以通过toCharArray方法获取字符数组，再从字符数组中获取单个字符，这样效率有比较大的提升。

# JDK

### 反射

#### 通过方法引用获取属性名

关键：获取到`SerializedLambda`对象，而获取此对象需要先获取`writeReplace`方法，而此方法只有该类实现了`Serializable`接口才会有，所以需要`SFunction`实现序列化接口。

补充：SerializedLambda是Java提供的关于lambda表达式的序列化方案。当需要对实现了Serializable接口的lambda表达式进行序列化时，Java虚拟机会将其转换成SerializedLambda对象，从而进行序列化操作。这个过程中，虚拟机会添加一个writeReplace()方法。SerializedLambda类存储了Lambda表达式的运行时信息，以确保Lambda表达式序列化的正确性和安全性。

~~~java
public class Lambda {
	public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
		SFunction<User, String> function = User::getUsername;
		Method method = function.getClass().getDeclaredMethod("writeReplace");
		method.setAccessible(true);
		Object name = method.invoke(function);
		SerializedLambda serializedLambda = (SerializedLambda) name;
		System.out.println(serializedLambda);
		String implMethodName = serializedLambda.getImplMethodName();
        // 获取get方法名
		System.out.println(implMethodName);
	}
}


@FunctionalInterface
interface SFunction<T, R> extends Serializable {
	R apply(T t);
}

class User {
	private String username;

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}
}
~~~

# websocket

导入依赖：springboot版本-2.7.6

~~~xml
dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
~~~

配置类：

~~~kotlin
@Configuration
class WebSocketConfig {
	@Bean	//创建ServerEndpointExporter对象，作为bean放入容器，它可以自动注册使用了@ServerEndPoint注解的bean
	fun serverEndpointExporter(factory: LettuceConnectionFactory): ServerEndpointExporter {
		factory.validateConnection = true	//检查redis的连接是否断开，断开就重连（但检测和重连时间较长）
		return ServerEndpointExporter()
	}
}
~~~

EndPoint类：（不是单例的，建立一个连接就创建一个）

~~~kotlin
@ServerEndpoint("/chat/{username}")
@Component
class ChatEndpoint {

	companion object {
		// 用来存储每一个客户端对象对应的ChatEndpoint
		private val onlineUsers = ConcurrentHashMap<String, Session>()
		private lateinit var msgService: MsgService
	}

	private lateinit var username: String

	@Resource
	fun setMsgService(msgService: MsgService) {
		ChatEndpoint.msgService = msgService
	}

	@OnOpen    // 连接建立时被调用
	fun onOpen(session: Session, @PathParam("username") username: String) {
		onlineUsers[username] = session
		this.username = username
		val msgList = msgService.getList(username)
		//把用户之前不在线时暂存于redis的消息发送给用户
		msgList.forEach { session.basicRemote.sendText(it) }
		msgService.removeList(username)
	}

	@OnMessage    // 接收到客户端发送的数据时被调用
	fun onMessage(message: String, session: Session) {
		val toName = JsonUtils.getStringValue(message, Message::toName)
		//如果是心跳包
		if (toName == "ping") return LogUtils.info("接收到了一个心跳包：${session.requestURI}")
		val toSession = onlineUsers[toName]
		if (toSession == null) {    // 当前用户不在线，先把消息暂存于redis
			try {
				msgService.save(message, toName)
			} catch (e: Exception) {
				// 客户端需检查消息的fromName是否为error，为error代表消息发送失败
				val json = JsonUtils.toJson(Message(username, e.message ?: "发送失败", "error"))
				session.basicRemote.sendText(json)
				LogUtils.error(e.message, e)
			}
		} else {
			toSession.basicRemote.sendText(message)
		}
	}

	@OnClose    // 连接断开时被调用
	fun onClose(session: Session) {
		onlineUsers.remove(username)
	}

	@OnError
	fun onError(session: Session, t: Throwable) {
		LogUtils.error("socket -> ${t.message}", t)
	}
}
~~~

# 算法

## DFA

Deterministic Finite Automaton（确定有穷自动机），可以用于检查文本中是否包含一些敏感词，效率高。

存储：需要一次性把敏感词都存储到map中；`isEnd`表示是否到了词尾。

判断是否包含敏感词：遍历文本的每个字，如果该字在map中，则从该字对应的value（map）中检查isEnd，为0继续检查下一个字是否在该value中，为1则返回true；某次检查到字不在map中，返回false。

例子：冰毒、大麻、大坏蛋。

~~~js
{
    "冰": {
        "毒":{
            "isEnd": 1
        },
        "isEnd": 0
    },
    "大": {
        "麻": {
            "isEnd": 1
        },
        "isEnd": 0,
        "坏": {
            "蛋": {
                "isEnd": 1
            },
            "isEnd": 0
        }
    }
}
~~~

~~~java
public class SensitiveWordUtil {

	public static Map<String, Object> dictionaryMap = new HashMap<>();

	public static void initMap(Collection<String> words) {
		if (words == null) {
			System.out.println("敏感词列表不能为空");
			return;
		}

		// map初始长度words.size()，整个字典库的入口字数(小于words.size()，因为不同的词可能会有相同的首字)
		Map<String, Object> map = new HashMap<>(words.size());
		// 遍历过程中当前层次的数据
		Map<String, Object> curMap = null;

		for (String word : words) {
			curMap = map;
			int len = word.length();
			for (int i = 0; i < len; i++) {
				// 遍历每个词的字
				String key = String.valueOf(word.charAt(i));
				// 当前字在当前层是否存在, 不存在则新建, 当前层数据指向下一个节点, 继续判断是否存在数据
				Map<String, Object> wordMap = (Map<String, Object>) curMap.get(key);
				if (wordMap == null) {
					// 每个节点存在两个数据: 下一个节点和isEnd(是否结束标志)
					wordMap = new HashMap<>(2);
					wordMap.put("isEnd", "0");
					curMap.put(key, wordMap);
				}
				curMap = wordMap;
				// 如果当前字是词的最后一个字，则将isEnd标志置1
				if (i == len - 1) {
					curMap.put("isEnd", "1");
				}
			}
		}
		dictionaryMap = map;
	}

	private static int checkWord(String text, int beginIndex) {
		if (dictionaryMap == null) {
			throw new RuntimeException("字典不能为空");
		}
		boolean isEnd = false;
		int wordLength = 0;
		Map<String, Object> curMap = dictionaryMap;
		int len = text.length();
		// 从文本的第beginIndex开始匹配
		for (int i = beginIndex; i < len; i++) {
			String key = String.valueOf(text.charAt(i));
			// 获取当前key的下一个节点
			curMap = (Map<String, Object>) curMap.get(key);
			if (curMap == null) {
				break;
			} else {
				wordLength++;
				if ("1".equals(curMap.get("isEnd"))) {
					isEnd = true;
				}
			}
		}
		if (!isEnd) {
			wordLength = 0;
		}
		return wordLength;
	}

	public static Map<String, Integer> matchWords(String text) {
		Map<String, Integer> wordMap = new HashMap<>();
		int len = text.length();
		for (int i = 0; i < len; i++) {
			int wordLength = checkWord(text, i);
			if (wordLength > 0) {
				String word = text.substring(i, i + wordLength);
				// 添加关键词匹配次数
				if (wordMap.containsKey(word)) {
					wordMap.put(word, wordMap.get(word) + 1);
				} else {
					wordMap.put(word, 1);
				}

				i += wordLength - 1;
			}
		}
		return wordMap;
	}
}
~~~

# 技术

## OCR

### Tess4J

封装了Google开源的OCR引擎：Tesseract-OCR。

可以继续其他语言的训练：https://tesseract-ocr.github.io/tessdoc/

~~~xml
<groupId>net.sourceforge.tess4j</groupId>   <artifactId>tess4j</artifactId>   <version>4.1.1</version>
<!--还需要导入相关语言的字体库-->
~~~

~~~java
//创建Tesseract对象
ITesseract tesseract = new Tesseract();
//设置字体库路径（不包含文件名）
tesseract.setDatapath(dataPath);
//中文识别（参数为字体库文件的名称，不需要后缀）
tesseract.setLanguage(language);
//执行ocr识别
String result = tesseract.doOCR(image);
//替换回车和tal键  使结果为一行
result = result.replaceAll("\\r|\\n", "-").replaceAll(" ", "");
return result;
~~~

