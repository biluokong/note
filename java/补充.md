# 数据结构和算法

### 行先列后

遍历数组时，外层循环应该先遍历行，内层循环遍历列。这样能充分利用空间的局部性原理，提升程序的性能。

原理：

* cpu 读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了
* 缓存的最小存储单位是缓存行（cache line），一般是 64 bytes，一次读的数据少了不划算啊，因此最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其**临近的数据**，这就是所谓**空间局部性**

### 不用charAt

字符串的charAt方法获取字符的效率比较低，可以通过toCharArray方法获取字符数组，再从字符数组中获取单个字符，这样效率有比较大的提升。

# JDK

### 反射

#### 通过方法引用获取属性名

关键：获取到`SerializedLambda`对象，而获取此对象需要先获取`writeReplace`方法，而此方法只有该类实现了`Serializable`接口才会有，所以需要`SFunction`实现序列化接口。

补充：SerializedLambda是Java提供的关于lambda表达式的序列化方案。当需要对实现了Serializable接口的lambda表达式进行序列化时，Java虚拟机会将其转换成SerializedLambda对象，从而进行序列化操作。这个过程中，虚拟机会添加一个writeReplace()方法。SerializedLambda类存储了Lambda表达式的运行时信息，以确保Lambda表达式序列化的正确性和安全性。

~~~java
public class Lambda {
	public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
		SFunction<User, String> function = User::getUsername;
		Method method = function.getClass().getDeclaredMethod("writeReplace");
		method.setAccessible(true);
		Object name = method.invoke(function);
		SerializedLambda serializedLambda = (SerializedLambda) name;
		System.out.println(serializedLambda);
		String implMethodName = serializedLambda.getImplMethodName();
        // 获取get方法名
		System.out.println(implMethodName);
	}
}


@FunctionalInterface
interface SFunction<T, R> extends Serializable {
	R apply(T t);
}

class User {
	private String username;

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}
}
~~~

# websocket

导入依赖：springboot版本-2.7.6

~~~xml
dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
~~~

配置类：

~~~kotlin
@Configuration
class WebSocketConfig {
	@Bean	//创建ServerEndpointExporter对象，作为bean放入容器，它可以自动注册使用了@ServerEndPoint注解的bean
	fun serverEndpointExporter(factory: LettuceConnectionFactory): ServerEndpointExporter {
		factory.validateConnection = true	//检查redis的连接是否断开，断开就重连（但检测和重连时间较长）
		return ServerEndpointExporter()
	}
}
~~~

EndPoint类：（不是单例的，建立一个连接就创建一个）

~~~kotlin
@ServerEndpoint("/chat/{username}")
@Component
class ChatEndpoint {

	companion object {
		// 用来存储每一个客户端对象对应的ChatEndpoint
		private val onlineUsers = ConcurrentHashMap<String, Session>()
		private lateinit var msgService: MsgService
	}

	private lateinit var username: String

	@Resource
	fun setMsgService(msgService: MsgService) {
		ChatEndpoint.msgService = msgService
	}

	@OnOpen    // 连接建立时被调用
	fun onOpen(session: Session, @PathParam("username") username: String) {
		onlineUsers[username] = session
		this.username = username
		val msgList = msgService.getList(username)
		//把用户之前不在线时暂存于redis的消息发送给用户
		msgList.forEach { session.basicRemote.sendText(it) }
		msgService.removeList(username)
	}

	@OnMessage    // 接收到客户端发送的数据时被调用
	fun onMessage(message: String, session: Session) {
		val toName = JsonUtils.getStringValue(message, Message::toName)
		//如果是心跳包
		if (toName == "ping") return LogUtils.info("接收到了一个心跳包：${session.requestURI}")
		val toSession = onlineUsers[toName]
		if (toSession == null) {    // 当前用户不在线，先把消息暂存于redis
			try {
				msgService.save(message, toName)
			} catch (e: Exception) {
				// 客户端需检查消息的fromName是否为error，为error代表消息发送失败
				val json = JsonUtils.toJson(Message(username, e.message ?: "发送失败", "error"))
				session.basicRemote.sendText(json)
				LogUtils.error(e.message, e)
			}
		} else {
			toSession.basicRemote.sendText(message)
		}
	}

	@OnClose    // 连接断开时被调用
	fun onClose(session: Session) {
		onlineUsers.remove(username)
	}

	@OnError
	fun onError(session: Session, t: Throwable) {
		LogUtils.error("socket -> ${t.message}", t)
	}
}
~~~

