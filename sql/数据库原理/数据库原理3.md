数据库基础知识（第1、2章）
==============

概念模型
----

#### 一、模型的三个世界

1.  现实世界
2.  信息世界：即根据需求分析画概念模型（即E-R图），E-R图与DBMS无关。
3.  机器世界：将E-R图转换为某一种数据模型，数据模型与DBMS相关。

**注意：信息世界又称概念模型，机器世界又称数据模型**

#### 二、实体及属性

1.  实体：客观存在并可相互区别的事物。
2.  属性：实体的特性或联系的特征都称为属性。
3.  关键词（码、key）：能唯一标识每个实体又不含多余属性的属性组合。

**一个表的码可以有多个，但主码只能有一个。**

例：借书表（学号，姓名，书号，书名，作者，定价，借期，还期）

**规定：学生一次可以借多本书，同一种书只能借一本，但可以多次续借。**

1.  实体型：即二维表的结构  
    例 student(no，name，sex，age，dept)
2.  实体集：即整个二维表

#### 三、实体间的联系：

1．两实体集间实体之间的联系

*   1：1联系
    
*   1：n联系
    
*   m：n联系
    

2．同一实体集内实体之间的联系

*   1：1联系
*   1：n联系
*   m：n联系

#### 四、概念模型（常用E-R图表示）

实体型：□

属性：○

联系： ◇

说明：  
① E-R图作为用户与开发人员的中间语言。  
② E-R图可以等价转换为层次、网状、关系模型。

**举例：学校有若干个系，每个系有若干班级和教研室，每个教研室有若干教员，其中有的教授和副教授每人各带若干研究生。每个班有若干学生，每个学生选修若干课程，每门课程有若干学生选修。用E-R图画出概念模型。**  
![](https://img-blog.csdnimg.cn/20210410154719316.png)

数据模型
----

#### 一、层次模型：用树型结构表示实体之间的联系。

*   每个节点代表一个实体型.
*   只能直接处理一对多（含一对一）的实体关系.
*   查找层次数据库中的记录，速度较慢。

#### 二、网状模型：用图结构表示实体之间的联系。

*   每个节点代表一个实体型。
*   可以处理多对多的实体关系。
*   查找网状数据库中的记录，速度最快。

#### 三、[关系模型](https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020)：用二维表表示实体之间的联系。

1.重要术语：

*   关系：一个关系就是一个二维表：
*   元组：二维表的一行，即实体：
*   关系模式：在实体型的基础上，注明主码。
*   关系模型：指一个数据库中全部二维表结构的集合。

2.特点：

1.  关系模型是建立在严格的数学理论的基础上的；
2.  关系模型的存取路径对用户透明：
3.  查找关系数据库中的记录，速度最慢。

小结：数据中有三种类型，DBMS就有三种类型，DB亦有三种类型。

数据库系统结构
-------

#### 一、数据库系统的模式结构

1.  模式：是数据库中全体数据的逻辑结构和特征的描述。
    
2.  模式只涉及数据库的结构；
    
3.  模式既不涉及应用程序，又不涉及数据库结构的存储；
    
4.  **外模式：是模式的一个子集，是与一个应用程序有关的逻辑表示。特点：一个应用程序只能使用一个外模式，但同一个外模式可为多个应用程序使用。**
    
5.  内模式：描述数据库结构的存储，但不涉及物理记录。
    

2.两级映象

1\. 外模式/模式映象：保证数据库的逻辑独立性；  
2\. 模式/内模式映象：保证数据库的物理独立性；

3.两级映象的意义

1.  使数据库与应用系统完全分开，数据库改变时，应用系统不必改变。
2.  数据的存取完全由DBMS管理，用户不必考虑存取路径。

数据库管理系统
-------

DBMS的功能：负责对数据库进行统一的管理与控制。

1.  数据定义：即定义数据库中各对象的结构；
2.  数据操纵：包括对数据库进行查询、插入、删除、修改等操作。
3.  数据控制：包括安全性控制、完整性控制、并发控制、数据库恢复。

#### 一、基本概念

1.  码：能够唯一标识元组的属性集。
2.  候选码：一个属性集既能唯一标识元组，且又不含多余属性，一个关系模式可以有多个候选码。
3.  主码：任选候选码中的一个。
4.  非主属性：不包含在主码中的各个属性。
5.  外码：设F是关系R的一个属性，不是R的主码，但却是另一个关系S的主码，则F是关系R的外码。

例如：student ( sno, sname, ssex, sage, sdept)  
Sc ( sno, cno, grade)

**Sc的主码为：（sno,cno）；外码为：sno**

数据库设计 （第3章）
===========

#### 一、数据库设计的步骤

*   需求分析：了解分析用户的需要、要求。
*   概念结构设计：根据需求分析的结果画概念模型（即E-R图）.
*   逻辑结构设计：将E-R图转换为某一种数据模型，并优化。
*   物理结构设计
*   数据库实施
*   数据库运行与恢复

#### 概念结构设计

##### 局部E-R图设计

1．确定局部范围：通常把系统涉及的各个部门或各个主要功能作为局部。

2．确定实体与属性

*   ① 属性是不能再分的数据项；
*   ② 联系只发生在两实体之间；
*   ③ 原则上，能够作为属性，就不要作为实体。

##### 合并成总体E-R图

*   消除各局部E-R图的冲突问题。
*   按公共实体名合并，并生成初步E-R图。
*   消除冗余的属性和冗余的联系，生成总体E-R图。

#### 逻辑结构设计

##### 一、联系的属性和主码

*   （1）联系的属性：必须包含相关联的各实体型的主码。
    
*   1：1联系：可以是相关联的任一实体型的主码。
    
*   1：n联系：必须是n方实体型的主码。
    
*   m：n联系：必须是相关联的各实体型的主码之和。
    

##### E-R图向关系模型的转换

（1）把每个实体型转换为一个关系模式。  
（2）1：1联系：可以消化到相关联的任一实体型对应的关系模式中。![](https://img-blog.csdnimg.cn/20210410162347494.png?sfljsf sljspss as)

班长( XH， XM， NL，BH)  
班级（BH，RS）

（3）1：n联系：可以消化到n方实体名对应的关系模式中。  
例：一个班级有多名学生，每名学生只能属于一个班级。每一个班级有一名班长，他是学生中的一员。

![](https://img-blog.csdnimg.cn/20210410163017993.png)

学生（XH，XM，NL，BH）  
班级（BH，RS，XH）  
                              ↓ →班长的学号

（4）m：n联系：必须转换为一个关系模式，并且不能消化。  
例：  
![](https://img-blog.csdnimg.cn/20210410163214262.png)

> 学生(sno，sname， ssex， sage， sdept)  
> 课程（cno， cname，credit）  
> 选修（sno， cno， grade）

（5）多元联系：不能消化

例：  
![](https://img-blog.csdnimg.cn/20210410163301347.png)

三 [关系数据库](https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020) （第4章）
======================================================================================================================

#### 一、域

1.  定义：域是一组具有相同类型的值的集合。
2.  域的基数：域中所含数据的个数。

#### 笛卡尔积

1.  定义：给定一组域D1,D2,D3，则D1×D2×D3称为笛卡尔积。
2.  笛卡尔积D1×D2×D3对应一个二维表，所含元组的个数等于各个域的基数之积。

#### 关系

1.  定义：笛卡尔积的一部分元组称为关系。
2.  关系的目：一个关系所含属性的个数。
3.  关系的性质：任意两个元组不能完全相同，同一关系的属性名不允许重复。

### 关系的完整性

1.  实体完整性：指关系的所有主属性都不能去空值。注意：实体完整性不仅仅是主码整体不能取空值。
2.  参照完整性：指一个关系外码的取值必须是相关关系中主码的有效值或空值。

> 例： 班级( 班名,人数) 学生(学号,姓名,性别,密码,班名) 在学生表中，班名的取值必须是班级表\[班名\]的值或空值。

#### 关系代数

##### 一、传统的集合运算

设关系R、S的结构完全相同，则：

*   R∪S：由属于R或属于S的元组组成。
*   R∩S：由既属于R又属于S的元组组成。
*   R－S：由属于R而不属于S的元组组成。

**思考：（R∩S）∪（R－S）=？**（结果就是R）

**R×S**：设R有m个属性，K1个元组；S有n个属性，K2个元组，则R×S含有(m+n)个属性，(K1×K2)个元组。

##### 二、专门的关系运算

1.  选择：从关系R中选择满足条件的元组。记为： ![](https://img-blog.csdnimg.cn/2021041016480741.png)
    
2.  投影：从关系R中选择若干属性组成新的关系，并把新关系的重复元组去掉。记为：  
    ![](https://img-blog.csdnimg.cn/20210410164814657.png)
    
3.  条件连接：将两关系按一定条件连接成一个新关系，记为： ![](https://img-blog.csdnimg.cn/2021041016490341.png)
    

说明：条件连接：两关系可以没有公共属性，若有公共属性，则新关系含有重复属性。

4.  自然连接：将两关系按公共属性连接成一个新的关系，并把新关系的重复属性去掉。  
    记为： ![](https://img-blog.csdnimg.cn/20210410164933839.png)

说明：

*   ① 自然连接：两关系至少有一个公共属性。
*   ② 对于R的每个元组，S都从第一个元组开始判断，若两元组的公共属性值相同，则产生一个新元组添加到新关系中，最后把新关系中的重复属性去掉。

# 关系数据库规范化理论（第7章）

#### 函数依赖

##### 一、有关概念：

1.  函数依赖：任给R（U），U为属性集，x、y为U的子集，如果对于x的每个值，y有唯一确定的值与之对应，则称x决定y，或y函数依赖于x。记为：x→y。
2.  完全函数依赖：若x→y，且对于x的所有真子集x′,都有x′ 不能决定y，则称x完全决定y，或y完全函数依赖于x。记为：![](https://img-blog.csdnimg.cn/20210410165344656.png)  
    。  
    结论：若x→y，且x只包含一个属性，则 ![](https://img-blog.csdnimg.cn/20210410165401556.png) 
3.  部分函数依赖：  
    若x→y，且存在x的一个真子集x′,满足x′→y，则称x部分决定y，或y部分函数依赖于x。记为：![](https://img-blog.csdnimg.cn/20210410165435289.png)  
    。
4.  传递函数依赖：若x→y,y→z,但 y 不能决定x,则称![](https://img-blog.csdnimg.cn/20210410165509234.png)

##### 二、平凡函数依赖与非平凡函数依赖

设x→y，如果y是x的子集，则该依赖是平凡的。如：  
Sno,sname→sno

**如果y中至少有一个属性不在x中，则该依赖是非平凡的。如：  
Sno,sname→sname,sdept**

如果y中没有一个属性在x中，则该依赖为完全非平凡的。

关系模式的规范化
--------

#### 一、问题提出

答：**存在问题**

1.  ① 数据冗余大；
2.  ② 修改麻烦；
3.  ③ 插入异常：应该插入到DB中的数据插不进去。

如：新开课程没有学生选修时，新开课程的课程号、课程名插不进去。

1.  ④ 删除异常：不应该删除的数据被删掉。

如选修某门课的学生毕业了，在删除学生信息的同时，把课程信息也删除掉。

结论：一个好的关系模式应满足：

*   ① 冗余应尽可能少；
*   ② 应尽可能避免插入、删除异常；
*   ③ 消去关系中不合适的属性依赖关系。

#### 二、范式

*   什么叫范式？  
    答：指一个关系的非主属性函数依赖于主码的程度。
    
*   什么叫关系规范化？  
    答：指一个关系从低级范式向高级范式的转换过程。  
    ![](https://img-blog.csdnimg.cn/20210410170659917.png)
    
*   应用：关系规范化理论应用在逻辑结构设计阶段。
    

#### 三、关系模式的规范化

**1．第一范式（1NF）**

*   ① 定义：若关系R的所有属性不能再分，则R∈1NF

**2．第二范式（2NF）**

① 定义：若关系R∈1NF，且它的每个非主属性都完全依赖于主码，则称R∈2NF。

② 存在问题：

*   冗余大： R1必要冗余，R2冗余可以修改。
*   修改麻烦
*   插入异常：如新来的教师没有上课，则该教师的信息就没办法插入R2表中。
*   删除异常：若某位教师只授一门课，当该门课不开时，该教师的信息亦被删除。

**③ 原因：存在非主属性对主码的传递依赖。**  
![](https://img-blog.csdnimg.cn/20210410171310251.png)  
④ 解决办法：将R2 一分为二

![](https://img-blog.csdnimg.cn/20210410171327702.png)

**3．第三范式（3NF）**

**① 定义：若关系R∈2NF，且它的每个非主属性都不传递依赖于主码，则称R∈3NF。**

② 规范化过程

非规范关系

↓使每个属性都不能再分

1NF

↓消去非主属性对主码的部分依赖

2NF

↓消去非主属性对主码的传递依赖

3NF

**BCNF：关系模式R<U,F>中，如每一个决定因素都包含码，则R是ＢＣ范式。如果R属于BCNF 那么R一定属于3NF，反之未必。**

**4．结论**

*   ① 若R∈1NF，且主码只含一个属性，则R一定为2NF。
*   ② 若R∈2NF，且只有0~1个非主属性，则R一定为3NF。
*   ③ 3NF一般控制了数据冗余，一般避免了操作异常。
*   ④ 范式并非越高越好，适可而止。

数据库保护技术（第8章）
============

一、两种身份验证模式：

1.  仅`windows`模式：用户只能使用`windows`登录名登录`SQL` `Server`
2.  混合模式：用户可以使用`windows`登录名或`SQL` `Server`登录名登录`SQL` `Server`

二、两种身份验证：

用户登录到`SQL Serve`r时，必须使用特定的登录名和密码标识自己。

1.  `Windows`身份验证：用户登录到`SQL Server`时，使用操作系统当前的登录名和密码。
2.  `SQL Server`身份验证：用户登录到`SQL Server`时，必须显式提供登录名和密码。

**常用安全性控制方法：用户标识和控制、存取控制、视图、审计、数据加密。**

索引
--

一、索引的概念：

*   ①索引使用户能快速访问数据表的特定信息。
*   ② 索引必须依附于某个基本表，不能单独存在。

二、索引的类型：

*   聚集索引：影响数据表的记录顺序
*   非聚集索引：不会影响数据表的记录顺序

**注：一个表只能建立一个聚集索引，但可以建立若干个非聚集索引。**

三、创建索引

1．自动创建索引：

*   如果在数据表的某个属性设置主键约束或唯一约束，则系统将在这些属性上自动创建唯一索引。
*   自动创建的索引随约束的存在而存在，随约束的消失而消失。

视图
--

一、视图的特点：

*   ①视图只有结构，没有记录，是虚表；
*   ②一个视图总对应着一个`select`语句；
*   ③对视图的查询、更新，实际上是对基本表的查询、更新。

事务处理与并发控制
---------

1．什么叫事务？

答： **事务是用户定义的一组操作序列。**

*   ③ 事务是并发控制的基本单位。
*   ④ 一个事务包含的诸操作要么都执行，要么都不执行

1． 事务的属性

1.  原子性：指事务中包含的诸操作要么都执行，要么都不执行。
2.  一致性：事务必须使数据库从一个一致性状态变到另一个一致性状态。
3.  隔离性：一个事务的执行不能被其他事务干扰。
4.  持久性：该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚

数据的锁定
-----

#### **一、并发操作与数据不一致性**

##### 1．数据不一致性包括三类

*   `丢失修改`：指`事务1`与`事务2`从数据库中读入同一数据并修改，事务2的提交结果`破坏`事务1提交的结果，导致事务1的修改被丢失。
*   `不可重复读`：指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。
*   `读脏数据`：指事务1修改某一数据后，事务2读取该数据，事务1由于某种原因被`撤销`，这时数据又`恢复`到原值，事务2读到的数据与数据库中的数据`不一致`，称为“脏”数据。

##### 2．产生数据不一致性的原因

*   并发操作破坏了事务的隔离性。

#### 二、并发控制的目标、方法

*   目标：确保DB中的数据一致性。
    
*   并发事务正确性的原则 :几个事务的并发执行是正确的，当且仅当其结果与任何一个串行执行的结果相同。
    
*   并发控制的方法 DBMS一般采用“**封锁**”技术，保证并发操作的可串行化。
    

##### 一、 封锁（Locking）

1． 什么叫封锁？  
答：`SQL Server`自动强制封锁，并且会将封锁粒度控制在合适的级别，用户不必考虑封锁问题。

2． 封锁类型

*   排它锁（X锁）：事务T对数据A加X锁，其它事务不能再对A加锁，即其它事务`不能`读取和修改A。
*   共享锁（S锁）：事务T对数据A加S锁，其它事务只能再对A加S锁，即其它事务`只能读A`，`不能修改A`。

3． 封锁粒度

封锁对象可以是属性`列、元组、关系、整个数据库`。封锁对象的大小称为**封锁粒度**。封锁粒度**越小**，并发度**越高**，但并发控制的开销**越大**。

4． 封锁协议

1.  事务T在修改数据A之前，必须对其加X锁，直到事务结束才释放。
    
2.  事务T在读取数据A之前，必须对其加S锁，直到事务结束才释放。 遵循封锁协议，可以解决**三种数据不一致性问题**：
    

> 3.  **丢失修改**
> 4.  **不可重复读**
> 5.  **读“脏”数据**

#### 四、死锁和活锁

> 封锁技术可以解决并发操作的不一致性问题，但也带来新的问题，即死锁和活锁。

##### 1.死锁：

① 定义：两个事务已经各自锁定一个数据，但是又要访问被对方锁定的数据，造成了循环等待，称为死锁。

避免死锁的方法：

*   顺序封锁法：若规定封锁顺序为A，B，则T1，T2只能先封锁A，再封锁B。

##### 2.活锁：

*   ① 定义：若多个事务请求封锁同一个数据时，其中的某个事务总处于等待状态，则称为活锁。
*   ② 避免活锁的方法：先来先服务

事务可串行化调度：**两段锁协议.**
