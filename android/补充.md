# fragment

## 通信

`fragment`于`activity`通信的一种原生方法是使用`Bundle`：

~~~java
Bundle bundle = new Bundle();
bundle.putString('msg', "数据");
BlankFragment bf = new BlankFragment();
bf.setArguments(bundle);
~~~

## 生命周期

1. 第一次显示：onAttach -> onCreate -> onCreateView -> onActivityCreated -> onStart -> onResume
2. 按home：onPause -> onStop（界面显示的fragment不变）
3. 重新显示：onStart -> onResume
4. 按返回：onPause -> onStop -> onDestroyView -> onDestroy -> onDetach

使用了`FragmentTransaction`的`addToBackStack`方法

1. 切换fragment：onPause -> onStop -> onDestroyView（但没销毁时，同栈切换）

- 返回原fragment：onCreateView -> onActivityCreated -> onStart -> onResume（同栈返回）

# Okhttp

## 基本使用

模块级的`build.gradle`导入依赖：

~~~kotlin
implementation 'com.squareup.okhttp3:okhttp:4.9.1'
~~~

创建客户端：

~~~kotlin
client = OkHttpClient.Builder()
    .addInterceptor {
        val request = it.request()
        val response = it.proceed(request)
        Log.d("biluo", request.url.toString())
        response
    }
    .connectTimeout(20, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .build()
~~~

创建和使用请求：

~~~kotlin
val request = Request.Builder().url("http://localhost/user/list").build()
// 阻塞方式
val response = client.newCall(request).execute()
// 异步方式
val response = client.newCall(request).enqueue(object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        TODO("Not yet implemented")
    }

    override fun onResponse(call: Call, response: Response) {
        TODO("Not yet implemented")
    }
})
~~~

## websocket

```kotlin
val observable = Observable.create<String> { emitter ->
   val request = Request.Builder().url("${AppConstant.WS_URL}/${user.username}").build()
   val ws = client.newWebSocket(request, object : WebSocketListener() {
      override fun onOpen(webSocket: WebSocket, response: Response) {
         wsObservable.ws = webSocket
         Log.d("biluo", "socket连接成功")
      }

      override fun onMessage(webSocket: WebSocket, text: String) {
         Log.d("biluo", "接收到消息：$text")
         emitter.onNext(text)
      }

      override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
         Log.d("biluo", "socket连接准备断开")
      }

      override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
         wsObservable.ws = null
         Log.d("biluo", "socket连接已经断开")
         //emitter.onComplete()
      }

      override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
         Log.e("biluo", "异常：${t.message}", t)
         emitter.onError(t)
      }
   })
   emitter.setDisposable(object : Disposable {
      override fun dispose() {
         Log.d("biluo", "dispose...")
         ws.close(1000, "Closing by dispose")
      }

      override fun isDisposed(): Boolean {
         return ws.close(1000, null)
      }

   })
}
wsObservable.observable = observable
return wsObservable
```

# Retrofit

基于OkHttp，提供了简洁的注解驱动的 API 来定义 HTTP 请求，同时支持了RESTful API风格设计。

## 基本使用

模块级的`build.gradle`导入依赖：

~~~kotlin
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
~~~

创建Retrofit实例：

添加了GsonConvert后，会自动把响应回来的Json字符串转换为对象。

~~~kotlin
val retrofit = Retrofit.Builder()
	.baseUrl(BASE_URL)
	.addConverterFactory(GsonConverterFactory.create())
	.build()
~~~

定义Api类：

~~~kotlin
interface UserApi {
	@GET("$USER_URL/{username}")
	fun getByUsername(@Path("username") username: String): Call<MsgResult<User>>

	@POST("$USER_URL/register")
	fun register(@Body user: User): Call<MsgResult<Nothing>>
}
~~~

创建Api类：

~~~kotlin
UserApi = retrofit.create(UserApi::class.java)
~~~

## 使用协程

使用kotlin的协程时，操作更加简单。

1. 将之前的Api类修改为如下的形式：

~~~kotlin
interface UserApi {
	@GET("$USER_URL/{username}")
	suspend fun getByUsername(@Path("username") username: String): MsgResult<User>

	@POST("$USER_URL/register")
	suspend fun register(@Body user: User): MsgResult<Nothing>
  
  @get("$USER_URL/users")
	suspend fun list(@Query("page") page: Int, @Query("limit") limit: Int): MsgResult<User>
}
~~~

2. 其他的步骤不变，使用方法如下：（以`Jetpack compose`举例）

~~~kotlin
@Composable
fun TestScreen() {
  val scope = rememberCoroutineScope()	// 获取组合感知作用域，以便在组件内使用协程
  var dataList by remember { mutableStateOf(listOf<User>()) }

  suspend fun getDataList() {
    val res = userApi.list(1, 10)
    val page = res["data"]
    var list = (page as Map<*, *>)["list"] as List<*>
    dataList = list.map { 转换为UserList }
  }

  // 在组件首次绘制后仅执行一次的副作用，key值发生变化会重新执行，若只想其仅执行一次，可以传入常量
  LaunchedEffect(Unit) { getDataList() }

  Column(modifier = Modifier.padding(innerPadding).fillMaxSize()) {
    // 一些组件
    Button(
      onClick = { scope.launch {	// 使用协程执行网络操作
        var res = userApi.register(new User("lisi", "1111"))
        //其他处理
      }},
      modifier = Modifier.fillMaxWidth()
    ) {
      Text("注册")
    }
  }
}
~~~

# RxJava

RxJava（Reactive Extensions for Java）是一个用于构建异步程序和事件驱动程序的库，它基于观察者模式和函数式编程。RxJava 将数据流（或事件流）视为连续的流，并通过一系列操作符来处理这些流，实现了声明式的异步事件处理，从而提高了代码的可读性和可维护性。

RxJava 和 Retrofit 可以结合使用，以更高效地处理网络请求和异步数据流。

## 基本使用

模块级的`build.gradle`导入依赖：

~~~kotlin
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
implementation 'com.squareup.retrofit2:adapter-rxjava3:2.9.0'
~~~

前提：已经导入相关依赖，并创建了RxJavaConvert到Retrofit中。

~~~kotlin
val retrofit = Retrofit.Builder()
	.baseUrl(BASE_URL)
	.addConverterFactory(GsonConverterFactory.create())
	.addCallAdapterFactory(RxJava3CallAdapterFactory.create())	// 创建RxJavaConvert到Retrofit中
	.client(client)
	.build()
~~~

之前定义Api的返回值可以改为RxJava提供的类型。

它提供了：

- **Observable**：流式数据类型，用于访问多个项的异步序列。

- **Flowable**：与Observable类似，支持背压（backpressure）机制，即当数据生产速度超过消费速度时，能够控制数据的流动。

- **Single**：单发数据类型，只能且必须发射一个数据。

- **Maybe**：单发数据类型，可以发射零个或一个数据。

- **Completable**：不发射任何数据，只通知流的结束。

之前的UserApi类变为：

~~~kotlin
interface UserApi {
	@GET("$USER_URL/{username}")
	fun getByUsername(@Path("username") username: String): Single<MsgResult<User>>

	@POST("$USER_URL/register")
	fun register(@Body user: User): Single<MsgResult<Nothing>>
}
~~~

使用：

~~~kotlin
val disposable: Disposable = single
	.subscribeOn(Schedulers.io())	// 在IO线程执行
	.observeOn(AndroidScheduler.mainScheduler)	// 在主线程接收结果
	.subscribe({ res ->
		//成功获取结果res，做什么
	}, { e ->
		//出现异常后做些什么
	})
~~~

Retrofix下的RxJava没有AndroidScheduler类，可以自己定义一个：

~~~kotlin
object AndroidScheduler : Executor {

	val mainScheduler: Scheduler = Schedulers.from(this)
	private val handler: Handler = Handler(Looper.getMainLooper())

	override fun execute(command: Runnable) {
		handler.post(command)
	}
}
~~~

## 定时任务

~~~kotlin
val disposable = Observable.interval(15L, TimeUnit.MINUTES)
	.subscribe({ _ ->
        val json = Gson().toJson(Message("ping", null, appUser.username))
		wsObservable.ws?.send(json)
    Log.d("biluo", "发送了一个心跳包")
	}) { t ->
    	Log.e("biluo", "异常：", t)
        wsObservable.ws?.close(1000, "心跳续约失败")
	}
~~~

# Hilt

可以进行实例的管理，并进行依赖注入。类似spring IOC

项目级`build.gradle`导入插件：

~~~kotlin
id 'com.google.dagger.hilt.android' version '2.51.1' apply false
~~~

模块级`build.gradle`导入插件：

~~~kotlin
id 'kotlin-kapt'
id 'dagger.hilt.android.plugin'
~~~

模块级`build.gradle`导入依赖：

~~~kotlin
implementation 'com.google.dagger:hilt-android:2.51.1'
    kapt 'com.google.dagger:hilt-compiler:2.51.1'
~~~

## 基本使用

参考教程：https://blog.csdn.net/Mr_Tony/article/details/124516871

使用`Hilt`必须要先用`@HiltAndroidApp`绑定`Application`。

哪个类需要进行依赖注入，就得加上`@AndroidEntryPoint`进行绑定，然后注入的地方需要使用`@Inject`。

> - `@HiltAndroidApp`：用于标注 `Application` 类，触发 Hilt 的代码生成操作，生成应用级别的组件。
> - `@AndroidEntryPoint`：用于标注 Android 组件（如 `Activity`、`Fragment` 等），告知 Hilt 这些组件可以接收依赖注入。
>
> - `@Inject`
>   - 用于标注需要注入的依赖项，可以是字段、构造函数或方法。
>   - 对于字段，Hilt 会自动注入相应的依赖；对于构造函数，Hilt 会使用它来创建类的实例
>
> 注：`@AndroidEntryPoint`不仅仅可以绑定到Activity，还可以绑定到其他地方，请参考：https://developer.android.google.cn/training/dependency-injection/hilt-android

~~~kotlin
@HiltAndroidApp
class App: Application()

// 类似spring的 @Component
class DateFormatter @Inject constructor() {
  fun testDateFormatter(){
    Log.e("YM--->","---->获取DateFormatter")
  }
}

// 类似spring在类中进行依赖注入也需要当前类被spring管理
@AndroidEntryPoint
class HiltActivity : AppCompatActivity() {
  @Inject	// 类似spring的 @Autowire
  lateinit var dateFormatter: DateFormatter

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_hilt)
    dateFormatter.testDateFormatter()
  }
}
~~~

## 进阶使用

- `@Module`：用于标注提供依赖项的类。
- `@Provides`：用于标注 `Module` 类中的提供依赖项的方法，Hilt 会在需要时调用这些方法。
- `@Binds`：用于在`Module`类中绑定接口和实现类，告知 Hilt 在需要提供接口的实例时要使用哪种实现。
- `@InstallIn`：用于标注 `Module` 或 `EntryPoint`，指定其作用范围。
- `@Singleton`：用于标注提供的依赖项为单例，即在整个应用程序的生命周期内只存在一个实例。
- `@HiltViewModel`
  - 用于标注 `ViewModel` 类，使其可以使用 Hilt 进行依赖注入。
  - 注意：`ViewModel` 不能直接使用 `@Inject` 注解，需要使用 `@HiltViewModel`。
- `@ActivityScoped`：用于标注提供的依赖项为 Activity 级别的作用域，即依赖项的生命周期与 Activity 相同。

> 补充：
>
> - `@HiltViewModel`
>
>   - 用于标注 `ViewModel` 类，使其可以使用 Hilt 进行依赖注入。
>
>   - 注意：`ViewModel` 不能直接使用 `@Inject` 注解，需要使用 `@HiltViewModel`。
>
> - `@ViewModelScoped`：用于标注提供的依赖项为 ViewModel 级别的作用域，即依赖项的生命周期与 ViewModel 相同。
> - `@EntryPoint`：用于获取 Hilt 提供的实例，特别是在不能直接使用 `@AndroidEntryPoint` 的类中（如 `ContentProvider`、`BroadcastReceiver`）。

- `@Provides`举例：

~~~kotlin
class HelloClass {
  fun hello() = "Hello"
}

@Module
// 表示整个应用程序的生命周期内都是单例
@InstallIn(SingletonComponent::class)
object AppModule {
  @Provides
  @Singleton	// 单例
  fun provideSomeOtherClass(): HelloClass {
    return HelloClass()
  }
}

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
  @Inject
  lateinit var helloClass: HelloClass

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    helloClass.hello()
  }
}
~~~

- `@Binds`举例：在这个示例中，`@Binds` 注解用于将 `ApiServiceImpl` 绑定到 `ApiService` 接口上，这样当需要 `ApiService` 的实例时，Hilt 会提供 `ApiServiceImpl` 的实例。

~~~kotlin
interface ApiService {
  fun doSomething()
}

class ApiServiceImpl @Inject constructor() : ApiService {
  override fun doSomething() {
    println("Doing something in ApiServiceImpl")
  }
}

@Module
@InstallIn(SingletonComponent::class)
abstract class ApiServiceModule {
  @Binds
  abstract fun bindApiService(apiServiceImpl: ApiServiceImpl): ApiService
}
~~~

- `@ActivityScope`例子：

~~~kotlin
@Module
@InstallIn(ActivityComponent::class)
object ActivityModule {
  @Provides
  @ActivityScoped
  fun provideActivityDependency(): ActivityDependency {
    return ActivityDependency()
  }
}
~~~

## 例子

Application类：

~~~kotlin
@HiltAndroidApp
class MyApplication : Application() {}
~~~

模块类：

~~~kotlin
@InstallIn(SingletonComponent::class)
@Module
class AppModule {
	@Provides
	@Singleton
	fun okHttpClient(): OkHttpClient {
		return OkHttpClient.Builder()
			.addInterceptor {
				val request = it.request()
				val response = it.proceed(request)
				Log.d("biluo", request.url.toString())
				response
			}
			.connectTimeout(20, TimeUnit.SECONDS)
			.readTimeout(30, TimeUnit.SECONDS)
			.retryOnConnectionFailure(false)
			.build()
	}

	@Provides
	@Singleton
	fun retrofit(client: OkHttpClient): Retrofit {
		return Retrofit.Builder()
			.baseUrl(BASE_URL)
			.addConverterFactory(GsonConverterFactory.create())
			.addCallAdapterFactory(RxJava3CallAdapterFactory.create())
			.client(client)
			.build()
	}

	@Provides
	@Singleton
	fun userApi(retrofit: Retrofit): UserApi = retrofit.create(UserApi::class.java)
}
~~~

使用：

~~~kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    @Inject
	lateinit var userApi: UserApi
}
~~~

# Jetpack Compose

目前只有这些内容，其他组件后续有机会的话再更新。

## 布局和组件

官方文档：

- 布局：[Compose 中的布局  | Jetpack Compose  | Android Developers](https://developer.android.com/develop/ui/compose/layouts?hl=zh-cn)
- 组件：[Material 组件  | Jetpack Compose  | Android Developers](https://developer.android.com/develop/ui/compose/components?hl=zh-cn)

一些组件使用方式参考[组件库章节相关内容](#Jetpack Compose Material)

## 副作用

官方文档：[Compose 中的附带效应  | Jetpack Compose  | Android Developers](https://developer.android.com/develop/ui/compose/side-effects?hl=zh-cn)

小例子：[Retrofit章节的使用协程相关内容](#使用协程)

# 组件库

## Material Components for Android

Material Components for Android：Google 官方提供的 Material Design 组件库。

- 特点
  - 完全遵循 Material Design 规范。
  - 提供丰富的组件（如 `Button`、`CardView`、`BottomNavigationView` 等）。
  - 与 AndroidX 库无缝集成。
- 适用场景：需要遵循 Material Design 规范的项目。
- GitHub：https://github.com/material-components/material-components-android

举例：BottomNavigationView——底部导航栏

1. 编写菜单xml文件`bottom_nav_menu.xml`。

   ~~~xml
   <?xml version="1.0" encoding="utf-8" ?>
   <menu xmlns:android="http://schemas.android.com/apk/res/android">
       <item
           android:id="@+id/nav_home"
           android:icon="@drawable/home"
           android:title="@string/tab1" />
       <item
               android:id="@+id/nav_tab2"
               android:icon="@drawable/tab2"
               android:title="@string/tab2" />
       <item
               android:id="@+id/nav_tb3"
               android:icon="@drawable/tb3"
               android:title="@string/tab3" />
   </menu>
   ~~~

2. 在相应的布局文件中引入BottomNavigationView，例如MainActivity。

   ~~~xml
   <LinearLayout
       xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:orientation="vertical">
    
       <androidx.fragment.app.FragmentContainerView
           android:id="@+id/fragment_container"
           android:layout_width="match_parent"
           android:layout_height="0dp"
           android:layout_weight="1" />
     
   	<com.google.android.material.bottomnavigation.BottomNavigationView
               android:id="@+id/bottomNavigationView"
               android:layout_width="match_parent"
               android:layout_height="wrap_content"
               android:layout_gravity="bottom"
               android:background="@color/purple_200"
               app:menu="@menu/bottom_nav_menu"/>
   </LinearLayout>
   ~~~

3. 准备好相应的`Fragment`，为`BottomNavigationView`设置点击事件，根据点击的项切换`Fragment`。

   ~~~kotlin
   class MainActivity : AppCompatActivity() {
       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
           setContentView(R.layout.activity_main)
   
           val bottomNavigationView = findViewById<BottomNavigationView>(R.id.bottom_navigation)
           val fragmentContainer = supportFragmentManager.beginTransaction()
   
           // 默认加载 HomeFragment
           fragmentContainer.replace(R.id.fragment_container, HomeFragment())
           fragmentContainer.commit()
   
           bottomNavigationView.setOnItemSelectedListener { item ->
               when (item.itemId) {
                   R.id.nav_home -> {
                       supportFragmentManager.beginTransaction()
                           .replace(R.id.fragment_container, HomeFragment())
                           .commit()
                       true
                   }
                   R.id.nav_tb2 -> {
                       supportFragmentManager.beginTransaction()
                           .replace(R.id.fragment_container, NavTb2Fragment())
                           .commit()
                       true
                   }
                   R.id.nav_tb3 -> {
                       supportFragmentManager.beginTransaction()
                           .replace(R.id.fragment_container, NavTb3Fragment())
                           .commit()
                       true
                   }
                   else -> false
               }
           }
       }
   }
   ~~~

   

## Jetpack Compose Material

Jetpack Compose Material：Jetpack Compose 的 Material Design 组件库。

- 特点
  - 声明式 UI 开发。
  - 提供 Material Design 风格的组件（如 `Scaffold`、`Button`、`TextField` 等）。
  - 与 Jetpack Compose 生态完全兼容。
- 适用场景：使用 Jetpack Compose 开发的项目。
- 文档：[Jetpack Compose 使用入门  | Android Developers (google.cn)](https://developer.android.google.cn/develop/ui/compose/documentation?hl=zh-cn)

模块级的`build.gradle`导入依赖：

~~~kotlin
implementation("androidx.activity:activity-compose:1.10.1")
implementation(platform("androidx.compose:compose-bom:2025.04.00"))
implementation("androidx.compose.ui:ui")
implementation("androidx.compose.ui:ui-graphics")
implementation("androidx.compose.ui:ui-tooling-preview")
implementation("androidx.compose.material:material")
implementation("androidx.compose.material3:material3")
//扩展一些图标的支持，根据需要导入该依赖
implementation("androidx.compose.material:material-icons-extended") 
~~~

举例：

* 登录：用到了列`Column`组件、行`Row`组件、输入框`TextField`组件、复选框`Checkbox`组件，按钮`Buttom`组件、文本`Text`组件。

~~~kotlin
@AndroidEntryPoint
class LoginActivity : AppCompatActivity() {
	private lateinit var shared: SharedPreferences

	override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		shared = getSharedPreferences("user", MODE_PRIVATE)
		val id = shared.getString("id", "")!!
		val password = shared.getString("password", "")!!
		setContent {
			MaterialTheme { loginScreen(id, password) }
		}
	}

	@Composable
	fun loginScreen(originId: String, originPwd: String) {
		val ID_REGEX = Regex("^[1-9]\\d{5}(18|19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d{3}[\\dXx]$")
		val PWD_REGEX = Regex("^[a-zA-Z\\d]{4,16}$")

		var id by remember { mutableStateOf(originId) }
		var password by remember { mutableStateOf(originPwd) }
		var idErrorMsg by remember { mutableStateOf("") }
		var pwdErrorMsg by remember { mutableStateOf("") }

		var checked by remember { mutableStateOf(false) }

		fun checkIdFormat(): Boolean {
			idErrorMsg = if (id.isEmpty()) "身份证号不能为空" else {
				if (!ID_REGEX.matches(id)) "身份证号格式错误" else ""
			}
			return idErrorMsg.isEmpty()
		}

		fun checkPwdFormat(): Boolean {
			pwdErrorMsg = if (password.isEmpty()) "密码不能为空" else {
				if (!PWD_REGEX.matches(password)) "密码必须由4-16位的字母或数字组成" else ""
			}
			return pwdErrorMsg.isEmpty()
		}

		fun login() {
      // 登录逻辑
		}

		Column(modifier = Modifier.padding(16.dp)) {
			TextField(  // 身份证输入框
				value = id,
				onValueChange = { id = it },
				label = { Text("身份证号") },
				placeholder = { Text("请输入身份证号") },
				isError = idErrorMsg.isNotEmpty(),
				trailingIcon = {
					if (idErrorMsg.isNotEmpty()) {    // 如果有错误提示，则显示错误图标
						Icon(Icons.Filled.Error, contentDescription = "Error")
					}
				},
				supportingText = { Text(idErrorMsg) },    // 显示在下方的错误提示
				modifier = Modifier.fillMaxWidth()
				/*.onFocusChanged { focusState -> // 进入页面时会直接显示错误提示，不友好；改为点击登录时再检查格式
                if (!focusState.isFocused) {
                    idErrorMsg = if (id.isEmpty()) "身份证号不能为空" else {
                        if (!ID_REGEX.matches(id)) "身份证号格式错误" else ""
                    }
                }
            }*/
			)
			TextField(  // 密码输入框
				value = password,
				onValueChange = { password = it },
				label = { Text("密码") },
				placeholder = { Text("请输入密码") },
				isError = pwdErrorMsg.isNotEmpty(),
				trailingIcon = {
					if (pwdErrorMsg.isNotEmpty()) {    // 如果有错误提示，则显示错误图标
						Icon(Icons.Filled.Error, contentDescription = "Error")
					}
				},
				supportingText = { Text(pwdErrorMsg) },    // 显示在下方的错误提示
				modifier = Modifier.fillMaxWidth().padding(top = 4.dp)
			)
			Row(
				verticalAlignment = Alignment.CenterVertically, // 行内元素垂直居中
				horizontalArrangement = Arrangement.spacedBy((-6).dp),  // 行内元素间距
				modifier = Modifier.clickable(
					interactionSource = remember { MutableInteractionSource() },
					indication = null   // 移除点击效果
				) { // 点击整个 Row 切换选中状态
					checked = !checked
				}
			) {
				Checkbox(checked = checked, onCheckedChange = { checked = it })	// 复选框
				Text("记住用户")	// 文本
			}
			Button(	// 按钮
				onClick = { login() },
				modifier = Modifier.fillMaxWidth()
			) {
				Text("登     录")
			}
		}
	}
}
~~~

- 布局：用到了`Scaffold`布局组件、顶部导航栏`TopAppBar`组件、底部导航栏`BottomNavigation`组件、分隔线`Divider`组件、延迟列表`LazyColumn`组件。

~~~kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun mainScreen() {
  var selectedItem by remember { mutableStateOf(1) }

  Scaffold(
    topBar = {  // 顶部导航栏
      TopAppBar(
        title = { Text(text = "个人罚单", style = MaterialTheme.typography.headlineMedium) },
        actions = {
          IconButton(onClick = {}) {
            Icon(imageVector = Icons.Filled.Menu, contentDescription = "菜单")
          }
        },
        colors = TopAppBarDefaults.topAppBarColors(
          containerColor = Purple40, // 导航栏背景颜色
          titleContentColor = Color.White, // 标题颜色
          actionIconContentColor = Color.White, // 图标颜色
        )
      )
    },
    bottomBar = {   // 底部导航栏
      BottomNavigation(
        backgroundColor = Color(0xFFE0E0E0)    // 设置底部导航栏背景颜色
      ) {
        BottomNavigationItem(
          icon = {
            Icon(
              imageVector = Icons.Filled.Home, contentDescription = "主页",
              tint = if (selectedItem == 1) Color(0xFF1E92EE) else LocalContentColor.current    // 选中时图标变色
            )
          },
          label = { 
            Text(
              text = "tab1", fontSize = TextUnit(12F, TextUnitType.Sp),
              color = if (selectedItem == 1) Color(0xFF1E92EE) else Color.Unspecified   // 选中时文字变色
            ) 
          },
          selected = selectedItem == 1,
          onClick = { selectedItem = 1 },
          //modifier = Modifier.background(if (selectedItem == 1) Color(0xFF1E92EE) else Color(0xFFE0E0E0)) // 选中时背景变色
          //selectedContentColor = , // 选中项的颜色
          //unselectedContentColor = Color.Gray // 未选中项的颜色
        )
        BottomNavigationItem(
          icon = { Icon(imageVector = Icons.Filled.Info, contentDescription = "tab2") },
          label = { Text(text = "tab2") },
          selected = selectedItem == 2,
          onClick = { selectedItem = 2 },
        )
        BottomNavigationItem(
          icon = { Icon(imageVector = Icons.Filled.Settings, contentDescription = "tab3") },
          label = { Text(text = "tab3") },
          selected = selectedItem == 3,
          onClick = { selectedItem = 3 },
        )
      }
    }
  ) { innerPadding -> // 内容区域
     when (selectedItem) {
       1 -> {
         Column(modifier = Modifier.padding(innerPadding).fillMaxSize()) {
           Row(
             horizontalArrangement = Arrangement.SpaceBetween,
             verticalAlignment = Alignment.CenterVertically,
             modifier = Modifier.fillMaxWidth().height(30.dp)
           )
           {
             Text(text = "编号", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
             Text(text = "用户名", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
             Text(text = "性别", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
           }
           Divider(color = Color.Black, thickness = 0.8.dp)    // 分隔线
           LazyColumn {   // 可滑动列表
             items(20) { item ->	// items(这里可以传入实际数据列表)，但需要导入androidx.compose.foundation.lazy.items这个扩展函数，其他说明请参考官方文档
                        Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {
                          Text(text = "$item", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
                          Text(text = "李四", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
                          Text(text = "男", textAlign = TextAlign.Center, modifier = Modifier.weight(1F))
                        }
                        Divider()
                       }
           }
         }
       }
       2 -> {
         Text(
           text = "tab2",
           modifier = Modifier
           .padding(innerPadding).fillMaxSize(),
           style = MaterialTheme.typography.headlineMedium
         )
       }
       3 -> {
         Text(
           text = "tab3",
           modifier = Modifier
           .padding(innerPadding).fillMaxSize(),
           style = MaterialTheme.typography.headlineMedium
         )
       }
     }
    }
}
~~~

