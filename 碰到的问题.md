# Spring相关问题

## springboot问题

### 打包问题

#### 配置文件未打到包中

- 可能报错：数据库连接失败（数据库配置没有读取到）
- 解决方法：

```xml
<resources>
    <resource>
        <directory>src/main/java</directory>
        <includes>
            <include>**/*.yml</include>
            <include>**/*.properties</include>
            <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
    </resource>
    <resource>
        <directory>src/main/resources</directory>
        <includes>
            <include>**/*.yml</include>
            <include>**/*.properties</include>
            <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
    </resource>
    <resource>
        <directory>lib</directory>
        <includes>
            <include>**/*.jar</include>
        </includes>
    </resource>
</resources>
```

#### 依赖未打到包中

- 可能报错：Exception in thread “main“ java.lang.NoClassDefFoundError:
- 解决方法：

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <mainClass>com.ydwh.gf.YdwhApplication</mainClass> <!-- 指定启动主类 -->
        <fork>true</fork> <!-- 如果没有该配置，devtools不会生效  打包 将外部jar包打包进项目中 -->
        <includeSystemScope>true</includeSystemScope> <!-- 打包 将外部jar包打包进项目中 -->
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>repackage</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

#### 打的包运行没有主清单属性

- 解决方法1：

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <version>${spring-boot.version}</version>
    <configuration>
        <!--这三行是重点-->
        <mainClass>com.biluo.ib.IbApplication</mainClass>
        <fork>true</fork>
        <includeSystemScope>true</includeSystemScope>
    </configuration>
    <executions>
        <execution>
            <id>repackage</id>
            <goals>
                <goal>repackage</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

- 解决方法2：在jar包中 **META-INF** 目录下的 **MANIFEST.MF** 文件中添加属性

```xml
Main-Class: com.biluo.ib.IbApplication #程序入口类名
```

### swagger被拦截器拦截问题

#### swagger-bootstrap-ui被拦截

心得：网页开发者模式去访问doc.html，通过查看网络里访问该网页有哪些请求被拦截了，排除掉哪些请求。

```java
//WebMvcConfigurer配置类中，在addInterceptor方法中添加拦截器时，需要排除这些路径
registry.addInterceptor(loginInterceptor()).addPathPatterns("/**").excludePathPatterns("/login", "/doc.html", "/webjars/**", "/swagger-resources/**");
```

### wabapp下的作用为打入jar包中

```xml
<!-- 打包webapp下的资源到META-INF/resources目录下
                注：此操作后resources资源就不会再进行打包-->
<resource>
    <directory>src/main/webapp</directory>
    <targetPath>META-INF/resources</targetPath>
    <includes>
        <include>**/**</include>
    </includes>
</resource>
```

### 报错：视图解析错误，或无法访问静态资源

在resources目录下的资源无法直接访问 或 使用controller去映射html视图失败。

解决方法：

- yml中设置静态资源路径，拦截器中不要拦截住。（无效）
- 在resources目录下先创建META-INF目录，再在该目录下创建resources目录，把静态资源放在该目录下访问（无效）
- 创建 **webapp** 目录，与resources目录同级目录，把静态资源放在里面即可。（有效）
- 配置模板引擎（比如：thymeleaf）

### 报错：Public Key Retrieval is not allowed

解决方法：

- 先手动与数据库建立一个连接即可。（比如使用navicat）

## nacos问题

### 2021.0.5版本No spring.config.import property has been defined问题

SpringBoot 2.6.13	SpringCloud 2021.0.5版本问题

解决方法：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
    <version>3.1.0</version>
</dependency>
```

### websocket问题（连接不上）

解决方法：可能是依赖版本和nacos服务器版本不对应。

## feign问题

### feign高版本报错缺少spring-cloud-starter-loadbalancer

SpringBoot 2.6.13	SpringCloud 2021.0.5版本问题

解决问题：

```xml
<!--解决：Did you forget to include spring-cloud-starter-loadbalancer?-->
 <dependency>
   <groupId>org.springframework.cloud</groupId>
   <artifactId>spring-cloud-loadbalancer</artifactId>
 </dependency>
```

### feign把get请求变post请求

产生原因：因为Feign默认使用的连接工具实现类，所以里面发现只要你有body体对象，就会强制的把GET请求转换成POST请求。

解决方法：

- 方法1：加注解显式表明方法参数是请求参数

```java
@GetMapping("/get")
public User get(@SpringQueryMap User user);

@GetMapping(“/get”)
public User get1(@RequestParam(“id”) Long id);
```

- 方法2：**更换Apache的HttpClient**

```yaml
# 配置引入
feign:
  httpclient:
    enabled: true
```

```xml
<!--依赖引入-->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <!--<version>4.5.9</version>-->
</dependency>
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-httpclient</artifactId>
    <!--<version>10.2.3</version>-->
</dependency>
```



- 方法3：通过实现**RequestInterceptor** 来自定义Feign配置的解析

### feign session丢失问题

解决方法：

方法1：在程序中获取，调用B的时候再转发。

```java
//获取：
@RequestMapping(value = "/api/test", method = RequestMethod.GET)
public String testFun(@RequestParam String name, @RequestHeader("uniqueId") String uniqueId) {
    if(uniqueId == null ){
         return "Must defined the uniqueId , it can not be null";
    }
    log.info(uniqueId, "begin testFun... ");
 return uniqueId;
}

@FeignClient(value = "DEMO-SERVICE")
public interface CallClient {

   /**
 * 访问DEMO-SERVICE服务的/api/test接口，通过注解将logId传递给下游服务
  */
 @RequestMapping(value = "/api/test", method = RequestMethod.GET)
    String callApiTest(@RequestParam(value = "name") String name, @RequestHeader(value = "uniqueId") String uniqueId);
}
```

方法2：把cookie里面的session信息放到Header里面，编写一个拦截器来实现Header的传递

```java
@Configuration  
@EnableFeignClients(basePackages = "com.xxx.xxx.client")  
public class FeignClientsConfigurationCustom implements RequestInterceptor {  

      @Override  
      public void apply(RequestTemplate template) {  
        //通过RequestContextHolder获取到请求
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();  
        if (requestAttributes == null) {  
          return;  
        }  

        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest(); 
        //拿到所有头名 并封为一个集合
        Enumeration<String> headerNames = request.getHeaderNames();  
        if (headerNames != null) {  
          while (headerNames.hasMoreElements()) {  
            String name = headerNames.nextElement();  
            Enumeration<String> values = request.getHeaders(name);  
            while (values.hasMoreElements()) {  
              String value = values.nextElement();  
              template.header(name, value);  
            }  
          }  
        }  
      }  
    }  
```

新的问题：

​		当引入Hystrix熔断策略时，出现了一个新的问题：RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); 获取不到request信息，从而无法传递session信息，最终发现RequestContextHolder.getRequestAttributes()该方法是从ThreadLocal变量里面取得对应信息的，这就找到问题原因了，由于Hystrix熔断机制导致的。

Hystrix有隔离策略：THREAD以及SEMAPHORE，当隔离策略为 THREAD 时，是没办法拿到 ThreadLocal 中的值的。

解决方法：

- 调整格隔离策略：

  hystrix.command.default.execution.isolation.strategy: SEMAPHORE

  ​		改为信号量的隔离模式，但是不推荐，因为thread是默认的，而且要命的是信号量模式，熔断器不生效，比如设置了熔断时间hystrix.command.default.execution.isolation.semaphore.timeoutInMilliseconds=5000，五秒，如果B服务里面sleep了10秒，非得等到B执行完毕再返回，因此这个方案也不可取；

- 自定义策略

```java
import com.netflix.hystrix.HystrixThreadPoolKey;
import com.netflix.hystrix.HystrixThreadPoolProperties;
import com.netflix.hystrix.strategy.HystrixPlugins;
import com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy;
import com.netflix.hystrix.strategy.concurrency.HystrixRequestVariable;
import com.netflix.hystrix.strategy.concurrency.HystrixRequestVariableLifecycle;
import com.netflix.hystrix.strategy.eventnotifier.HystrixEventNotifier;
import com.netflix.hystrix.strategy.executionhook.HystrixCommandExecutionHook;
import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisher;
import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy;
import com.netflix.hystrix.strategy.properties.HystrixProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 自定义Feign的隔离策略;
 * 在转发Feign的请求头的时候，如果开启了Hystrix，Hystrix的默认隔离策略是Thread(线程隔离策略)，因此转发拦截器内是无法获取到请求的请求头信息的，可以修改默认隔离策略为信号量模式：hystrix.command.default.execution.isolation.strategy=SEMAPHORE，这样的话转发线程和请求线程实际上是一个线程，这并不是最好的解决方法，信号量模式也不是官方最为推荐的隔离策略；另一个解决方法就是自定义Hystrix的隔离策略，思路是将现有的并发策略作为新并发策略的成员变量,在新并发策略中，返回现有并发策略的线程池、Queue；将策略加到Spring容器即可；
 *
 * @author mozping
 * @version 1.0
 * @date 2018/7/5 9:08
 * @see FeignHystrixConcurrencyStrategyIntellif
 * @since JDK1.8
 */
@Component
public class FeignHystrixConcurrencyStrategyIntellif extends HystrixConcurrencyStrategy {

    private static final Logger log = LoggerFactory.getLogger(FeignHystrixConcurrencyStrategyIntellif.class);
    private HystrixConcurrencyStrategy delegate;

    public FeignHystrixConcurrencyStrategyIntellif() {
        try {
            this.delegate = HystrixPlugins.getInstance().getConcurrencyStrategy();
            if (this.delegate instanceof FeignHystrixConcurrencyStrategyIntellif) {
                // Welcome to singleton hell...
                return;
            }
            HystrixCommandExecutionHook commandExecutionHook =
                    HystrixPlugins.getInstance().getCommandExecutionHook();
            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance().getEventNotifier();
            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance().getMetricsPublisher();
            HystrixPropertiesStrategy propertiesStrategy =
                    HystrixPlugins.getInstance().getPropertiesStrategy();
            this.logCurrentStateOfHystrixPlugins(eventNotifier, metricsPublisher, propertiesStrategy);
            HystrixPlugins.reset();
            HystrixPlugins.getInstance().registerConcurrencyStrategy(this);
            HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook);
            HystrixPlugins.getInstance().registerEventNotifier(eventNotifier);
            HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher);
            HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy);
        } catch (Exception e) {
            log.error("Failed to register Sleuth Hystrix Concurrency Strategy", e);
        }
    }

    private void logCurrentStateOfHystrixPlugins(HystrixEventNotifier eventNotifier,
                                                 HystrixMetricsPublisher metricsPublisher, HystrixPropertiesStrategy propertiesStrategy) {
        if (log.isDebugEnabled()) {
            log.debug("Current Hystrix plugins configuration is [" + "concurrencyStrategy ["
                    + this.delegate + "]," + "eventNotifier [" + eventNotifier + "]," + "metricPublisher ["
                    + metricsPublisher + "]," + "propertiesStrategy [" + propertiesStrategy + "]," + "]");
            log.debug("Registering Sleuth Hystrix Concurrency Strategy.");
        }
    }

    @Override
    public <T> Callable<T> wrapCallable(Callable<T> callable) {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        return new WrappedCallable<>(callable, requestAttributes);
    }

    @Override
    public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey,
                                            HystrixProperty<Integer> corePoolSize, HystrixProperty<Integer> maximumPoolSize,
                                            HystrixProperty<Integer> keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        return this.delegate.getThreadPool(threadPoolKey, corePoolSize, maximumPoolSize, keepAliveTime,
                unit, workQueue);
    }

    @Override
    public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey,
                                            HystrixThreadPoolProperties threadPoolProperties) {
        return this.delegate.getThreadPool(threadPoolKey, threadPoolProperties);
    }

    @Override
    public BlockingQueue<Runnable> getBlockingQueue(int maxQueueSize) {
        return this.delegate.getBlockingQueue(maxQueueSize);
    }

    @Override
    public <T> HystrixRequestVariable<T> getRequestVariable(HystrixRequestVariableLifecycle<T> rv) {
        return this.delegate.getRequestVariable(rv);
    }

    static class WrappedCallable<T> implements Callable<T> {
        private final Callable<T> target;
        private final RequestAttributes requestAttributes;

        public WrappedCallable(Callable<T> target, RequestAttributes requestAttributes) {
            this.target = target;
            this.requestAttributes = requestAttributes;
        }

        @Override
        public T call() throws Exception {
            try {
                RequestContextHolder.setRequestAttributes(requestAttributes);
                return target.call();
            } finally {
                RequestContextHolder.resetRequestAttributes();
            }
        }
    }
}
```

## gateway问题

### Gateway路由转发-报503

SpringBoot 2.6.13	SpringCloud 2021.0.5版本问题

原因：因为在`Spring Cloud 2020`版本以后，默认移除了对`Netflix`的依赖，其中就包括Ribbon，官方默认推荐使用`Spring Cloud Loadbalancer`正式替换`Ribbon`，并成为了`Spring Cloud`负载均衡器的唯一实现。

解决方法：在当前模块导入`Spring Cloud Loadbalancer`依赖

```
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-loadbalancer</artifactId>
</dependency>
```

# mybatis和mybatis-plus

### sql中参数为String时怎么去掉sql中的引号

解决方法：不要用#{}，而改用${}

### @Results注解使用报错

报错：java.lang.IllegalArgumentException: Result Maps collection does not contain value ...

解决方法：可能是第一次定义并使用@Results注解时，使用了@ResultMap注解又指定该映射一遍。第一次定义使用@Results注解时，不需要用@ResultMap注解来指定映射。

# es相关问题

### Long型精度前端显示问题

实际es中存储的是没有问题的，显示出来时，由于经过了前端js，所以最终显示出来的结果会有精度损失。

解决方法：可以在es中用string类型存储Long型数据

# docker容器

## nginx问题

### 代理本机端口502

解决方法：本机ip不能用127.0.0.1，而应该用docker容器与服务器通信的ip。

```sh
ip addr
# 找到docker0，该项下面显示的ip就是docker容器和宿主机的通信ip
```

补：如果不是以容器形式安装，则可能是权限不够或Selinux配置问题。

权限不够：修改 **nginx.conf** 的 user项为root，默认是nginx。

selinux问题：修改 /etc/selinux/config ，将SELINUX设置为disabled，然后重启你的虚拟机 reboot。

# node.js问题

### 创建vue项目失败

可能是文件权限不够

# 补充

### 绕过备案的方法

解决阿里云等域名需要备案才能设置显性隐性URL的问题，从而可以通过多级域名对应端口访问，而不需要输入端口进行访问。

- 通过静态html跳转（显性URL转发）
  - 比如将域名解析到github pages(或其他静态网页托管平台)
  - 解析到或一个免/已备案服务器上，通过该服务器上的静态页面进行跳转（nginx，tomcat等）
  - 跳转方法：[HTML如何实现网页跳转 | w3cschool笔记](https://www.w3cschool.cn/article/62420882.html#:~:text=方法一：meta 标签 用 meta 标签实现网页跳转，可以设置跳转响应时间，如下例子为在 3 秒后跳转到指定网址。  方法二：JavaScript 设置跳转 JavaScript 设置跳转的方式又有两种，一种是直接跳转，另一种是设定时间跳转。 代码如下：)，并且可以通过js代码（this.location.hostname）获取当前域名来实现跳转到不同端口指向的页面。
- 通过cloudflare的DNS加速来绕过备案（需配置页面规则）
- 使用反向代理：比如nginx，监听80端口，根据不同域名进行代理
  - nginx代理，也可以根据不同URI进行代理
- 使用其他dns服务器解析（隐性URL转发）：比如nat123的DNS解析服务

### IDEA创建项目卡死

- 方法1：下载archetype-catalog.xml文件 https://repo1.maven.org/maven2/archetype-catalog.xml，打开网址加载完Ctrl+S，**将文件放到maven仓库根目录**
- 方法2：在初始页面创建项目
