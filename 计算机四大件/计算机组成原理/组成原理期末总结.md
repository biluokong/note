第一章 [计算机系统](https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020)概论
====================================================================================================================

> 计算机系统 = 硬件 + 软件
>
> *   对计算机的某一具体功能既可以用硬件实现，也可以用软件实现
> *   硬件和软件在**逻辑功能**上是等效的
> *   实现成本和速度有较大差别

> 计算机的系统结构：确定硬件和软件的功能分配  
> ![](组成原理期末总结pic/20a5eda09ab04912be38ef9386a39125.png)

1.计算机系统的硬件组成
------------

> **运算器、存储器、控制器、输入设备、输出设备**
>
> *   运算器：实现对数据的加工，包括算术运算和逻辑运算
> *   存储器：存储数据和程序
> *   控制器：控制计算机各部件有序协调的工作
> *   输入/输出设备：实现外部世界与计算机之间的数据交换
>
> ![](组成原理期末总结pic/b66f5ae42d454c209273f1010987e1ea.png)

> 三个部件：CPU、存储器、I/O设备
>
> *   CPU：运算器 + 控制器
> *   主机系统：CPU + 内存
> *   存储器：内存 + 外存
> *   I/O设备：输入输出设备及其相关的接口
>
> ![](组成原理期末总结pic/bd508f98c44f42cb927ce0705632492c.png)

![](组成原理期末总结pic/d7f089ceca6c4299a89a8ae182cfa2fe.png)

> 存储程序原理：在计算机解题之前，要事先编制好程序，并与所需要的数据一起预先存入主存当中。当程序开始执行后，由控制器按照该程序自动地、连续地从存储器中取出指令并执行，直到获得所要求的结果为止。

![](组成原理期末总结pic/aa1cc40cb55141b89f9dc9a7b9f1c953.png)

> 1.  运算部件：
>
> *   运算器(ALU) + 通用寄存器组(GPR)  
>     运算器用于完成算术和逻辑运算
>
> 2.  内存：
>
> *   内存一般用**半导体**技术实现，外存往往用**磁盘记录**方式实现
> *   访存操作：读、写  
>     读：把AR中地址所对应的存储单元的内容读入DR  
>     写：把DR中中的数据写入AR中地址所对应的存储单元
> *   地址寄存器（AR）：存放访存地址
> *   数据寄存器（DR）：存放从内存读出或写入内存的数据
>
> 3.  控制器：由6个部分组成
>
> *   指令寄存器（IR）：存放当前正在执行的指令
> *   程序计数器（PC）：存刚当前正在执行的指令的地址
> *   指令译码器：对指令进行译码，区分当前指令是什么指令，一遍形成相应的控制信号
> *   时钟脉冲（CP）：协调计算机各部件操作的同步的主时钟。**其工作频率叫做计算机的主频**
> *   时序信号发生器：按时间顺序周而复始地发出节拍信号
> *   微操作控制部件：(微操作是硬件电路中不可再细分的简单操作)根据指令的译码结果，结合CP以及时序信号发生器产生的节拍信号，产生该指令执行过程中各节拍所的微操作控制信号，并将它们发送给包括控制器本身在内的各个部件，使之协调、分步骤地进行操作，实现指令的执行。

2.软件系统
------

> **系统软件 + 应用软件**  
> ![](组成原理期末总结pic/8ba72be323024d3c941ae74cb9b140b5.png)
>
> 系统软件：保证计算机系统高效、正确地运行的基础软件
>
> *   操作系统：管理系统资源，为用用程序提供运行环境，为用户提供操作界面
> *   语言处理程序：将用源程序变换为机器语言程序，处理方式有两种：  
>     解释：逐行处理，边分析边执行  
>     翻译：用汇编程序或编译程序将源程序全部翻译成**目标程序**后，再去执行目标程序

3.计算机的[性能指标](https://so.csdn.net/so/search?q=%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87&spm=1001.2101.3001.7020)
----------------------------------------------------------------------------------------------------------

> 1.  主频
>
> *   CPU的工作节拍是由时钟来控制的，时钟不断产生固定频率的时钟脉冲，这个时钟的频率就是CPU的主频
> *   主要用于评价相同或近似系统结构的计算机的性能，不用在结构差距很大的机器之间
>
> 2.  运算速度
>
> *   每秒执行多少指令/完成多少次浮点运算
> *   单位：MIPS(百万条指令/秒)/MFLOPS(百万次浮点运算/秒)  
>     ![](组成原理期末总结pic/e83aba8e216a4354bc80e197e20e8f6d.png)
> *   计算运算速度：混合比率计算法、计算各种指令的执行速度、执行基准程序的运算速度
>
> 3.  基本字长
>
> *   直接参与运算的数据字的二进制位数  
>     决定寄存器、ALU、数据总线等的位数，直接影响硬件的造价
>
> 4.  主存容量
>
> *   主存所能存储的信息的总容量  
>     ![](组成原理期末总结pic/f066a45706524d3eaa4a404d6e996ac0.png)
>
> 5.  主存存取周期
>
> *   对主存连续两次访问所允许的最小时间间隔
>
> 6.  所配置的外部设备及其性能指标

第二章 数制与编码
=========

1.带符号数的表示方法
-----------

> 1.  原码：
>
> *   正数最高位为0
> *   负数最高位为1
>
> ![](组成原理期末总结pic/c06bd90766cb40e8a2e2472f11c4b76b.png)

> 2.补码：
>
> *   正数补码=原码
> *   负数补码：取反+1 **（符号位不变）**  
>     注意小数的符号位位置
>
> ![](组成原理期末总结pic/585770b2e25b4e48a4a77093752113e4.png)

> 3.  反码：
>
> *   正数反码=原码
> *   负数反码：每位取反 **（符号位不变）**
>
> ![](组成原理期末总结pic/baf639aed9ad449587d299a8a83b539f.png)  
> 4\. 移码：
>
> *   与补码仅符号位不同
> *   **采用移码的目的是为了能从机器数的形式上直接判断两数真值的大小**
>
> ![](组成原理期末总结pic/7a71a1612d794a3194d1394804f6c7ff.png)

2.数的定点表示与浮点表示
-------------

> 1.  定点表示：小数点固定
>
> ![](组成原理期末总结pic/4fcc1d19fc1f440595753d8f86068c98.png)  
> 2.浮点表示
>
> *   **阶码用移码，尾数用补码**
>
> ![](组成原理期末总结pic/145437fa0e074ae39e8ab0d605cfb05d.png)  
> ![](组成原理期末总结pic/dcbb768f6f0f4ff6be61f853f14065e8.png)

3.其他编码
------

> 1.  8421（BCD）码
> 2.  余三码：BCD码 + 0011
>
> *   是一种对9的自补码：自身按位取反就得到其对9的补码  
>     _十进制数字5的余3码为1000，5对9之补是9－5＝4，而4的余3码是0111，它正好是5的余3码1000按位取反而得。_
> *   两个余3码相加，所产生的进位相应于十进制数的进位，但所产生的和要进行修正后才是正确的余3码。如果没有进位，则和需要减3；如果发生了进位，则和需加3。  
>     ![](组成原理期末总结pic/1c9337be8ae8402a966122c424465a62.png)
>
> 3.  2421码

第六章 计算机执行程序的过程
==============

> 1.  Load指令：装载寄存器指令
>
> *   把一个数据送入指定的寄存器，这个值可以是立即数，也可以是来自存储器的某单元
>
> 2.  Store指令：存储指令
>
> *   把指定寄存器中的数据存入存储器的某个单元
>
> 3.  Add指令：加法指令
> 4.  Jump 指令：跳转指令

1.Load R1，200(R0)
-----------------

> 用\[R0\]+200作为地址访问存储器，将读出的内容送至R1

1.  取指：

*   将PC的内容传送至地址寄存器AR
*   从存储器读出第一条指令，放到数据存储器DR
*   把该指令从DR送到指令寄存器IR  
    ![](组成原理期末总结pic/4375d6c21a0f4b6aa1447d4a02bbd453.png)  
    ![](组成原理期末总结pic/8af4f498525d4f589e107198ef39e2d0.png)  
    ![](组成原理期末总结pic/af4acd205c09496c89aa8461a4564072.png)

2.  译码：

*   控制器结合时钟脉冲信号CP和时序信号产生器所生成的节拍信号，产生执行该指令所需要的微操作控制信号  
    ![](组成原理期末总结pic/393d43a4f1464f959f3240b5ce56cec8.png)

3.  执行：

*   计算访存地址\[R0\]+200→AR  
    具体操作：  
    \[R0\]→ALU，把寄存器R0中的内容（为0）送给ALU，见图中的①  
    IR中的操作数“200”→ALU，见图中的②  
    ALU进行加法运算。结果传送给AR，即\[ALU\]→AR，见图中的③

![](组成原理期末总结pic/ec13a6e4b4ff4a8c8d90c8344647f014.png)

*   从存储器读出数据，送入寄存器R1  
    具体操作：  
    从存储器中地址为200的存储单元读出数据50，如图中的①所示  
    DR→R1,把DR中的50送入R1,如图中的②所示

![](组成原理期末总结pic/6724cb0e8b5240c8b279a74272e93cc9.png)  
4.PC+4：指向下一条指令，为执行下一条指令做准备  
![](组成原理期末总结pic/4393eacfeb75455fb49bd63c10e8f6a6.png)

2.Load R2，#4
------------

> 把指令中的立即数4传送至R2

1.  取值：同上  
    ![](组成原理期末总结pic/ffc8fcdeae6f466b907ca5e8a7490f34.png)
    
2.  译码：同上
    
3.  执行：
    

*   将IR中的4送至R2  
    ![](组成原理期末总结pic/7c476dc4c94b404982c1ee21e0234e60.png)

4.  PC+4

3.Add R3，R1，R2
--------------

> 把R1和R2中的内容相加，结果存入R3

1.  取指
    
2.  译码  
    ![](组成原理期末总结pic/026ca66861fa4ca6b95edb7047ce19be.png)
    
3.  执行
    

*   把R1和R2中的数据送往ALU的两个入口端，ALU做加法运算
*   把ALU出口端的结果存入R3  
    ![](组成原理期末总结pic/74d44d981d8b450ba1bb9084fb70959c.png)

4.  PC+4

4.Store R3，200(R2)
------------------

> 把R3中的内容存入地址为\[R2\]+200的存储单元

1.  取指
    
2.  译码  
    ![](组成原理期末总结pic/345dbc67dace4b3a961663debb3d3c46.png)
    
3.  执行
    

*   计算访存地址\[R2\]+200→AR  
    具体操作：  
    \[R2\]→ALU，把寄存器R2中的内容（为4）送给ALU  
    IR中的操作数“200”→ALU  
    ALU的加法运算，\[ALU\] →AR，ALU 的运算结果（204）送给AR  
    ![](组成原理期末总结pic/729e95fe5c33425ab67cd9796dec7b17.png)
*   \[R3\]→DR：把R3的内容送DR  
    ![](组成原理期末总结pic/2d9b700f75644053b3ed5e917a521d96.png)
*   \[DR\]→MEM\[AR\]：把数据写入存储器  
    ![](组成原理期末总结pic/9d40eb21fc0948f286be1f30492bac1d.png)

4.  PC+4

5.Store R2，@(208)
-----------------

@表示间接寻址

> \[R2\]→MEM\[MEM \[208\]\]：把寄存器R2中的内容存入主存中地址为MEM\[208\]的单元中

1.  取指
    
2.  译码  
    ![](组成原理期末总结pic/7c9fc109f7e245e3b82c8ce4281ae9c0.png)
    
3.  执行
    

*   MEM\[208\]→DR  
    具体操作：  
    208→AR  
    MEM\[208\]→DR  
    ![](组成原理期末总结pic/a863cf6fae4947548b002f850458d2c1.png)
    
*   \[DR\]→AR  
    ![](组成原理期末总结pic/b96567c0bd7c41579abdb428b206864e.png)
    
*   \[R2\]→DR  
    ![](组成原理期末总结pic/9a750866049f468b9ed08593cb595d78.png)
    
*   \[DR\]→MEM\[AR\]  
    ![](组成原理期末总结pic/8c177b5adaa14656aceed47a2f8bbda1.png)  
    4.PC+4
    

6.Jump 1000
-----------

> 让计算机跳转到地址为1000的地方

1.  取指
2.  译码  
    ![](组成原理期末总结pic/1e8b03f65c9649a79c552d3d34241acc.png)
3.  执行

*   1000→PC  
    ![](组成原理期末总结pic/85ecd0d890df4b16832778d72610bf19.png)

4.  PC+4

第七章 指令系统
========

*   **指令集/指令系统：一台计算机所能执行的全部指令的集合**
*   指令系统决定计算机硬件所能完成的全部功能
*   **指令：要求计算机进行基本操作的命令**

1.指令格式
------

> 操作码 + 地址码
>
> *   操作码：描述指令的操作功能
> *   地址码：描述与操作数有关的信息，可以是操作数本身，也可以是存放操作码的地址  
>     ![](组成原理期末总结pic/afc6fabfb51942c9a11e67602fd6c8c1.png)

*   计算机中，操作数可能存放在**主存储器、CPU中的寄存器、I/O接口寄存器或堆栈中**
*   地址的个数与长度主要取决于指令所涉及的操作数的个数、进行什么操作、存储器的容量、编址单位的大小以及寻址方式等

### 1.1 地址码

*   根据**指令中地址码部分显式给出的地址的个数**，将指令格式分为以下5种：

> 1.  零地址指令：  
>     ![](组成原理期末总结pic/667393508ee94a7a8cc9d9f3ffc08ca3.png)
>
> *   只有操作码，没有地址码
> *   使用零地址的情况：  
>     指令本身不需要任何操作数（空操作、停机）  
>     指令中所需的操作数是隐含指定的（堆栈操作）

> 2.  一地址指令  
>     ![](组成原理期末总结pic/841a832447a344ad8cb5a351e124c7ad.png)
>
> *   使用情况：  
>     指令本身只需要一个操作数（加一、求补、清零），A←OP\[A\]  
>     指令需要两个操作数，指令中指明一个操作数，而另一个操作数在默认的累加器AC中，操作结果存放到累加器AC中：AC←\[AC\]OP\[A\]

> 3.  二地址指令  
>     ![](组成原理期末总结pic/593cb0dffebe465d8ce04420f93e04aa.png)
>
> *   根据存放操作数的不同分为三种：  
>     寄存器-寄存器型（R-R型）指令  
>     存储器-存储器型（M-M型）指令  
>     寄存器-存储器型（R-M型）指令：结果保留在**寄存器**中

> 4.  三地址指令  
>     ![](组成原理期末总结pic/6198d23a657e4b6eabc77557356a849e.png)
> 5.  多地址指令

### 1.2 操作码

*   **指令系统中的每一条指令都有唯一确定的操作码，不同指令的操作码不相同**
*   操作码的长度决定指令系统的最大规模
*   n为操作码，指令系统最多有2n条指令

> 1.  固定长度操作码：
>
> *   每条指令的长度都相同
> *   利于简化硬件设计；减少指令译码时间

> 2.  可变长度操作码：
>
> *   不同指令的长度随指令功能而不同
> *   使用频率高的指令用段的操作码
> *   缩短操作码的长度，但会使硬件设计复杂化，增加指令译码的时间和难度

> 3.  **扩展操作码技术**：
>
> *   简化硬件设计
>
> *   当指令总长度一定时，可以使操作码的长度随地址数的增加而减少，不同地址数的指令的操作码的长度也不同，从而有效地缩短指令总长度
>
> *   包括等长扩展与不等长扩展
>
> *   **地址长度为n，上层留出m种状态，下一层可扩展出m×2n种状态**
>
>     eg.二地址指令条数最大值 = (2三地址指令操作码位数 - 三地址指令条数) × 2二地址操作码位数-三地址操作码位数
>
>
> ![](组成原理期末总结pic/5536045322bd44d1b6cb945a96aec551.png)  
> ![](组成原理期末总结pic/4ec06230238846349d88a6c78cc68242.png)

### 1.3 指令长度

*   一条指令所包含的二进制代码的总位数
*   主要取决于**操作码的长度、操作数地址的长度、操作数地址的个数**
*   与机器字长有简单的倍数关系：  
    单字长指令：指令长度等于机器字长的指令  
    半字长指令：指令长度等于半个机器字长的指令  
    双字长指令：指令长度等于机器字长的两倍的指令

> 机器字长：计算机能直接处理的二进制数据的位数

*   指令字长一般为字节的整数倍

2.数据类型
------

*   数据表示：计算机硬件能够直接识别、指令 系统可以直接调用的数据类型
*   数据结构：由软件进行处理和实现的各种数据类型

> 表示操作数的方法：
>
> 1.  由指令中的操作码指定操作数的类型
> 2.  给数据加上标识符（tag），有数据本身给出操作数类型

*   操作数的大小：操作数的位数或字节数  
    包括：字节（8位）、半字（16位）、 字（32位）、 双字（64位）
*   字符一般用ASCII码表示，大小为一个字节
*   整数用二进制补码表示，大小可以是字节、半字、单字和双字
*   浮点数分为单精度浮点数（单字）和双精度浮点数（双字）
*   所有计算机采用IEEE754浮点标准

3.寻址方式
------

*   计算机中，操作数可能存放在**主存储器、CPU中的寄存器、I/O接口寄存器或堆栈中**
    
*   形式地址与有效地址
    
*   寻址方式：确定指令操作数有效地址的方法
    

> 1.  直接寻址
>
> *   在指令的地址码字段直接给出操作数所在主存单元的地址 EA = A
> *   简单、快速的寻址方式，但寻址范围受限于地址码字段的位数
>
> ![](组成原理期末总结pic/eae699c806984fe2bdb57bbc1f7722ee.png)

> 2.  间接寻址
>
> *   指令的地址码字段给出的是操作数所在内存单元的地址的地址，即指令中形式地址所指定的内存单元中存放的内容才是操作数的真正地址 EA = (A)
> *   得到操作数需要访问两次内存，指令的执行速度比较慢
>
> ![](组成原理期末总结pic/4846d5ca06e34c729e7c15b434f22a45.png)

> 3.  立即寻址
>
> *   指令的地址码字段直接给出操作数本身

> 4.  寄存器直接寻址与间接寻址
>
> *   寄存器直接寻址：指令的地址码字段给出一个**寄存器编号**，该寄存器中存放的内容就是操作数 EA = Ri
>
> ![](组成原理期末总结pic/6efd6952b0a64811aa29a192c2b8f3d2.png)
>
> *   寄存器间接寻址：寄存器中存放的内容是操作数的地址，根据此地址访问内存取得操作数 EA = (Ri)
>
> ![](组成原理期末总结pic/7565a450126446a0943530ac6068a26d.png)

> 5.  隐含寻址
>
> *   指令中不给出操作数的地址
> *   通常操作数约定在某个特定的寄存器中或者在堆栈中

> 6.  相对寻址
>
> *   有效地址 = 形式地址（偏移量） + PC的内容 EA = (PC) + D(D是补码表示！！！)
> *   注意取址后PC自动+‘1’
>
> ![](组成原理期末总结pic/85938cdd54cc4e20a4374e7d1a471136.png)

> 7.  变址寻址
>
> *   有效地址 = 形式地址 + 变址寄存器的内容 EA = (RX) + D
> *   形式地址固定，变的是变址寄存器的内容
> *   变址寄存器可以是专用寄存器，也可以是通用寄存器中的一个
> *   常用于字符串处理、数组运算等成批数据处理中，主要是面向用户，解决**程序循环**控制问题
>
> ![](组成原理期末总结pic/079938364fd54df4a24efe9a4cc0bbc9.png)

> 8.基址寻址
>
> *   有效地址 = 详细地址 + 基址寄存器的内容 EA = (RB) + D
> *   基地址固定，变的是形式地址
> *   基址寄存器的内容称为基地址，常由操作系统或管理程序设定
> *   面向系统，解决程序重定位和扩大寻址空间等问题
>
> ![](组成原理期末总结pic/303a71913c5e4f9bafe8a0dc38221d67.png)

> 9.  “基址+变址”寻址
>
> *   有效地址 = 形式地址 + 基址寄存器RB的内容 + 变址寄存器RX的内容 EA = (RB)+(RX)+D

### 习题

![](组成原理期末总结pic/c3bf74c400e245a08eec890a4b488d11.png)

> ![](组成原理期末总结pic/9e2a2ceab34b49e29198b2f8d42c736e.png)  
> ![](组成原理期末总结pic/b3300befe9264b05b5fa0a691a2b2a7e.png)

> ![](组成原理期末总结pic/5aae61a039f14182b2922ec33222743e.png)  
> ![](组成原理期末总结pic/4f60f7f1825348c283d4a5655cc7677b.png)  
> ![](组成原理期末总结pic/9563b67632684663a2636d9c6cf16fe1.png)  
> ![](组成原理期末总结pic/103a690ebbf34c34bc9cb5d4f7cf8cd8.png)  
> ![](组成原理期末总结pic/fafa2773dc4a46539001558cbaeaa6ba.png)

![](组成原理期末总结pic/5fc90b8d34bf4e8ca3cf7d2a20556ba4.png)  
![](组成原理期末总结pic/32270ec848d24bed9ca681dbb0f0eb33.png)

4.指令类型与功能
---------

*   一个指令系统中的指令可以按功能分为**数据传送类指令、数据运算类指令、程序控制类指令、输入输出类指令**

> 1.  数据传输类指令
>
> *   将数据从一个地方传送到另一个地方
> *   主要实现主存和主存之间、主存和寄存器之间、寄存器和寄存器之间的数据传送
> *   数据传送指令一次可以传送一个数据，也可以一次传送一批数据

> 2.  数据运算类指令
>
> *   用来实现数据的算术运算、逻辑运算和移位运算
> *   算术运算：加、减、乘、除运算；加1 、减1；比较指令等
> *   逻辑运算：包括与、或、非 、异或等运算
> *   移位指令：算术移位、逻辑移位和循环移位三类，它们又可分为左移和右移两种

> 3.  程序控制类指令
>
> *   主要用来控制程序执行的顺序和方向
> *   包含转移指令、子程序调用和返回指令、自陷指令等

> 4.  输入输出指令
>
> *   主要用于实现主机与外部设备之间的信息交换

5.指令系统的设计
---------

*   包括指令的 **功能设计**和**指令格式设计**
*   在确定哪些基本功能用硬件来实现时，主要考虑3个因素：**速度、成本、灵活性**  
    硬件实现：速度快，成本高，灵活性差  
    软件实现：速度慢，价格便宜，灵活性好

### 5.1 对指令系统的基本要求

*   **对指令系统的基本要求：完整性、规整性、正交性、高效率、兼容性**
*   规整性包括对称性和均匀性

### 5.2 指令格式的设计

*   确定操作码字段和地址码字段的大小及其组合形式
*   确定各种寻址方式的编码方法
*   三种常见的指令编码格式：**可变长度编码格式、固定长度编码格式、混合型编码格式**

> 1.  可变长度编码格式：多用于CISC  
>     ![](组成原理期末总结pic/8bdb7ddff9bb4df98dee760d080b4000.png)
> 2.  固定长度编码格式：多用于RISC  
>     ![](组成原理期末总结pic/7319918108be4d34aec3495d4ab6f7f9.png)
> 3.  混合型编码格式  
>     ![](组成原理期末总结pic/61f409adf1154354850876b122dcf5a1.png)

6.指令系统的改变和发展
------------

*   **指令集分为复杂指令集合精简指令集**

> 复杂指令系统计算机CISC：
>
> *   强化指令功能，实现软件功能向硬件功能转移
> *   特点：指令数量多，功能多样
> *   **缺点**：各指令使用频率相差悬殊，许多指令很少用得到；指令系统庞大，指令条数多，许多指令的功能很复杂；CPI值大，执行速度慢；规整性不好，不利于采用流水线技术提高性能

> 精简指令功能计算机RISC：
>
> *   尽可能降低指令系统的复杂性，以达到简化实现，提高性能的目的
> *   **设计原则**：  
>     指令条数少、指令功能简单；  
>     采用简单而又统一的指令格式，并减少寻址方式；  
>     指令的执行在单个机器周期内完成；采用load-store结构；  
>     大多数指令采用硬连逻辑来实现；  
>     强调优化编译器的作用，为高级语言程序生成优化的代码；  
>     充分利用流水技术来提高性能

7.指令系统实例：MIPS的指令系统
------------------

*   典型的RISC结构

> MIPS的寄存器：
>
> *   32个64位的通用寄存器，R0的值永远是0
> *   32个64位浮点数寄存器
> *   其他特殊寄存器，如浮点状态寄存器

> MIPS的数据表示
>
> *   整数：字节、半字、字、双字
> *   浮点数：单精度、双精度  
>     字节、半字或者字在装入64位寄存器时，用零扩展或者**用符号位扩展来填充该寄存器的剩余部分**。装入以后，对它们将按照64位整数的方式进行运算

> MIPS的数据寻址方式
>
> *   立即数寻址和偏移量寻址
> *   两种寻址方式都是16位
> *   寄存器间接寻址是通过把0作为偏移量来实现的
> *   16位直接寻址是通过把R0（其值永远为0）作为基址寄存器来完成的
> *   MIPS的寻址方式是编码到操作码OP中的
> *   MIPS的存储器是按字节寻址的，地址为64位
> *   所有存储器访问都必须是边界对齐的

> MIPS的指令格式
>
> *   所有指令都是32位，操作码占6位
> *   共有三种格式：**I类指令、R类指令、J类指令**，三种指令格式中，同名字段的位置固定不变
>
> 1.  **I类指令**
>
> *   包括所有的load和store指令，立即数指令，分支指令，寄存器跳转指令，寄存器链接跳转指令
> *   立即数字段为16位，用于提供立即数或偏移量  
>     ![](组成原理期末总结pic/bb0a5a06f4894f6d9ae17cce08b8767d.png)  
>     ![](组成原理期末总结pic/302200c8b51e47fb8b0130ba08ac6250.png)

> 2.  **R类指令**
>
> *   包括ALU指令，专用寄存器读/写指令，move指令等  
>     ![](组成原理期末总结pic/a7326393884b40dfb7af4cdb1c55f40a.png)  
>     ![](组成原理期末总结pic/315342e328eb44f8bc4caf8d6510ba16.png)
>
> 3.  J类指令
>
> *   包括跳转指令，跳转并链接指令，自陷指令，异常返回指令
> *   在这类指令中，指令字的低26位是偏移量，它与PC值相加形成跳转的地址  
>     ![](组成原理期末总结pic/1a19ea4a4a9f4584bd9cf586858c6b03.png)

> MIPS的操作
>
> *   可分为四大类：  
>     load和store（I类）  
>     ALU操作（R类）  
>     分支与跳转（J类）  
>     浮点操作
> *   要求内存**边界对齐**  
>     ![](组成原理期末总结pic/98a8cc5ece3f4707819957f6c0bae65f.png)

第八章 中央处理器
=========

*   **CPU的组成：ALU、通用寄存器组、控制器**
    
*   **CPU的基本功能：指令顺序控制、操作控制、时间控制、数据加工**
    
*   指令执行的基本步骤：取指令、译码、执行、（PC+1）  
    ![](组成原理期末总结pic/25be87a8b675446fac58a8c0dd8382f7.png)
    

1.关于模型机
-------

> 模型机是MIPS结构的一种简单实现，实现了MIPS指令系统的核心子集

> 包含指令：
>
> *   算术运算指令：R类  
>     add、sub、and、or、slt，其操作码字段 OP=0
> *   存储器访问指令：I类  
>     lw（load word，op=35）、sw（store word，Op=43）
> *   等于"0"分支：I类  
>     beqz，OP=63

*   **指令字长都是4个字节（32位）**

> 1.  R类指令格式：  
>     OP——操作码字段  
>     rs——第一源操作数字段  
>     rt——第二源操作数字段  
>     rd——目标操作数字段（或结果字段）  
>     shamt——无用  
>     funct——ALU指令的运算函数码字段
>
> ![](组成原理期末总结pic/1ab1b3bb8ca24df9824a4349c82c1653.png)

> 2.  I类指令格式：  
>     rs——基址寄存器字段，对于beqz指令来说，是存放被检测的数据  
>     adr——偏移量字段，rs和adr用于计算访存有效地址或分支目标地址  
>     rt——对于load指令来说，rt所指出的寄存器是存放所取的数据；对于store指令来说，是存放要写入存储器的数据
>
> ![](组成原理期末总结pic/3ceab1a078a04839bf3ef075ff0da508.png)

2.逻辑设计的约定
---------

*   **CPU设计中的两种部件：对数据值进行操作的部件（组合逻辑电路）、包含状态的电路（时序电路）**
*   组合逻辑电路：没有内部状态，其输出仅依赖于当前的输入，与过去的值无关。在任何时候，对于相同的输入总是得到相同的输出
*   时序电路：状态部件的当前输出是前一个时钟周期写进去的值

3.实现MIPS的一个基本方案
---------------

### 3.1 构建基本数据通路

*   **两种典型的数据通路组织方式：基于总线的结构、直接连接**

> 基本部件：  
> ![](组成原理期末总结pic/7110295b45ee4a3aac964af94fb4d8bc.png)

> 1.  取指令的数据通路  
>     ![](组成原理期末总结pic/d372bebad8764a0da0ab2c0d8fe702af.png)

> 2.  R类指令的数据通路  
>     ![](组成原理期末总结pic/97a63dfb5c2c4947bdfccee582f62187.png)

> 3.  load指令的数据通路
>
> *   把指令字中的16位偏移量字段进行符号位扩展，变成32位数，送给ALU
> *   用IR\[rs\]作为地址去访问寄存器组Reg，读出的操作数送给ALU，与上一步扩展了的地址相加，计算出访存的有效地址，将之送到数据存储器DM的地址输入端DA
> *   从DM读出数据（将DMRead设置为有效），将该数据送到通用寄存器组的数据入口端WD，写入由IR\[rt\]指定的寄存器  
>     ![](组成原理期末总结pic/6d9d1e5fdbc64a2eb4fb72282a68057c.png)

> 4.  store指令的数据通路  
>     ![](组成原理期末总结pic/26d2e89bfce04860b23d05a00c202b0c.png)

> 5.  beqz指令
>
> *   把指令字中的16位偏移量字段（IR\[adr\]）进行符号位扩展，变成32位数，并**左移两位**送给ALU
> *   把PC＋4送给ALU的另一个输入，与上一步符号位扩展和左移后的地址相加，得到转移目标地址
> *   用IR\[rs\]作为地址去访问寄存器组Reg，读出操作数并送给判0部件。由该部件的输出确定是否分支成功
> *   如果为真，转移目标地址就成为新的PC值，分支成功；否则就用PC＋4代替PC中的值，分支失败  
>     ![](组成原理期末总结pic/27742fe78803481c82a0342016737a1e.png)

### 3.2 ALU控制器

*   **模型机中控制器分为主控制器与ALU控制器**  
    ![](组成原理期末总结pic/1f8a7a0785eb4f8e87baf06091963308.png)  
    ![](组成原理期末总结pic/59fcffefed5c4432af0b29e386079d10.png)

> ALUOp的定义：
>
> *   load指令和store指令：  
>     ALUOp=00，让ALU做加法，计算访存的有效地址
> *   beqz指令：  
>     ALUOp=00，让ALU做加法，计算分支目标地址
> *   R类指令  
>     ALUOp=10，ALU完成and、or、add、sub中的某一个，具体取决于指令中funct字段的值

### 3.3 单周期数据路径的控制器

![](组成原理期末总结pic/d94af5c2030a4ada9da8415fa28638dc.png)

4.多周期实现方案
---------

> 单周期的缺点
>
> *   效率低
> *   单周期时间只能去最长的数据通路所花的时间
> *   每个时钟周期中功能部件最多被使用一次

*   多周期采用更短的时间作为时钟周期，允许指令的执行时间为多个时钟周期

![](组成原理期末总结pic/d7b381977c4d45609829bea4c6a9041f.png)

> 按周期分步：
>
> *   取指令周期(IF)
> *   指令译码/读存储器周期(ID)
> *   执行/有效地址计算周期(EX)
> *   存储器访问/R类指令和分支指令完成周期(MEM)
> *   写回周期(WB)

5.控制器的设计
--------

*   **实现控制器的技术：硬连逻辑、微程序设计**

> 控制器的组成：
>
> 1.  指令部件包括：
>
> *   程序计数器PC
> *   指令寄存器IR
> *   指令译码器ID
> *   地址形成部件
>
> 2.  时序控制部件
> 3.  微操作控制信号形成部件
> 4.  中断控制逻辑
> 5.  程序状态寄存器PSR
>
> ![](组成原理期末总结pic/51f4d65e2f9841f384d1ae9592014d4c.png)

> 控制方式：
>
> *   同步控制方式：机器有统一的时钟信号（称为系统时钟），所有的微操作控制信号都与时钟信号同步
> *   异步控制方式：各部件之间没有统一的时钟和节拍，而是各部件有自己的时钟

> 时序系统： **计算机的三级时序系统：指令周期、节拍、脉冲**
>
> *   指令周期：从取指令、分析指令到执行完该指令所需的全部时间，**一般由若干时钟周期构成**
> *   节拍：节拍的宽度（时间）一般语系统的时钟周期数相同
> *   脉冲
>
> ![](组成原理期末总结pic/9679aaf9a38d49eca0e263f431fa83ac.png)  
> 每个指令周期包含5个节拍T0～T4，每个节拍有一个脉冲

第九章 微程序控制器
==========

*   组合逻辑控制器的缺点：  
    设计复杂、繁琐，缺乏规律性，设计效率低  
    不易修改和扩充，缺乏灵活性
*   微程序技术能很好的解决上述问题，但速度比较慢

1.基本原理
------

*   用二进制编码字（微指令字）来代替组合逻辑控制器中的微操作控制信号的产生
*   把在一条指令的执行过程中各节拍要进行的微操作集合都用一个微指令字来表示，然后把他们按节拍的先后顺序存放到一个特殊的存储器中（称为控制存储器CM）
*   执行该指令时，按顺序依次读出微指令字

> *   微命令：构成控制信号序列的**最小单位**
> *   微操作：执行部件接受微命令后进行的最基本的、不可再细分的操作，分为相容的微操作和互斥的微操作
> *   微指令：用来产生微控制信号的二进制编码字
> *   微程序：一系列微指令构成的有序集合，**每条机器指令都对应于一段微程序**
> *   微指令周期：微程序控制器的工作周期

2.微程序控制器的组成与工作过程
----------------

![](组成原理期末总结pic/73523ec2860a4a3996beaa6c546dcd41.png)

> 1.  控制存储器CM
>
> *   存放实现整个指令系统的所有微程序
> *   每个单元存放一条微指令字
>
> 2.  微指令寄存器μIR
>
> *   用来存放从控存读出的当前微指令
>
> 3.  微地址形成电路
>
> *   根据控制地址字段中的信息产生后续微地址
>
> 4.  微地址寄存器μMAR
>
> *   接受微地址形成电路送来的地址，为读取下一条微指令做好准备
>
> 5.  地址译码器
>
> *   将μMAR中的微地址进行译码，找到被访问的控存单元，将其中的微指令读出并存放于μIR中

> **微程序控制器的工作过程**
>
> 1.  启动取指微程序，把要执行的机器指令（其地址由PC给出）从主存取到指令寄存器IR中，并完成对PC的增量操作
> 2.  根据IR中指令的操作码，微地址形成电路产生该指令的微程序的入口地址，并送入μMAR
> 3.  μMAR中的微地址经过译码，从控存中读取相应的微指令，送入μIR
> 4.  μIR中微指令的操作控制字段直接（或经过译码）产生一组微命令，送往相应的功能部件，控制它们完成所规定的微操作
> 5.  微地址形成电路根据μIR中微指令的地址控制字段和机器的状态信息（如程序状态字PSW），产生下一条微指令的地址并送往μMAR
> 6.  重复上述步骤第三到第五步，直到该机器指令的微程序全部执行完毕

3.微程序设计技术
---------

### 3.1 微指令的编码方法

*   微指令 = 微操作控制字段 + 地址控制字段
*   **四种方法：直接控制编码、最短字长编码、分段直接编码、分段间接编码**

> 1.  直接控制编码法
>
> *   微操作控制字段的每一位直接对应一个微操作：当某位为1时，就表示执行相应的微操作；为0时就不执行该微操作
> *   优点：结构简单，并行性最好，操作速度快
> *   缺点：微指令字太长
>
> ![](组成原理期末总结pic/07c8d93ec240466ca92a5bc24bcebdf9.png)

> 2.  最短字长编码法
>
> *   将所有的微命令进行统一的二进制编码，每条指令只定义一个微操作
> *   微操作控制字段的长度L与微命令的总数N的关系：L ≥ log2N
> *   需要对整个微操作控制字段进行编码
>
> ![](组成原理期末总结pic/4eb689aa75774e8f9b63aadbd3eb6684.png)

> 3.  字段直接编码法
>
> *   把微操作控制字段进一步划分为若干个字段，每个字段单独编码，每个码点表示一个微命令
> *   **字段之间采用直接控制，字段内部采用最短字长编码**
> *   既能缩短微指令字长，又能实现较高的并行性，执行速度比较快。
> *   **设计原则：** 把互斥的微操作分在同一字段，把相容的微操作分到不同的字段；字段的划分应与数据通路相适应；一般每个字段应留出一个码点，用于表示不发任何微命令
>
> ![](组成原理期末总结pic/077ba65b8baf48878a82d834d0301380.png)

> 4.  字段间接编码法（_了解_）
>
> *   字段的编码的含义（即表示什么微命令）要由另外一个字段的编码来解释确定
>
> ![](组成原理期末总结pic/c86307b52800410bb6f9559f4d3e6e42.png)

### 3.2 微指令格式

*   **分为两大类：水平型微指令和垂直型微指令**

### 3.3 微程序的顺序控制

> 微程序入口地址的形成：
>
> *   公用的“取指令”微程序一般存放在控存中第0号单元或其它指定的控存单元开始的一片控存区域中。（这个地址是固定不变的）
> *   根据IR中的操作码，找到该指令所对用的微程序的入口地址  
>     两种实现方法：
>
> 1.  直接对应法
>
> *   直接把操作码与微地址码的部分位对应
> *   适用于所有指令的操作码的位数和位置都相同时
>
> 2.  查表法：
>
> *   在操作码的位数或位置不固定的情况下，需要用专门的硬件实现操作码到入口地址的映象
> *   用**PLA**或**ROM**实现一个表格，该表格给出了各操作码所对应的微程序的入口地址
> *   使用该表时，只要用操作码作为输入，就能在其输出端得到该指令的微程序入口地址

> **后继微地址的形成**：
>
> 1.  增量方式
>
> *   顺序执行时，给μPC增加一个增量（通常为1）给出下一条微指令的地址  
>     ![](组成原理期末总结pic/1f4aa45d4eac4488a09bbdad6a4c704a.png)
> *   转移控制字段BCF用于固定是顺序实行还是转移，如果是转移，就有BCF指出转移地址的来源
> *   转移地址字段BAF
> *   转移地址的来源：**由BAF给出的地址；机器指令所对应的微程序的入口地址；微子程序入口地址和返回地址（存放在返回地址寄存器中）**
> *   优点：SCF字段比较短，后继微地址生成逻辑比较简  
>     单，编制微程序也比较容易
> *   缺点：不能直接实现多路转移
>
> ![](组成原理期末总结pic/1dc43bf8a56e46a3a3a81951d4f943cb.png)
>
> 2.  断定方式
>
> *   由微程序设计者直接指定
> *   由微程序设计者指定的测试判别逻辑字段控制产生
> *   后继地址由两部分组成：  
>     非测试地址：微程序设计者直接指定的，是不变的，构成微地址的高位部分  
>     测试地址：在微程序的执行过程中，通过测试一些状态位而动态决定的，它构成微地址的低位部分
> *   测试地址的位数决定了并行分支的路数，而且也决定了测试控制字段的个数
> *   优点：能够实现快速多路转移，提高微程序的执行速度。而且微程序在控存中的存放位置也很灵活、方便。
> *   缺点：后继微地址的生成方法比较复杂，微程序的执行顺序不直观
>
> ![](组成原理期末总结pic/c65024792df84c1da3b3487768acfb1d.png)  
> ![](组成原理期末总结pic/d36524eb4c4248eeb56627c81e2ae24b.png)  
> ![](组成原理期末总结pic/77f4622b769146b5acee8846e98de4e1.png)

4.模型机的微指令格式
-----------

*   模型机中确定下一条微指令地址的来源：**当前微指令地址加1、转移到“取指令”的公共入口、根据指令操作码散转到该指令（或该类指令）的入口**

第十章 运算方法与运算器
============

1.移位运算
------

> 1.  逻辑移位
>
> *   被移位的数据是逻辑数（无符号，无大小）
> *   逻辑左移shl：按位左移，最高位丢弃，最低位补0
> *   逻辑右移shr：按位右移，最低位丢弃，最高位补0
>
> ![](组成原理期末总结pic/cfc3a7faad3c4143b2e232dc8eaa6d96.png)

> 2.  循环移位
>
> *   循环移位中将被移位数据的左右两端连接起来，形成闭合的移位环路
>
> ![](组成原理期末总结pic/1d359ec1ad8e4954b526c1e2b1d88b53.png)

> 3.  算术移位
>
> *   原码算术移位：**符号位不参加移位**，只将数值位依次移动，补0
>
> ![](组成原理期末总结pic/8841e2d253364f01b790cf116d89068a.png)
>
> *   补码算术移位：  
>     算术左移：连同符号位整体左移，最高位（符号位）丢弃，最低位补0  
>     算术右移：连同符号位整体右移，**符号位保持不变**，最低位丢弃
>
> ![](组成原理期末总结pic/1018857ef8b9421992266dcd601e0b2e.png)

2.定点数的加减法运算
-----------

*   运算规则：  
    设\[X\]补与\[Y\]补均为n位补码数，其中包含一位符号位  
    \[X＋Y\]补＝\[X\]补＋\[Y\]补  
    \[X－Y\]补＝\[X\]补＋\[－Y\]补 （mod M）  
    如果X、Y是定点小数，则M=2；如果X、Y是定点整数，则M=2n

> 硬件实现：
>
> *   as为0时，\[F\]补 = \[X\]补＋\[Y\]补
> *   as为1时，\[F\]补 = \[X\]补 - \[Y\]补
>
> ![](组成原理期末总结pic/08cfeae7fa674a5e910e92f79d144530.png)

> 溢出的判断
>
> *   分为正溢出（正数）与负溢出（负数）  
>     三种方法：
>
> 1.  采用两个操作数和结果的符号来判断
>
> *   当两个同号数的补码相加，若得到的结果的符号与两个操作数的符号不同，则发生了溢出  
>     ![](组成原理期末总结pic/f06eaa146c174319a19dd40d1edea2d9.png)
>
> 2.  采用最高数值位产生的进位与符号位产生的进位是否相同来判断，当不相同时，则发生了溢出  
>     ![](组成原理期末总结pic/c16439649b7f45c38f89547e67d426c0.png)
> 3.  采用变形补码来判断
>
> *   变形补码：两位符号位  
>     ![](组成原理期末总结pic/e11ff8a971374880b88da1e53b9b3eda.png)
> *   当结果的变形补码的两个符号位不同，则溢出
> *   若结果符号位为01，则表示结果为正溢出；若结果符号位为10，则表示结果为负溢出  
>     ![](组成原理期末总结pic/8b063c9aec2141399e15ed5989ea4178.png)  
>     ![](组成原理期末总结pic/2cbd059e29bc4b72a6f95a30725c5e5e.png)

3.定点数的乘除法运算
-----------

> 原码一位乘法
>
> *   符号位单独处理：同号相乘，乘积为正；异号相乘，乘积为负
> *   结果的数值部分是两个数的绝对值相乘，即两个正数相乘  
>     ![](组成原理期末总结pic/75eaeb3687974291b0ca0b6658ef507a.png)  
>     ![](组成原理期末总结pic/3247967a00544eca91ec423561106a37.png)  
>     ![](组成原理期末总结pic/8b4287988129461eb64b64efda5e5a19.png)  
>     ![](组成原理期末总结pic/2ebeae6a0d0e438da0229318c847df0e.png)

4.浮点运算
------

*   步骤：**判0操作、对阶、尾数加/减、规格化、舍入**

> 1.  判0操作
>
> *   判断两个操作数中是否有为0的，若有则不需要进行运算，直接就能设置运算结果（为0）
>
> 2.  对阶
>
> *   使小数点对齐
> *   使两个操作数的阶码相等  
>     求阶差△E＝XE－YE  
>     若△E＞0，则表示X的阶码大于Y的阶码，需调整操作数Y：将Y的尾数YM右移；每右移一位，其阶码YE加1，直到两数的阶码相等为止  
>     若△E＜0，则表示X的阶码小于Y的阶码，需调整操作数X。调整的方法与上面的一样
>
> 3.  尾数加/减
>
> *   按**定点加减运算**
>
> 4.  结果规格化并判溢出
>
> *   若得到的运算结果的绝对值大于1，则需要右规  
>     将该结果右移一位，相应的阶码加1
> *   若得到的运算结果的绝对值小于1，则需要左规  
>     将该结果左移，每左移一位，相应的阶码减1，直到运算结果的绝对值大于等于1/2为止
> *   在规格化时，阶码每次加1或减1以后，都要判断阶码是否超出所能表示的范围
>
> 5.  舍入处理
>
> *   0设1入法
> *   截断法
> *   朝＋∞舍入法
> *   朝－∞舍入法
>
> ![](组成原理期末总结pic/092007e619ff4b4287943ebb9b7afcb8.png)

> ![](组成原理期末总结pic/e682436d0f084c71a223ab282c77ec4a.png)  
> ![](组成原理期末总结pic/833229e0f9994b849a693928776e5d34.png)  
> ![](组成原理期末总结pic/d54c61ba838d4a5e9a63e2dca1aad3bc.png)

5.运算器的构成
--------

*   算术运算逻辑单元ALU、寄存器组、数据总线

第十一章 存储器
========

![](组成原理期末总结pic/a5b7e5971ff64e0b8a490d34136e42f5.png)

1.存储子系统
-------

> 三级存储系统
>
> *   Cache：高速缓冲存储器——速度最快，容量最小
> *   主存储器
> *   磁盘存储器（辅存）——速度最慢，容量最大

> 两个存储层次
>
> 1.  “Cache——主存”层次：解决主存速度不足的问题
>
> *   对系统程序员和应用程序员都透明  
>     2… “主存——辅存”层次：解决主存容量不足的问题
> *   对系统程序员不透明

2.存储器的分类
--------

*   按计算机系统中的作用分类：主存、辅存、Cache
*   按存取方式分类：随机存储器RAM、制度存储器ROM、顺序存取存储器SAM
*   按存储介质分类：半导体存储器、磁表面存储器、光存储器

3.其他
----

*   数据在存储器中的存放：字节顺序、整数边界
*   主存的主要技术指标：**存储容量、存取速度、可靠性、功耗**
*   动态RAM的刷新：**集中式刷新、分散式刷新、异步式刷新**
*   并行存储器：单体多字存储器、多体交叉存储器
*   辅存：磁表面存储器、磁盘存储器、光盘存储器

4.主存的设计
-------

> 1.  位扩展法
>
> ![](组成原理期末总结pic/2029d19a1ab54e4691a09fc0a999f786.png)

> 2.  字扩展法
>
> ![](组成原理期末总结pic/c58940df6e0445a2b0efca7a345f94bf.png)  
> ![](组成原理期末总结pic/7169bf81ac564759a54beeb61cf8d552.png)  
> ![](组成原理期末总结pic/bbda17be68b94bb5ab2f77d6683094f2.png)

> 3.  字和位同时扩展法  
>     ![](组成原理期末总结pic/56d32cb50aa14ac9bf38765bc69529fa.png)  
>     ![](组成原理期末总结pic/b253d12ba0284a689cdbe2d00eb55136.png)