* * *

[1、计算机系统概述](https://blog.csdn.net/qq_44709990/article/details/107992763)
------------------------------------------------------------------------

### 1.1、[计算机系统](https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020)层次结构

#### 1.1.1、系统的组成

**硬件系统和软件系统共同构成了一个完整的计算机系统。硬件指有形的物理设备，是计算机系统中实际物理装置的总称。软件指在硬件上运行的程序和相关的数据及文档。**

**计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。**

#### 1.1.2、计算机硬件

**1、冯 · 诺依曼机的特点：**

1.  **计算机由五大部件组成：输入输出设备，存储器，运算器，控制器；**
2.  **指令和数据以同等地位存于存储器，可按地址寻访；（按地址访问并顺序执行指令）**
3.  **指令和数据用二进制表示， 指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。**
4.  **存储程序 （控制流驱动方式）**
5.  **以运算器为中心（I / O 设备与存储器之间的数据传送通过运算器完成） 现在一般以存储器为中心**

**“存储程序” 的基本思想是：将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。**

**2、计算机的功能部件**

**（1）输入设备：键盘、鼠标、扫描仪、摄像机等。**

**（2）输出设备：显示器、打印机等。**

**（3）存储器**

存储器分为主存储器（又称内存储器）和辅助存储器（又称外存储器)。CPU 能够直接访问的存储器是主存储器。辅助存储器中的信息必须调入主存后，才能被 CPU 所访问。

**地址寄存器 (MAR) 存放访存地址，经过地址译码后找到所选的存储单元。**

**数据寄存器 (MDR) 用于暂存要从存储器中读或写的信息。**

存储体由许多[存储单元](https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83&spm=1001.2101.3001.7020)组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码 “0” 或 “1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是 1B（8bit）或是字节的偶数倍。

**MAR 用于寻址，其位数对应着存储单元的个数，如 MAR 为 10 位，则有 210 = 1024 个存储单元，记为 1K。MAR 的长度与 PC 的长度相等（与地址码长度相等）。**

**MDR 的位数和存储字长相等，一般为字节的二次幂的整数倍。**

注意：[MAR](https://so.csdn.net/so/search?q=MAR&spm=1001.2101.3001.7020) 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU中 ，高速缓存（Cache）也存在于CPU中。

**（4）运算器（不含地址寄存器）**

运算器为执行部件，用于进行算术运算和逻辑运算，其核心是算术逻辑单元 ALU，包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC），乘商寄存器 ( MQ )，操作数寄存器（X）、变址寄存器（IX）、基址寄存器(BR)等，其中前 3 个寄存器是必须具备的。运算器内还有程序状态寄存器（PSW）, 也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。

**（5）控制器（CPU含地址寄存器，不含地址译码器）**

计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（PC），指令寄存器（IR）和控制单元（CU）组成。

PC 用来存放当前欲执行指令的地址，可以自动加 1 以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。

IR 用来存放当前的指令（存放欲执行指令的寄存器），其内容来自主存的 MDR。指令中的操作码 OP（IR）送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad(IR) 送往 MAR，用以取操作数。

一般将运算器和控制器集成到同一个芯片上，称为中央处理器 (CPU)。CPU 和主存储器共同构成主机，除主机外的其他硬件装置（外存、I/O设备等）统称为外部设备，简称外设。

CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线。MAR 中的地址信息会直接送到地址线上，用于指向读／写操作的主存存储单元；控制线中有读 / 写信号线，指出数据是从 CPU 写入主存还是从主存读出到 CPU，根据是读操作还是写操作来控制将 MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到 MDR 中。

ACC

累加计数器，存放操作数、运算的结果

**MQ**

**乘商寄存器，进行乘、除法时用得到**

**X**

**通用寄存器，存放操作数**

**ALU**

**算术逻辑单元，用电脑实现各种算数运算、逻辑运算**

**PC**

**程序计数器，存放下一条指令的地址**

**IR**

**指令寄存器，存放当前执行的指令**

**CU**

**控制单元，分析指令，给出控制信号**

**MAR**

**地址寄存器，用于指明要读/写哪个存储单元。其长度反映存储单元数量**

**MDR**

**数据寄存器，用于暂存要读/写的数据。其位数 = 存储字长**

#### 1.1.3、计算机软件

系统软件主要有操作系统(OS)、数据库管理系统(DBMS)、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序，编译程序等。

应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序，数据库系统等。

**三个级别的语言：**

1）机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。  
2）汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译。将其转换为机器语言程序后，才能在计算机的硬件系统上执行。  
3）高级语言。高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

**翻译程序的分类：**

1）汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。  
2）解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。  
3）编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。

#### 1.1.4、层次结构

 **下层是上层的基础，上层是下层的扩展。**

![](https://img-blog.csdn.net/20150517230944333)

#### 1.1.5、工作原理

**1、“存储程序”工作方式**

**一个程序的执行就是周而复始地执行一条一条指令（指令和数据预先存储在主存中）的过程。每条指令执行过程包括：从主存取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。**

程序执行前，先将程序第一条指令的地址存放到 PC 中，取指令时，将 PC 的内容作为地址访问主存。在每条指令执行过程中，都需要计算下条将执行指令的地址，并送至PC。若当前指令为顺序型指令，则下条指令地址为 PC 的内容加上当前指令的长度；若当前指令为跳转型指令，则下条指令地址为指令中指定的目标地址。

**2、从源程序到可执行文件**

![](https://img-blog.csdnimg.cn/5488a638c737481f96f1783d0aacb93e.png)

**3、指令执行过程的描述**

以取数指令（送至运算器的 ACC 中）为例来说明，其信息流程如下：

1）取指令：PC—>MAR—>M—>MDR—>IR  
根据 PC 取指令到 IR。将 PC 的内容送MAR，MAR 中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR 从数据线接收指令信息，并传送到 IR 中。  
2）分析指令：OP(IR)—>CU  
指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR 中是取数指令，因此读控制信号被送到总线的控制线上。  
3）执行指令：Ad(IR)—>MAR—>M—>MDR—>ACC  
取数操作。将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线，同时控制器将读信号送读/写信号线，从主存中读出操作数，并通过数据线送至 MDR,再传送到 ACC 中。  
每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即(PC)+1—>PC。（PC）指程序计数器 PC 中存放的内容。PC—>MAR 应理解为 （PC）—> MAR）

![](https://img-blog.csdnimg.cn/9539ecc7db4d488ea270460bfe7a97fb.png)

#### 1.1.6、本节习题

**01、计算机硬件能够直接执行的是【机器语言程序（二进制编码）】。**

**02、冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是【C】。**  
**A. 指令操作码的译码结果 B. 指令和数据的寻址方式**  
**C. 指令周期的不同阶段 D. 指令和数据所在的存储单元**

**解析：通常在取指阶段取出的是指令，在执行阶段取出的是数据。**

### 1.2、计算机性能指标

#### 1.2.1、主要性能指标

**1、字长**

计算机进行一次定点整数运算所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。因此，字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。通常选定为字节（8位）的整数倍。

2、数据通路带宽（外部数据总线的宽度）：数据总线一次所能并行传送信息的位数。

**3、主存容量**

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长（如512K×16位）来表示存储容量。其中，MAR 的位数反映存储单元的个数，MAR 的位数反映可寻址范围的最大值（不一定是实际存储器的存储容量）。  
**例如，MAR 为 16 位，表示 216 = 65536，即此存储体内有 65536 个存储单元（可称为 64 K内存，1K = 1024)，若 MDR 为 32 位，表示存储容量为 64K×32位。**

**4、运算速度**

**（1）吞吐量和响应时间**

*   **吞吐量： 指系统在单位时间内处理请求的数量。系统吞吐量主要取决于主存的存储周期。**
*   响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括 CPU 时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I / O操作、操作系统开销等时间)。

**（2）主频和 CPU 时钟周期**

*   CPU 时钟周期：通常为节拍脉冲或 T 周期，即主频的倒数。它是 CPU 中最小的时间单位，执行指令的每个动作至少需要 1 个时钟周期。
    
*   主频（CPU时钟频率）。机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。
    
    注意：CPU 时钟周期 = 1／主频，主频通常以 Hz（赫兹）为单位，1Hz 表示每秒 1 次。
    

**（3）CPI：执行一条指令所需的时钟周期数。**

**（4）CPU 执行时间 = CPU 时钟周期数 / 主频 = （指令条数 x CPI）/ 主频**

**（5）MIPS：每秒执行多少百万条指令。**

 **MIPS = 指令条数 / （执行时间 x 106 ）**

 **IPS：每秒执行多少条指令。 IPS = 主频 / 平均CPI； 主频 = 1 / 时钟周期。**

![](https://img-blog.csdnimg.cn/8c3027a9ceab4d8a9dfbaf88aa233350.png)

**注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 1Kb=210b；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 1kb/s = 103b/s。**

#### 1.2.2、本节习题

**01、计算机中，CPU 的 CPI 与下列【A】因素无关。**  
**A. 时钟频率 B. 系统结构 C. 指令集 D. 计算机组织**

**解析：CPI 是执行一条指令所需的时钟周期数，系统结构、指令集、计算机组织都会影响 CPI，而时钟频率并不会影响 CPI，但可加快指令的执行速度。例如，执行一条指令需要 10 个时钟周期，则一台主频为 1GHz 的 CPU，执行这条指令要比一台主频为100MHz 的 CPU 快。**

**02、计算机“运算速度”指标的含义是每秒能执行多少条【指令】。**

**03、假定计算机 MI 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2GHz。在 MI 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 MI 和 M2 上运行时间的比值是【1.6】。**

**解析：运行时间 = 指令数 × CPI／主频 = 指令数 × CPI × T。**

**04、下列给出的部件中，其位数（宽度）一定与机器字长相同的是【ALU、通用寄存器】。**

**机器字长是指 CPU 内部用于整数运算的数据通路的宽度。CPU 内部数据通路是指 CPU 内部的数据流经的路径及路径上的部件，主要是 CPU 内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致才能相互匹配。因此，机器字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度。**

**05、设主存储器容量为 64K x 32 位，且指令字长、存储字长、机器字长三者相等。写出如下图所示各寄存器的位数，并指出哪些寄存器之间有信息通路。**

![](https://img-blog.csdnimg.cn/48a539c18ddc48768a0e62ee5810e56e.png)

**解析：由于主存容量为 64K×32位，因 216 = 64K，则地址总线宽度为 16 位，32 位表示数据总线宽度，因此 MAR 为 16 位，PC 为 16 位，MDR 为 32 位。**

**因指令字长 = 存储字长 = 机器字长，则 IR、ACC、MQ、X 均为32位。**  
**寄存器之间的信息通路有：**  
**PC—>MAR**  
**Ad(IR)—>MAR**  
**MDR—>IR**  
**取数：MDR—>ACC，存数：ACC—>MDR**  
**MDR—>X**

* * *

### 1.3、简答题

**（1）计算机由哪几部分组成？以哪部分为中心？**  
**计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成。现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。**  
**而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。**  
**随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已经发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。**

* * *

**（2）主频高的 CPU 一定比主频低的 CPU 快吗？为什么？**  
**衡量 CPU 运算速度的指标有很多，不能以单独的某个指标来判断 CPU 的好坏。CPU 的主频，即CPU 内核工作的时钟频率。CPU 的主频表示 CPU 内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看 CPU 的流水线的各方面的性能指标（架构、缓存、指令集、CPU 的位数、Cache大小等)。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。**

* * *

**（3）不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？**  
**机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直接执行。**

* * *

**（4）基准程序执行得越快说明机器的性能越好吗？**  
**一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。**

* * *

**（5）什么是透明性？透明是指什么都能看见吗？**  
**在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念正好相反。**

**例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的。**

* * *

**（6）翻译程序、解释程序、汇编程序、编译程序的区别和联系是什么？**  
**翻译程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无须重新翻译。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。**  
**汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。**  
**编译程序与汇编程序的区别：若源语言是诸如 C、C++、Java 等“高级语言“，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器浯言，则这样的一个翻译程序称为汇编程序。**

* * *

**（7）字、字长、机器字长、指令字长、存储字长的区别和联系是什么？**  
**在通常所说的“某 16 位或 32 位机器”中，16、32指的是字长，也称机器字长。所谓字长，通常是指 CPU 内部用于整数运算的数据通路的宽度，因此字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。**  
**指令字长：一个指令字中包含的二进制代码的位数。**  
**存储字长；一个存储单元存储的二进制代码的长度。**  
**它们都须是字节的整数倍。**  
**指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指周期等于机器周期。**  
**早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。**

* * *

**（8）什么是存储程序原理？按此原理，计算机应具有哪几大功能？**

**存储程序是指将指令以代码的形式事先输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。**  
**计算机按照此原理应该具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能。**

* * *

[2、数据的表示和运算](https://blog.csdn.net/qq_44709990/article/details/108017204)
-------------------------------------------------------------------------

### 2.1、数制与编码

**01、下列各种数制的数中，最小的数是【B】。**

**A. (101001)2 B. (101001)BCD C. (52)8 D. (233)16**

**解析：A 为 29H，B 为 29D，C 写成二进制数为 101010，即 2AH，显然最小的为 29D。注意，没有特殊说明时，可默认 BCD 码就是 8421 码。**

* * *

**02、若 X 为负数，则由 \[X\]补 求 \[-X\]补 是将【 \[X\]补 连同符号位一起变反，末位加 1 】。**

* * *

**03、对于相同位数（设为 N 位，不考虑符号位）的二进制补码小数和十进制小数，二进制小数能表示的数的个数 / 十进制小数所能表示数的个数为【(0.2)N】。**  
解析： N 位二进制小数可以表示的数的个数为 1 + 20 + 21 + ········· + 2N-1 = 2N ，而十进制小数能表示  
的数的个数为 10N，二者的商为（0.2）N。这也是为何在计算机的运算中会出现误差情况的原因，它表明仅有 （0.2）N 概率的十进制数可以精确地用二进制表示。

* * *

**04、若 \[x\]补 = 1，x1x2x3x4x5x6，其中 xi 取 0 或 1，若要 x > -32，应当满足【x1 为 1，x2 ······x6 中至少有一位为 1】。**  
**解析：\[x\]补 的符号位为 1，所以 x 一定是负数。绝对值越小，数值越大，所以要满足 x > - 32，则 x 的绝对值必须小于 32。因此，x1 为 1，x2 ······x6 中至少有一位为1；这样，各位取反末尾加 1 后，x1 一定为 0，x2 ······x6 中至少有一位为 1，使得 x 的绝对值保证小于 32。**  
**解题技巧：使用补码表示时，若符号位相同，则数值位越大码值越大。**

* * *

**05、设 x 为真值，x\* 为其绝对值，满足\[ - x\* \]补 = \[ - x \]补，当且仅当【D】。**  
**A. x 任意 B. x 为正数 C. x 为负数 D. 以上说法都不对**

解析：当 x 为 0 或为正数时，满足 \[ - x\* \]补 = \[ - x \]补，B 为充分条件，因此 B 错误。而 x 为负数时，-x 为正数，而 -x\* 为负数，补码的表示是唯一的，显然二者不等，因此 C 错误

* * *

**06、一个 n+1 位整数 x 原码的数值范围是【- 2n + 1 ≤ \\leq ≤ x ≤ \\leq ≤ 2n - 1】**

 **一个 n+1 位小数 x 原码的数值范围是【- (1 - 2\-n ) ≤ \\leq ≤ x ≤ \\leq ≤ 1 - 2\-n】**

 **一个 n+1 位整数 x 补码的数值范围是【- 2n ≤ \\leq ≤ x ≤ \\leq ≤ 2n - 1】**

 **一个 n+1 位小数 x 补码的数值范围是【- 1 ≤ \\leq ≤ x ≤ \\leq ≤ 1 - 2\-n】**

**移码常用来表示浮点数的阶码。它只能表示整数。**

 **\[x\]移 = 2n + x （-2n ≤ \\leq ≤ x ≤ \\leq ≤ 2n，其中机器字长为 n + 1）**

**当 纯整数 x 为负数时：**

      **\[ x \]补 = 2n+1 - | x | \[ x \]原 = 2n + | x |**

**当 纯小数 x 为负数时：**

     **\[ x \]补 = 2 - | x | \[ x \]原 = 1 + | x |**

* * *

**07、若寄存器内容为 10000000，若它等于 - 0，则为【原码】。**

 **若寄存器内容为 00000000，若它等于 - 128，则为【移码】。**

 **若寄存器内容为 11111111，若它等于 - 1，则为【补码】。**

 **若寄存器内容为 11111111，若它等于 +127，则为【移码】。**

 **0 的移码：1000···0（n 个 “0”）** **\-128 的补码：10000000**

 **同一数值的移码和补码除最高位相反外，其他各位相同。**

* * *

**08、在计算机中，通常用来表示主存地址的是【无符号数】。**  
**解析：主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。**

* * *

**09、由 3 个 “1” 和 5 个 “0” 组成的 8 位二进制补码，能表示的最小整数是【-125】。**

**解析： 使用补码表示时，若符号位相同，则数值位越大码值越大。绝对值越小，数值越大。**

**1000 0011 ——> 1111 1101 <——> -125**

* * *

**10、下列为 8 位移码机器数 \[ x \]移，求 \[ - x \]移 时，【B】将会发生溢出。**  
**A. 11111111 B. 00000000 C. 10000000 D. 01111111**

**解析：选项 B 对应 8 位最小的值 - 128，而 - x = 128 发生溢出，因此无法表示其移码。**

* * *

![](https://img-blog.csdnimg.cn/7ed4aeed4b354aee81868e1830f72de0.png)

* * *

![](https://img-blog.csdnimg.cn/c42953ed24d74d2e8345ae1cfdf6e6e9.png)

* * *

![](https://img-blog.csdnimg.cn/59d5f83f50cd4fceb221aba07b71ed3d.png)

* * *

### 2.2、运算方法和运算电路

**01、算术移位** **不同机器数移位（有符号数）后空位添补规则**

码制

添补代码

**正数**

**原码、补码、反码**

**0**

**原码**

**0**

**负数**

**补码**

**左移添 0**

**补码**

**右移添 1**

**反码**

**1**

**02、逻辑移位（无符号数）**  
**移位规则：逻辑 左移 时，高位移丢，低位添 0；逻辑 右移 时，低位移丢，高位添 0。**

* * *

**03、补码加减运算公式（设机器字长为 n + 1)**

**\[ A + B \]补 = \[ A \]补 + \[ B \]补 （ mod 2n+1 ） \[ A - B \]补 = \[ A \]补 + \[ - B \]补 （ mod 2n+1 ）**

注：最终运算结果的高位丢弃，保留 n + 1 位，运算结果亦为补码。

**【例】设机器字长为 8 位（含 1 位符号位)，A = 15，B = 24，求 \[ A + B \]补 和 \[ A - B \]补。**

**解：A = +15 = +000 1111，B = +24 = +001 1000; 得 \[ A \]补 = 0000 1111，\[ B \]补 = 0001 1000**

**求得 \[ - B \]补 = 1110 1000**

**所以： \[ A + B \]补 = 0010 0111 ，符号位为 0，对应真值为 +39。**

 **\[ A - B \]补 = 1111 0111 ，符号位为 1，对应真值为 - 9。**

* * *

**04、设 x = - 0.1101，y = 0.1011，采用原码一位乘法求 x·y 。**

![](https://img-blog.csdnimg.cn/0958be97c03f4593834bdf638466672a.png)

* * *

**05**、**设 x = - 0.1101， y = 0.1011 ，采 用 Booth 算 法 求 x · y** 。

![](https://img-blog.csdnimg.cn/b48aa53a7e4b484aac34290c7c1b8e7a.png)

* * *

**06**、**设 x = 0.1011，y = 0.1101，采 用 原 码 加 减 交 替 除 法 求 x/y** 。

![](https://img-blog.csdnimg.cn/6a1fb71ff2a14571b7e9280573974b63.png)

* * *

**07**、**设 x = 0.1000，y =- 0.1011，采 用 补 码 加 减 交 替 除 法 求 x/y** 。

![](https://img-blog.csdnimg.cn/a42fc665621d481cb7cbc957c8b9f0a3.png)

* * *

**08**、一 个 C 语 言 程 序 在 一 台 **32 位** 机 器 上 运 行 。程 序 中 定 义 了 三 个 变 量 x 、y 、z ， 其 中 **x 和 z 为 int 型** ，**y 为 short 型** 。当 x = 127 、y = - 9 时 ，执 行 赋 值 语 句 z = x + y 后 ，x 、 y 、z 的 值 分 别 是 【**0000 007FH、FFF7H、0000 0076H**】。

**解 析**：C 语 言 的 数 据 在 内 存 中 为 补 码 形 式 ， 因 此 x 、y 的 机 器 数 写 为 0000 007F 、 FFF7H 。 执 行 z = x + y 时 ， 由 于 x 为 int 型 ， y 为 short 型 ， 因 此 需 将 y 的 类 型 强 制 转 换 为 int 型 ， 在 机 器 中 通 过 符 号 位 扩 展 实 现 ， 由 于 y 的 符 号 位 为 1 ， 因 此 在 y 的 前 面 添 加 16 个 1 ， 即 可 将 y 强 制 转 换 为 int 型 ， 其 十 六 进 制 形 式 为 FFFF FFF7H 。然 后 执 行 加 法 ， 即 0000 007FH + FFFF FFF7H = 0000 0076H ， 其 中 最 高 位 的 进 位 1 自 然 丢 弃 。

* * *

**09**、假 定 有 4 个 整 数 用 **8 位 补 码** 表 示 ，r1 = FEH 、r2 = F2H 、r3 = 90H 、r4 = F8H ， 若 将 运 算 结 果 存 放 在 一 个 **8 位 寄 存 器** 中 ， 则 下 列 运 算 **会 发 生 溢 出** 的 是 【B】 。  
A. r1 × r2    **B. r2 × r3**    C. r1 × r4    D. r2 × r4

**解 析**：本 题 的 真 正 意 图 是 **考 查 补 码 的 表 示 范 围** ， 采 用 补 码 乘 法 规 则 计 算 出 4 个 选 项 是 费 力 不 讨 好 的 做 法 ，且 极 易 出 错 。8 位 补 码 所 能 表 示 的 整 数 范 围 为 - 128 ~ +127 。 将 4 个 数 全 部 转 换 为 十 进 制 数 ：r1 = -2 、r2 = -14 、r3 = -112 、r4 = -8，**r2 × r3** 远 超 出 了 表 示 范 围 ， 发 生 溢 出 。

* * *

**10**、某 字 长 为 8 位 的 计 算 机 中 ， 已 知 整 型 变 量 x、y 的 机 器 数 分 别 为 \[x\]补 = 1 111 0100 ，\[y\]补\= 1 0110000 。 若 整 型 变 量 z =2x + y / 2 ， 则 z 的 机 器 数 为 【**1 1000000**】 。

**解 析**：x \* 2 ，将 x 算 术 左 移 一 位 为 1 1101000 ；y/2，将 y 算 术 右 移 一 位 为 11011000， 均 无 溢 出 或 丢 失 精 度 。 补 码 相 加 为 1 1101000 + 1 1011000 = 1 1000000 ， 亦 无 溢 出 。

![](https://img-blog.csdnimg.cn/f794beff0aa8490784d570c40b9af622.png)

* * *

**11**、某 32 位 计 算 机 按 字 节 编 址 ， **采 用 小 端 方 式** 。 若 语 句 "int i = 0；” 对 应 指 令 的 机 器 代 码 为 "C7 45 FC 00 00 00 00 ” ， 则 语 句 "int i = - 64；” 对 应 指 令 的 机 器 代 码 是\_\_\_。

**解 析**：按 字 节 编 址 ， **采 用 小 端 方 式 ， 低 位 的 数 据 存 储 在 低 地 址 位 、 高 位 的 数 据 存 储 在 高 地 址 位** ，并 且 按 照 一 字 节 相 对 不 变 的 顺 序 存 储 。 由 题 意 ， 存 储 0 的 位 数 是 后 32 位 ， 则 我 们 只 需 要 把 - 64 的 补 码 按 字 节 存 储 在 其 中 即 可 ， 而 - 64 表 示 成 32 位 的 十 六 进 制 是 FFFFFF C0 ， 根 据 小 端 方 式 特 点 ， 低 字 节 存 储 在 低 地 址 ， 就 是 C0 FF FF FF 。

* * *

**12**、考 虑 以 下 C 语 言 代 码 ：unsigned short usi = 65535 ；short si = usi ; 执 行 上 述 程 序 段 后 ， si 的 值 是 【**\-1**】 。

**解 析**：unsigned short 类 型 为 无 符 号 短 整 型 ， 长 度 为 2 字 节 ， 因 此 unsigned short usi 转 换 为 二 进 制 代 码 即 1111 1111 1111 1111 。 short 类 型 为 短 整 型 ， 长 度 为 2 字 节 ， 在 采 用 补 码 的 机 器 上 ， short si 的 二 进 制 代 码 为 1111 1111 1111 1111， 因 此 si 的 值 为 1000 0000 0000 0001 = -1 。（ 仅 解 释 方 式 不 同 ）

* * *

**13**、在 按 字 节 编 址 ，采 用 **小 端 方 式 的 32 位** 计 算 机 中 ，按 **边 界 对 齐 方 式** 为 以 下 C 语 言 结 构 型 变 量 a 分 配 存 储 空 间 。

    struct record{
    short x1; int x2;
    }a;


若 **a 的 首 地 址 为 2020 FE00H** ， a 的 成 员 变 量 x2 的 机 器 数 为 1234 0000H ， 则 其 中 34H 所 在 存 储 单 元 的 地 址 是【**2020 FE06H**】。

**解 析**：

![](https://img-blog.csdnimg.cn/2a36f10c416341bc9bbf4ff16566972f.png)

* * *

**14**、有 实 现 x \* y 的 两 个 C 语 言 函 数 如 下 ：  
**unsigned umul (unsigned x，unsigned y) { return x \* y ; }**  
**int imul (int x ， int y) { return x \* y ; }**  
假 定 某 计 算 机 M 中 的 ALU 只 能 进 行 加 减 运 算 和 逻 辑 运 算 。请 回 答 下 列 问 题 。

**1 ）** 若 M 的 指 令 系 统 中 没 有 乘 法 指 令 ， 但 有 加 法 、 减 法 和 位 移 等 指 令 ， 则 在 M 上 也 能 实 现 上 述 两 个 函 数 中 的 乘 法 运 算 ， 为 什 么 ？  
**2 ）** 若 M 的 指 令 系 统 中 有 乘 法 指 令 ， 则 基 于 ALU 、 位 移 器 、 寄 存 器 及 相 应 控 制 逻 辑 实 现 乘 法 指 令 时 ， 控 制 逻 辑 的 作 用 是 什 么 ？  
**3 ）** 针 对 以 下 三 种 情 况 ： a ） 没 有 乘 法 指 令 ； b ） 有 使 用 ALU 和 位 移 器 实 现 的 乘 法 指 令 ； c ） 有 使 用 阵 列 乘 法 器 实 现 的 乘 法 指 令 ， 函 数 umul() 在 哪 种 情 况 下 执 行 的 时 间 最 长 ？ 在 哪 种 情 况 下 执 行 的 时 间 最 短 ？ 说 明 理 由 。  
**4 ）** n 位 整 数 乘 法 指 令 可 保 存 2n 位 乘 积 ， 当 仅 取 低 n 位 作 为 乘 积 时 ， 其 结 果 可 能 会 发 生 溢 出 。 当 n = 32 ， x = 231 - 1 、 y = 2 时 ， 带 符 号 整 数 乘 法 指 令 和 无 符 号 整 数 乘 法 指 令 得 到 的 x \* y 的 2n 位 乘 积 分 别 是 什 么（ 用 十 六 进 制 表 示 ）？ 此 时 函 数 umul() 和 imul() 的 返 回 结 果 是 否 溢 出 ？ 对 于 无 符 号 整 数 乘 法 运 算 ，当 仅 取 乘 积 的 低 n 位 作 为 乘 法 结 果 时 ， 如 何 用 2n 位 乘 积 进 行 溢 出 判 断 ？

**解 析**：**1 )** 乘 法 运 算 可 通 过 加 法 和 移 位 来 实 现 。编 译 器 可 以 将 乘 法 运 算 转 换 为 一 个 循 环 代 码 段 ，在 循 环 代 码 段 中 通 过 比 较 、加 法 和 移 位 等 指 令 实 现 乘 法 运 算 。  
**2** ） 控 制 逻 辑 的 作 用 是 控 制 循 环 次 数 ， 控 制 加 法 和 移 位 操 作 。  
**3** ） a) 最 长 ， c) 最 短 。 对 于 a) ， 需 要 用 循 环 代 码 段 （ 即 软 件 ） 实 现 乘 法 操 作 ， 因 而 需 要 反 复 执 行 很 多 条 指 令 ， 而 每 条 指 令 都 需 要 取 指 令 、 译 码 、 取 数 、 执 行 并 保 存 结 果 ， 所 以 执 行 时 间 很 长 ； 对 于 b) 和 c) ， 都 只 需 用 一 条 乘 法 指 令 实 现 乘 法 操 作 ， 不 过 b) 中 的 乘 法 指 令 需 要 多 个 时 钟 周 期 才 能 完 成 ， 而 c) 中 的 乘 法 指 令 可 在 一 个 时 钟 周 期 内 完 成 ， 所 以 c) 的 执 行 时 间 最 短 。  
**4** ） 当 n = 32 、 x = 231 - 1 、 y = 2 时 ，带 符 号 整 数 和 无 符 号 整 数 乘 法 指 令 得 到 的 64 位 乘 积 都 是 0000 0000 FFFF FFFEH 。int 型 的 表 示 范 围 为 \[ -231 ，231 -1 \] ，故 函 数 imul() 的 结 果 溢 出 ；unsigned int 型 表 示 范 围 为 \[ 0 ，232 - 1 \] ，故 函 数 umul() 的 结 果 不 溢 出 。 对 于 无 符 号 整 数 乘 法 ，若 乘 积 高 n 位 全 为 0 ， 即 使 低 n 位 全 为 1 也 正 好 是 232 - 1 ， 不 溢 出 ， 否 则 溢 出 。

* * *

### 2.3、[浮点数的表示与运算](https://zhuanlan.zhihu.com/p/47396662)

**01**、**长 度 相 同 、格 式 相 同** 的 两 种 浮 点 数 ， 假 设 **前 者 基 数 大 ，后 者 基 数 小 ， 其 他 规 定 均 相 同** ， 则 它 们 可 表 示 的 数 的 范 围 和 精 度 为 【**前 者 可 表 示 的 数 的 范 围 大 且 精 度 低**】。

**解 析**：**基 数 越 大 ，范 围 越 大 ，但 精 度 变 低（ 数 变 稀 疏 ）**。在 浮 点 数 总 位 数 不 变 的 情 况 下 ，阶 码 位 数 越 多 ，尾 数 位 数 越 少 ；即 表 示 的 数 的 范 围 越 大 ，精 度 越 差（ 数 变 稀 疏 ）。

* * *

**02** ， 在 规 格 化 浮 点 运 算 中 ，若 某 浮 点 数 为 25 × 1.10101，其 中 **尾 数 为 补 码 表 示** ， 则 该 数【**需 将 尾 数 左 移 一 位 规 格 化**】。

**解 析**：考 查 浮 点 数 的 规 格 化 。 当 **尾 数 为 补 码 表 示 ， 且 为 1.0×××× 形 式 时 为 规 格 化 数 ， 因 此 该 尾 数 需 左 移 一 位 ， 阶 码 同 时 应 减 1** ， 才 为 规 格 化 数 。

* * *

**03**、某 浮 点 机 ， 采 用 规 格 化 浮 点 数 表 示 ， **阶 码 用 移 码 表 示** （ 最 高 位 代 表 符 号 位 ） ， **尾 数 用 原 码 表 示** 。下 列 【B】 的 表 示 不 是 规 格 化 浮 点 数 。  
A. 11111111，1.1000······00       **B. 0011111 ，1.0111······01**  
C. 1000001 ， 0.1111······01        D. 0111111 ， 0.1000········10

**解 析**：**原 码 表 示 时 ， 正 数 的 规 格 化 形 式 为 0.1×××× ， 负 数 的 规 格 化 形 式 为 1.1××××** ， 因 此 B 错 误 。

* * *

**04**、若 浮 点 数 的 **尾 数 用 补 码** 表 示 ， 则 下 列 【D】中 的 尾 数 是 规 格 化 数 形 式 。  
A. 1.11000   B. 0.01110   C. 0.01010   **D. 1.00010**

**解 析**：补 码 的 规 格 化 表 示 是 小 数 点 后 一 位 与 符 号 位 不 同 。

* * *

**IEEE 754 标 准 中 尾 数 采 用 原 码 表 示 ， 阶 码 部 分 用 移 码 表 示** 。

* * *

**05**、设 浮 点 数 的 基 数 为 4 ， 尾 数 用 原 码 表 示 ， 则 以 下【C】 是 规 格 化 的 数 。  
A. 1.001101   B. 0.001101   **C. 1.011011**   D. 0.000010

**解 析**：**原 码 表 示 的 规 格 化 小 数 是 小 数 点 后 2 位 （ 基 数 为 4 ， 用 2 位 表 示 ） 不 全 为 0 的 小 数** 。

* * *

**06**、设 浮 点 数 共 12 位。其 中 阶 码 含 1 位 阶 符 共 4 位，以 2 为 底，补 码 表 示；尾 数 含 1 位 数 符 共 8 位， 补 码 表 示， 规 格 化。 则 该 浮 点 数 所 能 表 示 的 最 大 正 数 是【**27 - 1**】。

**解 析**：为 使 浮 点 数 取 正 数 最 大 ，可 使 尾 数 取 正 数 最 大 ，阶 码 取 正 数 最 大 。尾 数 为 8 位 补 码 （ 含 符 号 位 ），正 值 最 大 为 0.1111111 ， 即 1 - 2\-7 ， 阶 码 为 4 位 补 码 （ 含 符 号 位 ） ， 正 值 最 大 为 0111 ， 即 7 ， 则 最 大 正 数 为 （1 - 2\-7）× 27 = 27 - 1 。

* * *

**舍 入 是 浮 点 数 的 概 念 ， 定 点 数 没 有 舍 入 的 概 念** 。 浮 点 数 舍 入 的 情 况 有 两 种 ： **对 阶 、 右 规 格 化** 。 舍 入 不 一 定 产 生 误 差 ， 如 向 下 舍 入 1.00 到 1.0 时 是 没 有 误 差 的 。

* * *

**07**、浮 点 数 加 、减 运 算 过 程 一 船 包 括 **对 阶 、尾 数 运 算 、规 格 化 、舍 入 和 判 断 溢 出** 等 步 驟 。 设 **浮 点 数 的 阶 码 和 尾 数 均 采 用 补 码 表 示** ， 且 位 数 分 别 为 5 和 7（ 均 含 2  
位 符 号 位 ）。 若 有 两 个 数 X = 27 × 29 /32 和 Y= 25 × 5 / 8 ， 则 用 浮 点 加 法 计 算 X + Y 的 最 终 结 果 是 【**发 生 溢 出**】。

**解 析**：**小 数 点 左 移（右 规、右 移） ，阶 码 增 加 ；小 数 点 右 移（左 规） ， 阶 码 减 小** 。

         5 / 32 —>101. × 2\-5 = .00101

![](https://img-blog.csdnimg.cn/dacba87a1c3a443a96fdd6a83f24ad3d.png)

* * *

**char —> int —> long —> double 和 float —> double ，转 换 过 程 没 有 损 失** 。

![](https://img-blog.csdnimg.cn/9e81e7245b2c4669afe6ca9a9fe5953c.png)

* * *

**08**、**float 型 数 据 通 常 用 IEEE 754 单 精 度 格 式 表 示** 。 若 编 译 器 将 float 型 变 量 x 分 配 在 一 个 **32 位 浮 点 寄 存 器 FR1 中** ， 且 x = -8.25 ， 则 FR1 的 内 容 是【**C184 0000H**】。

**解 析**：先 将 x 转 换 成 二 进 制 为 -1000.01 = - 1.000 01 × 23 ， 其 次 计 算 阶 码 E ，根 据 IEEE 754 单 精 度 浮 点 数 格 式 ， 有 E - 127 = 3 ， 因 此 E = 130 ， 转 换 成 二 进 制 为 1000 0010 。 最 后 ， **根 据 IEEE 754 标 准 ， 最 高 位 的 “ 1 ” 是 被 隐 藏 的** 。  
**IEEE 754 单 精 度 浮 点 数 格 式 ： 数 符 （ 1 位 ） + 阶 码 （ 8 位 ） + 尾 数 （ 23 位 ）** 。  
因 此 FR1 的 内 容 为 1 ； 1000 0010 ； 0000 1000 0000 0000 0000 000 。  
即 1100 0001 0000 0100 0000 0000 0000 0000 = C104 0000H 。

* * *

**09**、float 型（即 IEEE754 单 精 度 浮 点 数 格 式）能 表 示 的 最 大 正 整 数 是【**2128 - 2104**】。

**解 析**：表 示 最 大 正 整 数 时 ： 数 符 取 0 ；阶 码 取 最 大 值 为 127（FEH） ；尾 数 部 分 隐 藏 了 整 数 部 分 的 “1”，23 位 尾 数 全 取 1 时 尾 数 最 大 ，为 1 + 1 - 2\-23 ，此 时 浮 点 数 的 大 小 为（2 -223) × 2127 。（ **阶 码 全 0 表 示 非 规 格 化 ，全 1 表 示 无 穷 大** ）规 格 化 短 浮 点 数 的 真 值 为 （-1）S × 1.m × 2E-127 。**此 题 最 小 正 整 数 为：S = m = 0，E = 1 , 为 2\-126** 。

* * *

3、[存储系统](https://blog.csdn.net/qq_44709990/article/details/108060193)
---------------------------------------------------------------------

### 3.1、存储器概述

**01、存取时间 Ta 是指从存储器读出或写入一次信息所需要的平均时间；**

 **存取周期 Tc 是指连续两次访问存储器之间所必需的最短时间间隔。**

 **对 Tc 一般有 Tc = Ta +Tr；其中 Tr 为复原时间；对 SRAM 指存取信息的稳定时间，对 DRAM 指刷新的又一次存取时间。**

* * *

**02、磁盘属于直接存取存储器，其速度介于随机存取存储器和顺序存取存储器之间。**

**非易失性存储器：【ROM】、【MROM】、【PROM】、【EPROM】、【Flash存储器】、【SSD】、【E2PROM（写速慢于读速）】。**

**易失性存储器：【SRAM（用于Cache）】、【DRAM（用于大容量主存系统）】**

**随机存取存储器：【SRAM】、【DRAM】。**

**只读存储器：【MROM】、【PROM】、【EPROM】、【闪存】。**

**U 盘属于【只读存储器】。** **CD-ROM 即光盘，采用串行存取方式。**

* * *

**03、在 Cache 和主存构成的两级存储体系中，主存与 Cache 同时访问，Cache 的存取时间是100ns，主存的存取时间是 1000ns，设 Cache 和主存同时访问，若希望有效（平均）存取时间不超过Cache 存取时间的 115％，则 Cache 的命中至少应为【99%】。**

**解析：假设命中率为 x，可得 100 x + 1000( 1 - x ) ≤ \\leq ≤ 100 ×（1+15％），简单计算后可得结果为 98.33％，因此命中率至少为 99％。**  
**注意：本题采用同时访问 Cache 和主存的方式，此时不命中的访问时间为 1000nS，但若题设中没有说明（通常会说明〕，则默认 Cache 不命中的时间为访问Cache和主存的时间之和。**

* * *

**04、主存和辅存之间的数据调动是由硬件和操作系统共同完成的，仅对应用级程序员透明。**

* * *

**05、CPU 执行一段程序时，Cache 完成存取的次数为 1900，主存完成存取的次数为 100，已知 Cache 存取周期为 50ns，主存存取周期为 250ns。设主存与 Cache 同时访问。**

**1）Cache/主存系统的效率是多少； 2）平均访问时间是多少。**

**解析：1）命中率 H = Nc ／（ Nc + Nm ）= 1900 / （1900 + 100）= 0.95。主存访问时间与Cache 访问时间的倍率 r = Tm / Tc = 250ns / 50ns = 5；Cache 主存系统的效率 e = 访问 Cache 的时间 / 平均访存时间。**  
**访问效率 e = 1 / \[ H + (1 - H) r \] = 1 / \[ 0.95 + ( 1 - 0.95 )×5 \] = 83.3％。**  
**2）平均访问时间 Ta = Tc / e = 50ns / 0.833 = 60ns。**

* * *

### 3.2、主存储器

* * *

**01、DRAM 刷新对 CPU 是【透明】的，即刷新不依赖于外部的访问；动态 RAM 的刷新单位是行，由芯片内部自行生成行地址；刷新操作类似与读操作。刷新方式：【集中刷新】、【分散刷新==（不存在死区）==】、【异步刷新】。**

* * *

**02、存储器芯片由【存储体】、【I/O 读写电路】、【地址译码器】和【控制电路】等部分组成。**

* * *

**03、数据线的宽度与 【MDR】 的宽度相同，地址线的宽度与 【MAR】的宽度相同。但要注意低位交叉编址时，存储器总线宽度有时不一定和所用芯片的MDR一致。**

* * *

**04、设存储器容量为 32 个字，字长为 64 位，模块数 m = 4，分别采用顺序方式和交叉方式进行组织。存储周期 T = 200ns，数据总线宽度为 64 位，总线传输周期 r = 50ns。在连续读出 4 个字的情况下，求顺序存储器和交叉存储器各自的带宽。**  
**解：顺序存储器和交叉存储器连续读出 m = 4 个字的信息总量均是： q = 64位 × 4 = 256位**  
**顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是：**

 **t1 = mT \= 4 × 200ns = 800ns = 8 × 10\-7 s**  
 **t2 = T + （ m - 1 ） r \= 200ns + 3 × 50ns = 350ns = 35 × 10\-8 s**  
 **顺序存储器和交叉存储器的带宽分别是：**

 **W1 = q / t1 = 256 / t1 = 32 × 107 b/s**

 **W2 = q / t2 = 256 / t2 = 73 × 107 b/s**

* * *

**05、某一 SRAM 芯片，其容量为 1024 × 8 位，除电源和接地端外，该芯片引脚数目最小为【21】。**

**解析：芯片容量为 1024 × 8 位，且以字节为单位存取，即地址线数要 10 根，8 位说明数据线要 8 根，加上 片选线 和 读 / 写控制线（读控制为 RD、写控制为 WE），因此引脚数最小为 21 根。**  
**注意：读写控制线也可共用一根，做题时应随机应变。**

* * *

**06、某一 DRAM 芯片，采用地址复用技术，其容量为 1024 × 8 位，除电源和接地端外，该芯片引脚数最少是【17】（读写控制线为两根）。**

**解析：1024×8位，因此可寻址范围是 1024B = 210B，按字节寻址。采用地址复用技术时，通过行通选和列通选分行、列两次传送地址信号，因此地址线减半为 5 根，数据线仍为 8 根；加上行通选和列通选 及 读 / 写控制线（片选线用行通选代替）4 根，总共是 17 根。**  
**注意 SRAM 和 DRAM 的区别，DRAM 采用地址复用技术，而 SRAM 不采用。**

* * *

**07、某计算机系统，其操作系统保存于硬盘上，其内存储器应该采用【C】。**  
**A. RAM B. ROM C. RAM 和 ROM D. 均不完善**  
**解析：因计算机的操作系统保存于硬盘上，所以需要 BIOS 的引导程序将操作系统引导到主存（RAM）中，而引导程序则固化于ROM中。**

ROM 存放系统程序、标准子程序和各类常数；RAM 则是为用户编程而设置。

* * *

**08、下列说法正确的是【B】。**  
**A. EPROM是可改写的，因此可以作为随机存储器**  
**B. EPROM是可改写的，但不能作为随机存储器**  
**C. EPROM是不可改写的，因此不能作为随机存储器**  
**D. EPROM只能改写一次，因此不能作为随机存储器**

**解析：EPROM 可多次改写，但改写较为烦琐，写入时间过长，且改写的次数有限，速度较慢，因此不能作为需要频繁读写的 RAM 使用。**

* * *

**09、已知单个存储体的存储周期为 110ns，总线传输周期为 10ns，采用低位交叉编址的多模块存储器时，存储体数应【 ≥ \\geq ≥ 11】。**

**解析：为保证第二次启动某个体时，其上次存取操作已完成，存储体的数量应大于等于 11**  
**(110ns / 10ns )。**

**来源知识点：设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为r，为实现流水线方式存取，存储器交叉模块数应大于等于 m = T / r。**

* * *

**10、一个四体并行低位交叉存储器，每个模块的容量是 64K × 32 位，存取周期为 200ns，总线周期为 50ns，在下述说法中，【B】是正确的。**  
A. 在 200ns 内，存储器能向 CPU 提供 256 位二进制信息  
**B. 在 200ns 内，存储器能向 CPU 提供 128 位二进制信息**  
C. 在 50ns 内，每个模块能向 CPU 提供 32 位二进制信息（局部就不一定了）

**解析：低位交叉存储器采用流水线技术，它可在一个存取周期内连续访问 4 个模块，32位×4=**  
**128位。**  
**注：本题若作为计算题来考虑，从第一个字的读写请求发出，到第 4 个字读写结束，共需要 350ns，但这里考查的是整体工作性能，可从以下角度理解：**  
**1）连续取 m 个字耗时 t1 = T + (m-1) r，平均每个字的存取时间是 t1 / m，实际工作时 m 非常大，因此 t1 / m 也就非常接近 r ，可认为存储器在每个总线周期 r 都能给 CPU 提供一个字。**  
**2）流水线充分流动起来后，每个总线周期后都能完成一个字的读写，所以本题中每 4 个总线周期（200ns）都能完成 4 个字的读写。**

* * *

**11**、某机器采用四体低位交叉存储器，现分别执行下述操作：（1）读取 6 个连续地址单元中存放的存储字，重复 80 次；（2）读取 8 个连续地址单元中存放的存储字，重复 60 次。则（1）、（2）所花的时间之比为【4:3】。

**解析**： **假设取指周期为 T，执行周期为 t，总线传输时间为 τ \\tau τ 。**

 **第一种情况，T1 = ( T + ( 6 - 1 ) × τ \\tau τ + 6t )× 80 = 80T + 400 τ \\tau τ + 480t。**

 **第二种情况，T2 = ( T + ( 8 - 1 ) × τ \\tau τ + 8t) × 60 = 60T + 420 τ \\tau τ + 480t。**

 二者之比大约为：4:3

**书本中：连续存取 m 个字所需的时间为 t1 = T + ( m - 1 )×r。**

**（ T：存储周期； r：总线传输周期）**

**对于1**：在每轮读取存储器的前 6 个 T/4 时间（共3T/2）内，依次进入各体。下一轮欲读取存储器时，最近访问的M1还在占用中（才过 T/2 时间），因此必须再等待 T/2 的时间才能开始新的读取（M1连续完成两次读取，也即总共 2T 的时间即可进入下一轮。进入下一轮不需要第 6 个字读取结束，第 5 个字读取结束，M1 就已空出，即可马上进入下一轮）。最后一轮读取结束的时间是本轮第 6 个字读取结束，共（6 - 1）x (T / 4) + T = 2.25T。  
  情况 1 的总时间为（80 - 1 ）x 2T + 2.25T = 160.25T;  
**对于2**：（60-1）x 2T + ( 8 - 1 ) x T/4 +T = 120.75T。

* * *

**12、假定用若干 16K×8 位的存储芯片组成一个 64K×8 位的存储器，芯片各单元采用交叉编址方式，则地址 BFFFH 所在的芯片的最小地址为【0003H】。**

**解析：64K×8 位 /16K×8位 = 4，可知芯片数为 4。芯片各单元采用交叉编址，所以每个芯片的片选信号由最低两位地址确定，高 14 位为片内地址。4 个芯片内各存储单元的最低两位地址分别为00、01、10、11。即最小地址分别为 0000H、0001H、0002H、0003H。地址 BFFFH 最低两位为11,因此该存储单元所在芯片的最小地址为 0003H。**

* * *

**13、某计算机使用四体交叉编址存储器，假定在存储器总线上出现的主存地址（十进制）序列为8005，8006，8007，8008，8001，8002，8003，8004，8000，则可能发生访存冲突的地址对是【8004 和 8000】。**  
解析：每个访存地址对应的存储模块序号（0，1，2，3）如下所示：

访存地址

8005

8006

8007

8008

8001

8002

8003

8004

8000

**模块序号**

**1**

**2**

**3**

**0**

**1**

**2**

**3**

**0**

**0**

**其中，模块序号 = 访存地址 ％ 存储器交叉模块数。**  
**判断可能发生访存冲突的规则如下：给定的访存地址在相邻的四次访问中出现在同一个存储模块内。 据此，根据上表可知 8004 和 8000 对应的模块号都为 0，即表明这两次的访问出现在同一模块内且在相邻的访问请求中，满足发生冲突的条件。**

* * *

**14、某计算机主存按字节编址，由 4 个 64M x 8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为804 001AH，则读取 x 需要的存储周期数是【3】。**

**解析：由 4 个 DRAM 芯片采用交叉编址方式构成主存可知主存地址最低二位表示该字节存储的芯片编号。double 型变量占 64 位，8 个字节，即需 8 个存储单元。它的主存地址 0804 001A H最低二位是10，说明它从编号为 2 的芯片开始存储（编号从0开始）。一个存储周期可以对所有芯片各读取一个字节，因此需要3轮。**

* * *

**15**、某计算机字长 32 位，存储体的存储周期为 200ns。  
1）采用四体交叉工作，用低 2 位的地址作为体地址，存储数据按地址顺序存放。主机最快多长时间可以读出一个数据字（代表要处理的数据二进制位数）？存储器的带宽是多少？  
2）若 4 个体分别保存主存中 前1／4、次1／4、再下个 1/4、最后 1/4这四段的数据，即选用高 2 位的地址作为体地址，可以提高存储器顺序读出数据的速度吗？为什么？  
3）若把存储器改成单体 4 字宽度，会带来什么好处和问题？  
4）比较采用四体低位地址交叉的存储器和四端口读出的存储器这两种方案的优缺点。

**解**：1）因为存取周期是 200ns。四体交叉轮流工作，每两个体间读出操作的延时为 1/4 个存储周期，理想情况是每个存取周期平均可读出 4 个数据字，读出一个数据字的时间平均为 200ns / 4 = 50ns。数据字长为 32 位，数据传输率为 32位 / 50ns = 640Mb/s = 80MB/s（结合第10加深理解）。

2）若对多体结构的存储器选用高位地址交叉，通常起不到提高存储器读写速度的作用，因为它不符合程序运行的局部性原理，一次连续读出彼此地址相差一个存储体容量的 4 个字的机会太少。因此，通常只有一个存储模块在不停地忙碌，其他存储模块是空闲的。

3）若把存储器的字长扩大为原来的 4 倍，实现的则是一个单体 4 字结构的存储器，每次读可以同时读出 4 个字的内容，有利于提高存储器每个字的平均读写速度，但其灵活性不如多体单字结构的存储器，还会多用到几个缓冲寄存器。

4）多端口存储器是对同一个存储体使用多套读写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则允许在同一个存储周期对几个存储体执行写入操作。

* * *

### 3.3、连接主存与 CPU

**01、** 基本知识点：

主存储器通过【数据总线】、【地址总线】和【控制总线】与 CPU 连接。

主存容量的扩展方法：【位扩展（增加存储字长）】、【字扩展（增加字的数量）】、【字位同时扩展】。

位扩展注意：仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某  
一时刻选中所有的芯片，所以片选信号要连接到所有芯片。

字扩展注意：仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在  
某一时刻只选中部分芯片，所以通过片选信号或采用译码器设计连接到相应的芯片。

字位同时扩展注意：采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号或采用译码器设计连接到相应的芯片。

片选信号的产生分为【线选法（某地址线信息为“0”时，就选中与之对应的存储芯片）】和【译码片选法（高位地址线通过地址译码器芯片产生片选信号）】。

片选有效信号与 CPU 的访存控制信号 M R E Q ‾ \\overline{MREQ} MREQ（低电平有效）有关，若 CPU 访问 I/O，则 M R E Q ‾ \\overline{MREQ} MREQ 为高，表示不要求存储器工作。

* * *

**02、** 80386DX 是 32 位系统，以 4B 为编址单位，当在该系统中用 8KB（8K×8位）的存储芯片构造 32KB 的存储体时，应完成存储器的【位扩展】设计。

**解析：因为以 4B 为编址单位，要扩展到 32KB，即扩展到 8Kx32bit，所以只用进行位扩展。**

* * *

**03、地址总线A0（高位）~ A15（低位），用 4K x 4 位的存储芯片组成 16KB 存储器，则产生片选信号的译码器的输入地址线应该是【A2 A3】。**

**解析：由于 A15 为地址线的低位，接入各芯片地址端的是地址线的低 12 位，即 A4 ~ A15，共有8 个芯片（16KB / 2KB = 8，且位扩展时每组两片分为 4 组）组成 16KB 的存储器，则由高两位地址线A2 A3 作为译码器的输入。**

* * *

**04、若片选地址为 111 时，选定某一 32K × 16位的存储芯片工作，则该芯片在存储器中的首地址为【38000H】，末地址为【3FFFFH】。**

**解析：32K × 16 的存储芯片有地址线 15 根（片内地址），片选地址为 3 位，因此地址总位数为18位，现高 3 位为 111，则首地址为 11 1000 0000 0000 0000 = 380000H，末地址为 11 1111 1111 1111 1111 = 3FFFFH。**

* * *

**05、假定用若干 2K×4 位的芯片组成一个 8K×8 位的存储器，则地址 0B1FH 所在芯片的最小地址是【0800H】。**

**解析：用 2Kx4 位的芯片组成一个 8K×8 位存储器，每行中所需芯片数为 2，每列中所需芯片数为 4，各行芯片的地址分配如下：**  
**第一行（2个芯片并联）：0000H~07FFH**  
**第二行（2个芯片并联）：0800H~0FFFH**  
**第三行（2个芯片并联）：1000H~17FFH**  
**第四行（2个芯片并联）：1800H~1FFFH**  
**可知，地址 0B1FH 在第二行，且所在芯片的最小地址为 0800H。**

* * *

**06、** 某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4M×8 位的 RAM 芯片组成32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是【26】。

解析：主存按字节编址，地址空间大小为 64MB，MAR 的寻址范围为 64M = 226，因此是26位。  
实际的主存容量 32MB 不能代表 MAR 的位数，考虑到存储器扩展的需要，MAR应保证能访问到整个主存地址空间；反过来，MAR 的位数决定了主存地址空间的大小。

* * *

**07、假定 DRAM 芯片中存储阵列的行数为 r、列数为 c，对于一个 2K×1 位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 r、c 的取值分别是【32】，【64】。**

**解析：根据 DRAM 的结构和原理可知，在分时复用的情况下，芯片引脚个数取决于行地址线和列地址线中的较大值，对于一个 2K×1 位的 DRAM 芯片，总共需要 11 条地址线，只有当一个取 5，一个取 6 时可使管脚数最小，而 DRAM 的刷新开销取决于行数，因此行地址线应该为 5、列地址线为6，即行数 25 = 32，列数为26 = 64。**

* * *

**08、** 某计算机的存储器总线中有 24 位地址线和 32 位数据线，按字编址，字长为 32 位。如果 0 0 0000H ~ 3F FFFFH 为 RAM 区。那么需要 512K×8 位的 RAM 芯片数为【32】。

解析：00 0000～3F FFFF，**共有 3F FFFFH - 00 0000H + 1H = 40 0000H = 222 个地址**，按字编址，字长为 32 位（4B），因此 RAM 区大小为 222 × 4B =2 22 × 32bit。每个 RAM 芯片的容量为  
512K×8bit = 219 × 8bit，所以需要 RAM 芯片的数量为【32】。

* * *

**09、有一组 16K×16 位的存储器，由 1K×4 位的 DRAM 芯片构成。问：**  
**1）共需要多少芯片？**  
**2）采用异步刷新方式，如单元刷新间隔不超过 2ms，则刷新信号周期是多少？**

**解：1）存储器总容量为 16K×16位，RAM芯片为 1K×4 位，因此所需芯片总数为（16K×16**  
**位）/ （1K×4位）= 64片。**  
**2）采用异步刷新方式，在 2ms 时间内分散地把芯片 64 行刷新一遍，因此刷新信号的时间间隔为 2ms / 64 = 31.25us，即可取刷新信号周期为 31us。**  
**注意：刷新周期也可取 30us，只要小于 31.25us 即可，但通常取刷新间隔的整数部分。**

* * *

**10**、某机的主存空间为 64KB，I/O 空间与主存单元统一编址，I/O 空间占用 1KB，范围为FC00H~FFFFH。可选用 8K×8 位和 1K×8 位两种 [SRAM](https://so.csdn.net/so/search?q=SRAM&spm=1001.2101.3001.7020) 芯片构成主存储器， R D ‾ \\overline{RD} RD和 W R ‾ \\overline{WR} WR 分别为系统提供的读写信号线。求每块芯片的地址。

解答：由于 64KB 存储空间中，I/O 占用了最高的 1KB空间（FC00H~FFFFH），RAM 芯片应当分  
配余下的低 63KB 空间。选用 7片 8K×8 位芯片和 7片 1K×8 位芯片，共计63KB。  
8K×8 RAM 芯片共有 8K 个 8位 的存储单元，片内地址应有 log2(8K) = 13 根，分别连接地址线A12 ~ A0，每片的地址范围为 0000H～1FFFH。  
64KB 的存储器应有 64K 个存储单元，地址线应有 log2（64K）= 16根。地址范围为 0000H～  
FFFFH。

地址线 A12～A0 并行连接到 7 片 8K×8 位 RAM 芯片的 13 个地址端，用 3 根高地址线 A15、A14、A13 经 3/8 译码器译码，译码器的 7 个输出端（000～110）分别接到 7 片 8K×8 位芯片的片选端，用以选择 7片 8K×8 位芯片中的 1 片。剩下 1 个输出端 111 用以控制另一个3/8译码器。  
1K×8 的存储器共有 1K 个存储单元，地址线应有 log2(1K)=10 根。地址范围为 000H～3FFH，地址线A9 ~ A0，共 10 根，并行连接到 7片 1K×8 位 RAM 芯片的 10 个地址端。3 根地址线 A12、A11、A10 经 3/8 译码器译码，译码器的 7 个输出端（000～110）分别接到7片 1K×8 位芯片的片选端，用以选择7片1K×8位芯片中的1片。

![](https://img-blog.csdnimg.cn/fd647da539fc4907afacafa0adf65337.png)

* * *

### 3.4、外部存储器

**01、** 基础知识点：

硬盘存储器由【磁盘驱动器】、【磁盘控制器】和【盘片】组成。

**道密度** 是沿磁盘半径方向单位长度上的磁道数，**位密度** 是磁道单位长度上能记录的二进制代码位数，**面密度** 是位密度和道密度的乘积。

**磁头数**：记录面数； **柱面数**：硬盘每面盘片上**磁道数**。

**平均存取时间** 由 **寻道时间**（磁头移动到目的磁道的时间）、**旋转延迟时间**（磁头定位到要读写扇区的时间）和 **传输时间**（传输数据所花费的时间）三部分构成。

**RAID0**

**无冗余无校验的磁盘阵列（无容错能力）**

**RAID3**

**位交叉奇偶校验的磁盘阵列**

**RAID1**

**镜像磁盘阵列**

**RAID4**

**块交叉奇偶校验的磁盘阵列**

**RAID2**

**采用纠错的海明码的磁盘阵列**

**RAID5**

**无独立校验的奇偶校验磁盘阵列**

**02、固态硬盘 SSD：基于闪存的存储技术，没有机械部件、随机写比较慢、随机读写性能明显高于磁盘、易磨损。**

RAID 将多个物理盘组成像单个逻辑盘，不会影响磁记录密度，也不可能提高磁盘利用率。

* * *

**03、若磁盘转速为 7200 转 / 分，平均寻道时间为 8ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是【12.2ms】。**

解析：存取时间 = 寻道时间 + 延迟时间 + 传输时间。存取一个扇区的平均延迟时间为旋转半周的时间，即 延迟时间 =（ 60 / 7200） / 2 = 4.17ms，传输时间 = （60 / 7200）/ 1000 = 0.01ms，所以访问一个扇区的平均存取时间为： 8 + 4.17 + 0.01 = 12.18ms = 12.2ms。

* * *

**04、某磁盘的转速为 10000 转 / 分，平均寻道时间是 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为【9.4ms】。**

解析：读取 4KB 扇区信息时间 = 4KB / （20MB /s） = 0.2ms；

 平均查询扇区的时间 = （60 / 10000）/ 2 = 3ms；

 总时间 = 6 + 3 + 0.2 + 0.2 = 9.4ms。

* * *

**05、** 某个硬磁盘共有 4 个记录面，存储区域内半径为 10cm，外半径为 15.5cm，道密度为 60 道 / cm，外层位密度为 600 bit / cm，转速为 6000 转／分。  
1）硬磁盘的磁道总数是多少？  
2）硬磁盘的容量是多少？  
3）将长度超过一个磁道容量的文件记录在同一个柱面上是否合理？  
4）假定每个扇区的容量为 512B，每个磁道有 12 个扇区，寻道的平均等待时间为 10.5ms，试计算磁盘平均存取时间。

解：1 ）有效存储区域 = 15.5 - 10 = 5.5cm，道密度 = 60 道 / cm，因此每个面为 60×5.5 = 330道，即有 330 个柱面，因此磁道总数 = 4×330 = 1320 个磁道。

2 ）外层磁道的长度为 2 π \\pi π R = 2 × 3.14 × 15.5 = 97.34cm。  
每道信息量 = 600bit/cm x 97.34cm = 58404 bit = 7300B。  
利用 1) 的结果，可得磁盘总容量 = 7300B ×1320 = 9636000B（非格式化容量）。

3 ) 若长度超过一个磁道容量的文件，将它记录在同一个柱面上是比较合理的，因为不需要重新寻找磁道，这样数据读/写速度快。

4 ）总时间 = 10.5ms + （60 / 6000）/ 2 + （60 / 6000） / 12 = 16.33ms。

* * *

### 3.5、高速缓冲存储器

**01、程序访问的局部性原理**

**程序访问的局部性原理包括【时间局部性】和【空间局部性】。时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。 LRU体现了局部性原理**

* * *

**02、** CPU 与 Cache（或主存） 之间的数据交换以【字】为单位，而 Cache 与主存之间的数据交换则以 【Cache 块】为单位。

Cache 写命中处理方法：【全写法】、【回写法】；写不命中处理方法：【写分配法】、【非写分配法】。非写分配法通常与全写法合用，写分配法通常和回写法合用。

* * *

**03**、某虚拟存储器系统采用页式内存管理，使用 **LRU 页面替换算法**，考虑下面的页面访问地址流（每次访问在一个时间单位中完成）：1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 1 3 7。假定**内存容量为 4 个页面，开始时是空的**，则**页面失效率**是【30%】。

**LRU：最近最久未使用。做题时采用沉淀法，将最久未使用的沉在下面等待被替换。**

页1

2

7

2

1

8

3

8

2

1

3

1

7

1

3

7

页2

7

8

8

2

7

2

1

8

3

8

2

1

3

1

7

1

3

页3

8

1

1

7

7

8

8

7

2

1

1

3

8

2

2

3

3

7

1

页4

1

1

8

8

1

1

1

1

8

7

2

2

1

3

8

8

2

2

2

2

命中否

0

0

0

0

0

0

* * *

**04**、假设某个计算机的**主存地址空间大小为 256MB，按字节编址**，其数据 Cache 有 **8 个 Cache行**，**行长为 64B**（每行存储的数据有 512bit）。  
1）若不考虑用于 Cache 的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据 **Cache的总容量**为多少？  
2）若该 Cache 采用直接映射方式，则主存地址为 3200（十进制）的主存块对应的 Cache 行号是多少？采用二路组相联映射时又是多少？

解：1）数据 Cache 的总容量为 4256 位。**Cache 的总容量包括：存储容量、标记阵列容量**（有效位、标记位）（标记阵列中的一致性维护位和 Cache 数据一致性维护方式相关，替换算法控制位和替换算法相关，这里不计算）。

**标记字段长度的计算**：主存地址有 28 位（ 256MB = 228 B），其中 **6 位为块内地址**（26 B = 64B），**3 位为行号**（23 = 8），**剩余 28 - 6 - 3 = 19 位为标记字段**，总容量为 8 ×（1 + 19 + 512）= 4256位。

注意：每个 Cache 行对应一个标记项（包括**有效位**、**标记位 Tag**、一致性维护位、替换算法控制位），而在组相联中，将每组的标记项排成一行，将各组从上到下排列，成为一个二维的标记阵列（直接映射一行就是一组)。查找 Cache 时就是查找标记阵列的标记项是否符合要求。

2）直接映射方式中，**主存按照块的大小划分**，主存地址 3200 对应的字块号为 3200B/64B=50。而 Cache 只有 8 行，则 **50 mod 8 = 2，因此对应的 Cache 行号为 2。**  
二路组相联映射方式，实质上就是将**两个 Cache 行合并（组数为 4）**，内部采用全相联方式，外部采用直接映射方式，50 mod 4 = 2，对应的组号为 2，即对应的 Cache 行号为 4或 5。

* * *

**05、某存储系统中，主存容量是 Cache 容量的 4096 倍，Cache 被分为 64 个块，当主存地址和Cache 地址采用直接映像方式时，地址映射表的大小应为【】（不考虑一致维护和替换算法位）**

解析：**地址映射表即标记阵列**，由于 Cache 被分为 64 个块，则 Cache 有 64 行，采用直接映射，一行相当于一组。因此标记阵列每行存储 1 个标记项，其中主存标记项为 12 位（212 = 4096，是 Cache 容量的 4096 倍，即地址长度比 Cache 长 12 位），**加上 1 位有效位**，因此**为 64×13位**。

* * *

**06**、有一主存-Cache 层次的存储器，其**主存容量为 1MB**，**Cache 容量为 16KB**，**每块有 8 个字，每字 32 位，采用直接地址映像方式**，Cache 起始字块为**第 0 块**，若主存地址为 35301H，且CPU访问 Cache 命中，则在 Cache 的第【152】（十进制表示）字块中。

解析：先写出主存地址的二进制形式，然后分析 Cache 块内地址、Cache 字块地址和主存字块标记。主存地址的二进制数 0011 0101 0011 0000 0001，根据直接映射的地址结构，字块内地址为低 5位（每字块含32B，25 = 32，因此为5位），主存字块标记为高 6 位（1MB/16KB = 64，26 = 64，因此为 6位），其余 01 0011 000 即为 Cache 字块地址，转换为十进制数 152。

* * *

**07、假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为4 个字，每字 32 位，采用回写方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是【148K】**

解析：**直接映射的地址结构为： 主存字块标记 | Cache字块标记（行号） | 字块内地址**

按字节编址，块大小为 4×32位 = 16B = 24 B，则 “字块内地址” 占 4 位；“能存放 4K 字数据的Cache”即 Cache 的存储容量为 4K字（注意单位），则 Cache 共有 1K = 210 个 Cache 行，Cache 字块标记占 10 位；主存字块标记占 32 - 10 - 4 = 18位。  
Cache 总容量包括：存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算法控制位）。标记阵列中的有效位和标记位一定存在，而一致性维护位（脏位）和替换算法控制位的取舍标准是看词眼，题目中明确说明了采用回写法，则一定包含一致性维护位，而关于替换算法的词眼题目中未提及，所以不予考虑。因此，每个 Cache 行标记项包含 18+1+1 = 20位，标记阵列容量为 210× 20位 = 20K位，存储容量为 4K×32位 = 128K位，总容量为128K+20K = 148K位。

* * *

**08、有效容量为 128KB 的 Cache，每块 16B，采用 8 路组相联。字节地址为 1234567H 的单元调入该 Cache，则其 Tag 应为【048DH】。**

解析：**块大小为 16B**，所以**块内地址字段为 4位**；**Cache 容量为 128KB**，采用 8 路组相联，共有  
128KB / （16B × 8）= **1024 组**，组号字段为 10 位；剩下的为标记字段。1234567H 转换为二进制数  
0001 0010 0011 0100 0101 0110 0111H，标记字段对应高 14 位，即 048DH。

**组相联映射的地址结构：标记 | 组号 | 块内地址** **Cache 组号 = 主存块号 mod Cache组数**

* * *

**09、**假设主存按字节编址，**Cache 共有 64 行**，采用**四路组相联映射**方式，主存块大小为 32 字节，所有编号都从 0 开始。则第 2593 号存储单元所在主存块的组号是【1】。

解析：主存块大小为 32 字节（Cache 块大小也为 32 B），按字节编址，故块内地址占 5 位。采用四路组相联映射方式，共 64 行，分 64/4 = 16组，故**组号占 4 位**。因为 2593 = 0······0101 0001 00001，根据主存地址划分的结果，可以看出第 2593 号存储单元所在主存块的 Cache 组号为0001。

* * *

**10**、若主存地址位数为 32 位，按字节编址，主存和 Cache 之间采用**全相联映射方式**，主存块大小为 1 个字，每字 32 位，采用 **回写（writeback)方式和随机替换策略**，则能存放 32K 字（32K行）数据的 Cache 的总容量至少应有【2048K】位。

解析：主存块大小为 1 个字，即 32 位，按字节编址，故块内地址占 2 位。在全相联映射方式下，主存地址只有两个字段，故**标志占 32 - 2 = 30位**。因**采用回写法，故需 1 位修改位**；因为**采用随机替换策略，故无须替换控制位**。每个 Cache 行的总位数为 32bit（数据位）+ 30bit（tag位）+ 1bit（修改位）+1bit（有效位）= 64bit。综上，Cache 总容量至少应有 32Kx64bit=2048Kbit。

**回写式：每个标记项加一个一致性控制位（脏位）。全写法不用。**

**四路组相联 Cache 使用 LRU 算法的替换控制位为 2 位。（8路的话就是 3 位）**

* * *

**11**、若主存地址位数为32位，按字节编址，Cache 数据区大小为 32KB，主存块大小为 32B，采用**直接映射方式和回写（WriteBack)策略**，则 Cache 行的位数至少是 【275】。

解析：Cache 数据区大小为 32KB，主存块的大小为 32B，那么 Cache 中共有 1K 个 Cache行。因为采用直接映射方式，所以 1K 个 Cache 行映射到 1K 个分组，物理地址中组号部分的长度 10bit。32bit 的主存地址除去 5bit 的块内地址 和 10bit 的组号后，还剩 17 bit的 tag 部分。又因为 Cache 采用回写法，所以 Cahce 行的总位数应为 32B（数据位）+ 17bit（tag位）+1bit（修改位）+1bit（有效位）= 275bit。

* * *

**12、有如下C语言程序段：**

**for( k = 0; k<1000;k++) a\[k\] = a\[k\] + 32;**

若数组 a 和变量 k 均为 int 型，int 型数据占 4B，数据 Cache 采用直接映射方式，**数据区大小为1KB、块大小为 16B**，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为【12.5%】。

解析：a\[k\]的访问步骤是：先访问 cache，cache 缺失，之后从主存中取出一个块调入 cache，这个块中的后几个数据都是命中的，本题中一个数据占 4B，一个块大小是 16B，这说明一个块中有 4 个数据，关键是后面还有一次写，这说明一次循环要八次访问cache，其中只有第一次是缺失的，后面七次都是命中的，所以缺失率是 12.5%；

* * *

**13、**假设某计算机按字编址，**Cache 有 4 行**，Cache 和主存之间**交换的块大小为 1 个字**，若Cache 的内容初始为空，采用**二路组相联映射**方式和 **LRU 替换策略**，则访问的主存地址依次为 0，4，8，2，0，6，8，6，4，8 时，命中 Cache 的次数是【3】。

解析：地址映射采用二路组相联，主存地址为 0～1、4~5、8～9 可映射到第 0 组 Cache 中，主存地址为 2～3、6～7 可映射到第 1 组 Cache 中。Cache 置换过程如下表所示。

![](https://img-blog.csdnimg.cn/5cb77c1aca69436ba849a53a5ac16073.png)

* * *

**14、**假定 CPU 通过存储器总线读取数据的过程为：**发送地址和读命令需 1 个时钟周期**，**存储器准备一个数据需 8 个时钟周期**，**总线上每传送 1 个数据需 1 个时钟周期**。若主存和 Cache 之间交换的**主存块大小为 64B**，**存取宽度和总线宽度都为 8B**，则 Cache 的一次缺失损失至少为【80】个时钟周期。

解析：一次缺失损失需要从主存读出一个主存块（64B），每个总线事务读取 8B，因此需要 8 个总线事务。每个总线事务所用的时间为 1+8+1 = 10 个时钟周期，共需要 80 个时钟周期。

若题目中说**支持突发传送**，比如每个时钟周期总线上传送1个数据，可连续传送8个数据（即突发长度为 8），则 Cache 的一次缺失损失至少为【1 + 8 + 8 = 17】个时钟周期。

* * *

**15、**某 32 位计算机，**CPU 主频为 800MHz**，Cache 命中时的 CPI 为 4，Cache **块大小为 32B**；主存采用 **8 体交叉**存储方式，**每个体的存储字长为 32 位**、**存储周期为 40ns**，**存储器总线宽度为 32 位**，**总线时钟频率为 200MHz**，支持突发传送总线事务。每次读突发传送总线事务的过程包括：送首地址和命令、存储器准备数据、传送数据。**每次突发传送 32B**，传送地址或 32位 数据均需要一个总线时钟周期。请回答下列问题，要求给出理由或计算过程。  
1）CPU 和总线的时钟周期各为多少？总线的带宽（即最大数据传输率）为多少？  
2）Cache 缺失时，需要**用几个读突发传送总线事务**来完成**一个主存块**的读取？  
3）存储器总线完成一次读突发传送总线事务所需的时间是多少？  
4）若程序 BP 执行过程中共执行了100条指令，平均每条指令需进行1.2次访存，Cache 缺失率为 5％，不考虑替换等开销，则 BP 的 CPU 执行时间是多少？

解析：1）CPU 的时钟周期是主频的倒数，即 1/800MHz = 1.25ns。  
总线的时钟周期是总线频率的倒数，即 1/200MHz = 5ns。  
总线宽度为32位，因此总线带宽为 4Bx200MHz=800MB/s 。

**总线带宽指这条总线在单位时间内可以传输的数据总量，它等于总线位宽与工作频率的乘积。**

2）Cache 块大小是 32B，因此 Cache 缺失时**需要一个读突发传送总线事务**读取**一个主存块**。

3）一次读突发传送总线事务包括一次地址传送和 32B 数据传送：用 1 个总线时钟周期传输地址；每隔 40ns / 8 = 5ns 启动一个体工作（各进行 1 次存取），第一个 体读数据花费 40ns，之后数据存取与数据传输重叠；用 8 个总线时钟周期传输数据。读突发传送总线事务时间为 5ns + 40ns + 8\*5ns = 85ns。

4）**一条指令的平均 CPU 执行时间包括 Cache 命中时的指令执行时间和 Cache 缺失时带来的额外开销。** **Cache 命中时的一条指令执行时间 = Cache 命中时的 CPI × 时钟周期** = 4×1.25ns = 5ns。

**一条指令执行过程中因 Cache 缺失而导致的平均额外开销 = 平均访存次数 x Cache缺失率 × 一次读突发传送总线事务时间** = 1.2×5％×85ns = 5.1ns。

一条指令的平均 CPU 执行时间 = 5ns+5.1ns = 10.1ns。BP 的 CPU 执行时间 = 一条指令的平均CPU 执行时间×指令条数 = 10.1ns × 100 = 1010ns。

* * *

**16、**假定主存地址为 32 位，按字节编址，**指令 Cache** 和**数据 Cache** 与主存之间均采用 **8 路**组相联映射方式，直写（WriteThrough）写策略和 LRU 替换算法，**主存块大小为 64B**，**数据区容量各为 32KB**。开始时 Cache 均为空。请回答下列  
问题。  
**1）Cache 每一行中标记(Tag)、LRU位各占几位？是否有修改位？**  
2）有如下 C 语言程序段：  
for( k =0；k<1024；k++)  
s\[k\] = 2 \* s\[k\];  
若数组 s 及其变量 k 均为 int 型，int 型数据占 4B，变量 k 分配在寄存器中，数组 s 在主存中的起始地址为 0080 00C0H，则在该程序段执行过程中，访问数组 s 的数据 Cache 缺失次数为多少？  
3）若 CPU **最先开始**的访问操作是**读取主存单元 0001 0003H**中的指令，简要说明从 Cache 中访问该指令的过程，包括 Cache 缺失处理过程。

![](https://img-blog.csdnimg.cn/1e12dc764af64ea888d4baf780065e8f.png)

* * *

### 3.6、虚拟存储器

**01、虚拟存储系统利用的是局部性原理，程序应当具有较好的局部性； 输入、输出操作产生中断，与虚存无关； 大小较小但可以多个程序并发执行，也可以发挥虚存的作用； 顺序执行的指令应当占较大比重为宜，这样可增强程序的局部性。**

**02**、**虚拟存储管理系统的基础是程序访问的局部性原理**，此理论的基本含义是【**在程序的执行过程中，程序对主存的访问是不均匀的**】（**程序只能访问主存获得指令和数据**）。

**03**、**页式虚拟存储方式**对程序**分页**，**采用页进行交互**；**段页式则先按照逻辑分段**，然后**分页**，**以页为单位和主存交互**。

**04**、在虚拟存储器中，当程序正在执行时，由【操作系统】完成地址映射。（需要一部分硬件基础的支持，如快表、地址映射系统等）

**05**、采用虚拟存储器的主要目的是【扩大主存储器的存储空间】。

**06、缺页处理完成后回到发生缺页的指令继续执行。**

* * *

**07**、下列命令组合的一次访存过程中，不可能发生的是【D】。  
A. TLB 未命中，Cache未命中，Page未命中  
B. TLB 未命中，Cache命中，Page命中  
C. TLB 命中，Cache未命中，Page命中  
D. TLB 命中，Cache命中，Page未命中

**解析：TLB 缓存的页表就是来自 Page，所以 TLB命中，那肯定Page也命中。**

 TLB、Page、Cache 三种缺失的可能组合情况

**序号**

**TLB**

**Page**

**Cache**

**说明**

**1**

**命中**

**命中**

**命中**

**TLB 命中则 Page一定命中，信息在主存，就可能在 Cache 中**

**2**

**命中**

**命中**

**缺失**

**TLB 命中则 Page一定命中，信息在主存，也可能不在 Cache 中**

**3**

**缺失**

**命中**

**命中**

**TLB 缺失但 Page可能命中，信息在主存，就可能在 Cache 中**

**4**

**缺失**

**命中**

**缺失**

**TLB 缺失但 Page可能命中，信息在主存，也可能不在 Cache 中**

**5**

**缺失**

**缺失**

**缺失**

**TLB 缺失则 Page可能也缺失，信息不在主存，就一定不在 Cache 中**

* * *

**08、某计算机主存地址空间大小为 256MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB（快表）采用全相联映射，有 4 个页表项，内容如下表所示。**

**有效位**

**标记**

**页框号**

**0**

**FF180H**

**0002H**

**1**

**3FFF1H**

**0035H**

**0**

**02FF3H**

**0351H**

**1**

**03FFFH**

**0153H**

**则对虚拟地址 03FFF180H 进行虚实地址变换的结果是【015 3180H】。**

**解析：按字节编址，页面大小为 4KB，页内地址共 12位。地址空间大小为4GB，虚拟地址共 32位，前 20 位为页号。虚拟地址为 03FFF180H，因此页号为 03FFFH，页内地址为 180H。查找页标记03FFFH 所对应的页表项，页框号为 0153H，页框号与页内地址拼接即为物理地址 015 3180H。**

* * *

**09、设有 8 页的逻辑空间，每页有 1024B，它们被映射到 32 块的物理存储区中，则按字节编址逻辑地址的有效位是【13】物理地址至少是【15】位。**

**解析：对于逻辑地址，因为 8 = 23 页，所以表示页号的地址有 3 位，又因为每页有 1024 = 210 B，所以页内地址有 10 位，因此逻辑地址共 13 位。**  
**对于物理地址，块内地址和页内地址一样有 10 位，内存至少有 32 = 25 个物理块，所以表示块号的地址至少有 5 位，因此物理地址至少有 15 位。**

* * *

**10、假设计算机 M 的主存地址为 24 位，按字节编址；采用分页存储管理方式，虚拟地址为 30位，页大小为 4KB；TLB 采用二路组相联方式和 LRU 替换策略，共 8 组。请回答下列问题。**  
**1）虚拟地址中哪几位表示虚页号？哪几位表示页内地址？**  
**2）已知访问 TLB 时虚页号高位部分用作 TLB 标记，低位部分用作 TLB 组号，M 的虚拟地址中哪几位是 TLB 标记？哪几位是 TLB 组号？**  
**3）假设 TLB 初始时为空，访问的虚页号依次为 10，12，16，7，26，4，12和20，在此过程中，哪一个虚页号对应的 TLB 表项被替换？说明理由。**  
**4）若将 M 中的虚拟地址位数增加到 32 位，则 TLB 表项的位数增加几位？**

**答：1）按字节编址，页面大小为 4KB = 212 B，页内地址为 12 位。虚拟地址中高 30 - 12 = 18位**  
**表示虚页号，虚拟地址中低 12 位表示页内地址。**  
**2）TLB 采用二路组相联方式，共 8 = 23 组，用 3 位来标记组号。虚拟地址（或虚页号）中高 18 - 3 = 15 位为 TLB 标记，虚拟地址中随后 3 位（或虚页号中低 3 位）为 TLB 组号。**

**3）虚页号 4 对应的 TLB 表项被替换。因为虚页号与 TLB 组号的映射关系为 TLB 组号 = 虚页号 mod TLB组数 = 虚页号 mod 8，因此，虚页号 10，12，16，7，26，4，12，20 映射到的 TLB 组号依次为 2，4，0，7，2，4，4，4。TLB 采用二路组相联方式，从上述映射到的 TLB 组号序列可以看出，只有映射到 4 号组的虚页号数量大于 2，相应虚页号依次是 12，4，12 和 20。根据 LRU 替换策略，当访问第 20 页时，虚页号 4 对应的 TLB 表项被替换出来。**  
**4）虚拟地址位数增加到 32 位时，虚页号增加了 32 - 30 = 2位，使得每个 TLB 表项中的标记字段增加 2 位，因此，每个 TLB 表项的位数增加 2 位。**

* * *

### **3.7、简答题**

**01、存取周期和存取时间有何区别？**  
**存取周期和存取时间的主要区别是：存取时间仅为完成一次操作的时间；而存取周期不仅包含操作时间，而且包含操作后线路的恢复时间，即存取周期 = 存取时间+恢复时间。**

* * *

**02、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？**  
**页面不能设置得过大，也不能设置得过小。因为页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率；页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长。**

* * *

**03、发生取指令 Cache 缺失的处理过程是什么？**  
**1）程序计数器恢复当前指令的值。**  
**2）对主存进行读的操作。**  
**3）将读入的指令写入 Cache 中，更改有效位和标记位。**  
**4）重新执行当前指令。**

* * *

**04、假定某处理器可通过软件对高速缓存设置不同的写策略，则在下列两种情况下，应分别设置成什么写策略？为什么？**  
**1）处理器主要运行包含大量存储器写操作的数据访问密集型应用。**  
**2）处理器运行程序的性质与1）相同，但安全性要求高得多，不允许有任何数据不一致的情况发生。**

**回写法(WriteBack)减少了访存次数，但存在不一致的隐患。因此若题目中出现了“较高的安全要求”，则尽量要使用写直通法(WriteThrough)。**  
**1）采用 WriteBack 策略较好，可减少访存次数。**  
**2）采用 WriteThrough 策略较好，能保证数据的一致性。**

* * *

[4、指令系统](https://blog.csdn.net/qq_44709990/article/details/108133680)
---------------------------------------------------------------------

* * *

### 4.1、指令格式

**01、三地址指令：若地址字段均为主存地址，则完成一条三地址需要 4 次访问存储器（取指令 1次，取两个操作数 2次，存放结果 1次）。**

**02、以下有关指令系统的说法中，错误的是【D】。**  
A. 指令系统是一台机器硬件能执行的指令全体  
B. 任何程序运行前都要先转换为机器语言程序  
C. 指令系统是计算机软/硬件的界面  
**D. 指令系统和机器语言是无关的**

**解析：指令系统是计算机硬件的语言系统，这显然和机器语言有关。**

* * *

**03、堆栈计算机中，有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址，参加的两个操作数来自【堆栈的栈顶和次栈顶单元】。**

**解析**：零地址的运算类指令又称堆栈运算指令，参与的两个操作数来自栈顶和次栈顶单元。  
**注意**：堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。若是软堆栈（堆栈区由内存实现），则对于双目运算需要访问 4 次内存：取指、取源数1、取源数2、存结果。若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存。

* * *

**04、以下叙述错误的是【B】。**  
A. 为了便于取指，指令的长度通常为存储字长的整数倍  
**B. 单地址指令是固定长度的指令**  
C. 单字长指令可加快取指令的速度  
D. 单地址指令可能有一个操作数，也可能有两个操作数

解析：指令的地址个数与指令的长度是否固定没有必然联系，即使是单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同。

* * *

**05、** 一个计算机系统采用 32 位单字长指令，地址码为 12 位，若定义了 250 条二地址指令，则还可以有【24K】条单地址指令。

解析：地址码为 12 位，二地址指令的操作码长度为 32 - 12 - 12 = 8位，已定义了 250 条二地址指令，28 - 250 =6，即可以设计出单地址指令 6×212 = 24K 条。

* * *

**06、某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条、二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是【24位】。**  
解析：三地址指令有 29 条，所以其操作码至少为 5 位。以 5 位进行计算，它剩余 25 - 29 = 3种操作码给二地址。而二地址另外多了 6 位给操作码，因此其数量最大达 3×64=192。所以指令字长最少为 23 位，因为**计算机按字节编址，需要是 8 的倍数**，所以指令字长至少应该是 24 位。

* * *

**07**、假设指令字长为 16 位，操作数的地址码为 6 位，指令有零地址、一地址、二地址 3 种格式。

1）设操作码固定，若零地址指令有 M 种，一地址指令有 N 种，则二地址指令最多有几种？  
2）采用扩展操作码技术，二地址指令最多有几种？  
3）采用扩展操作码技术，若二地址指令有 P 条，零地址指令有 Q 条，则一地址指令最多有几种？

答：1）根据操作数地址码为 6 位，得到二地址指令中操作码的位数为 16 - 6 - 6 = 4，这 4 位操作码可有 16 种操作。由于操作码固定，因此除了零地址指令有 M 种，一地址指令有 N 种，剩下的二地址指令最多有 16 - M - N 种。

2）采用扩展操作码技术，操作码位数可随地址数的减少而增加。对于二地址指令，指令字长 16位，减去两个地址码 12位，剩下 4 位操作码，共 16 种编码，去掉一种编码（如111）用于一地址指令扩展，二地址指令最多可有 15 种操作。

3）采用扩展操作码技术，操作码位数可变，二地址、一地址和零地址的操作码长度分别为 4位、10 位和 16 位。这样，二地址指令操作码每减少一个，就可以多构成 26 条一地址指令操作码；一地址指令操作码每减少一个，就可以多构成 26 条零地址指令操作码。

设一地址指令有 R 条，则一地址指令最多有（24 - P）× 26 条，零地址指令最多有\[ (24 - P)×26 - R\]×26 条。

**补充：**

**在设计扩展操作码指令格式时，必须注意以下两点：**  
**1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。**  
**2）各指令的操作码一定不能重复。**

* * *

### 4.2、指令的寻址方式

**本节可参考博客：[计算机组成原理——指令系统（课程笔记）](https://blog.csdn.net/qq_45800517/article/details/125423029)**

**01、基本知识点：**

 **EA = （A）意思是有效地址是地址 A 中的数值。**

 **数据寻址的指令格式：操作码 | 寻址特征 | 形式地址 A**

**指令系统中采用不同寻址方式的目的是【缩短指令字长，扩大寻址空间，提高编程的灵活性】**

**相对寻址方式中，指令所提供的相对地址实质上是一种【以下条指令在内存中首地址为基准位置的偏移量】。（EA =(PC) + A，执行本条指令时，PC 已完成加 1 操作（已自动更新），PC 中保存的是下一条指令的地址）**

**在多道程序设计中，最重要的寻址方式是【相对寻址】。**

指令字中的形式地址为操作数的有效地址，这种方式为【直接寻址】。

寻址方式

有效地址

访存次数

隐含寻址

程序指定

0

立即寻址

A 即是操作数

0

直接寻址

EA = A

1

一次间接寻址

EA =(A)

2

寄存器寻址

EA =Ri

0

寄存器间接一次寻址

EA =(Ri)

1

相对寻址（程序浮动）

EA =(PC) + A

1

基址寻址

EA =(BR) + A

1

变址寻址（数组）

EA =(IX) + A

1

* * *

**02**、某机器**指令字长为 16 位**，主存接字节编址，取指令时，**每取一字节，PC 自动加1**。当前指令地址为 2000H，**指令内容为相对寻址的无条件转移指令**，指令中的**形式地址为 40H**。则**取指令后**及**指令执行后** PC 的内容为【**2002H，2042H**】。

解析：指令字长为16位，2字节，因此**取指令后PC的内容为**（PC）+ 2 = 2002H；无条件转移指令将下一条指令的地址送至 PC，形式地址为 40H，指令执行后 PC=2002H + 0040H=2042H。

* * *

**03**、对按字寻址的机器，**程序计数器** 和 **指令寄存器** 的**位数**各取决于【**存储器的字数**】、【**指令字长**】。

解析：机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（指令在内存中的地址)，因此取决于存储器的字数；指令寄存器(IR) 用于接收取得的指令，因此取决于指令字长。

* * *

04、假设某条指令的第一个操作数采用**寄存器间接寻址**方式，指令中给出的寄存器编号为 8，8号寄存器的内容为 1200H，地址为 1200H 的单元中的内容为 12FCH，地址为 12FCH 的单元中的内容为 38D8H，而地址为 38D8H 的单元中的内容为 88F9H，则该**操作数的有效地址**为【1200H】。  
解析：寄存器间接寻址中操作数的有效地址 EA =（Ri），8 号寄存器内容为 1200H，因此 EA =  
1200H。

**特别注意：有效地址的内容即为要访问到的操作数。Ri 给出的是操作数所在主存单元的地址，即 EA = ( R i )**

* * *

**05**、假设**变址寄存器** R 的**内容为 1000H**，**指令中的形式地址为 2000H**；地址 1000H 中的内容为2000H，地址 2000H 中的内容为 3000H，地址 3000H 中的内容为 4000H，则**变址寻址方式下访问到的操作数**是【**4000H**】。

解析：根据变址寻址的方法，变址寄存器的内容（1000H）与 形式地址的内容（2000H）相加，得到操作数的实际地址（3000H），根据实际地址访问内存，获取操作数 4000H。

* * *

**06**、设**相对寻址**的转移指令占 **3B**，第一字节为操作码，第二、三字节为相对位移量（补码表示），而且数据在存储器中采用**以低字节为字地址的存放方式**。每当 CPU 从存储器**取出一字节时**，即自动完成\*\*（PC）+ 1 --> PC\*\*。若 PC 的当前值为 240（十进制），要求转移到 290（十进制），则转移指令的第二、三字节的机器代码是【**2FH 00H**】；若 PC 的当前值为 240（十进制），要求转移到 200（十进制)，则转移指令的第二、三字节的机器代码是【**D5H FFH**】。

解析：**补码的扩充：正数补码的扩充只需补0，负数补码的扩充只需补1。**  
1）PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 290，即**相对位移量为 47**，转换成**补码为 2FH**。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为 2FH，由于 47 是正数，因此只需在高位补 0，所以第三字节为 00H。  
2）PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 200，即相对位移量为 -43，转换成补码为 D5H。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为D5H，由于 -43是负数，因此只需在高位补 1，所以第三字节为 FFH。

* * *

**07**、某机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志 SF 和溢出标志OF，条件转移指令bgt（无符号整数比较，大于时转移）的转移条件是【 C F + Z F ‾ \\overline{CF+ZF} CF+ZF = 1】。

解析：假设两个无符号整数 A 和 B，bgt 指令会将 A 和 B 进行比较，也就是将 A 和 B 相减。若 A > B，则 A - B 肯定无进位/借位，也不为0（为0时表示两数相等），因此 CF 和 ZF 均为 0。

* * *

**08**、某计算机有 **16 个通用寄存器**，采用 **32 位定长指令字**，**操作码字段（含寻址方式位）为 8位**，Store 指令的**源操作数**和**目的操作数**分别采用**寄存器直接寻址**和**基址寻址**方式。若**基址寄存器可使用任一通用寄存器，且偏移量用补码表示**，则 Store 指令中偏移量的取值范围是【-32768 ~+32767】。

解析：采用 32 位定长指令字，其中操作码为 8 位，两个**地址码共占用** 32 - 8 = 24位，而 Store指令的源操作数和目的操作数分别采用**寄存器直接寻址**和**基址寻址**，机器中共有 16 个通用寄存器，因此**寻址一个寄存器需要 log2 16 = 4位**，源操作数中的寄存器直接寻址用掉 4 位，而目的操作数采用基址寻址也要指定一个寄存器，同样用掉 4 位，则**留给偏移量的位数为 24 - 4 - 4 = 16位**，而偏移量用**补码**表示，因此 16 位补码的表示范围为 -32768 ~+32767。

* * *

**09**、某计算机采用**大端方式**，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用**基址寻址**方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H，则该操作数的 LSB（最低有效字节）所在的地址是【EFFF FF15H】。

解析：考察补码运算，寻址，大、小端。  
FF12 = 1111 1111 0001 0010–>- 0000 0000 1110 1101+1 = - 0000 0000 1110 1110 = -00EE  
\-00EE+F000 0000=EFFF FF12  
大端方式，低地址存高位，即所求地址为 EFFF FF12 + 3 = EFFF FF15 。  
扩展：大端，即存储顺序和阅读顺序一致（网络字节序），如 10（int）为 000A ，小端，即和大端相反的存储顺序，如10（int）为 A000 ，写法中，从左到右为地址增加的方向，也即地址为左侧第一个字节的地址。

**错因分析：内存地址是无符号数，视作一个二进制数串，不是什么原码、补码表示。形式地址就是偏移量，补码表示时，要翻译成原码，并且除去符号位后，剩下的才可视为二进制数。**

![](https://img-blog.csdnimg.cn/049b953663154e7b831e8d3c6fe92c1e.png)

**参考博客：[计算机考研408题集](https://www.cnblogs.com/amazzzzzing/p/14022094.html) [大/小端方式](https://blog.csdn.net/zx013650/article/details/80068436) [LSB最低有效位和MSB最高有效位](https://blog.csdn.net/qq_29350001/article/details/51177404)**

* * *

**10**、某计算机采用 **16 位定长指令字格式**，**操作码位数和寻址方式位数固定**，指令系统有 48 条指令，支持直接、间接、立即，相对 4 种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是【0~255】。

解析：**48 条指令需要 6 位操作码字段**（25 <48<26），**4 种寻址方式需要 2 位寻址特征位**，还剩16 - 6 - 2 = 8 位作为地址码，故直接寻址范围为 0～255。注意，主存地址不能为负。

* * *

### 4.3、程序的机器级代码表示

#### 4.3.1、常用汇编指令介绍

##### 1、相关寄存器

**（除 EBP 和 ESP 外，其他几个寄存器的用途是比较任意的）**

![](https://img-blog.csdnimg.cn/3fe6f8f06d0642d982e4c91142519e8c.png)

##### 2、汇编指令格式

![](https://img-blog.csdnimg.cn/4439c65ad7594ddbbe86ef741e417217.png)

##### 3、常用指令

*   **<reg>：表示任意寄存器，若其后带有数字，则指定其位数，如表示32位寄存器。**
*   **<mem>：表示内存地址（如\[eax\]、\[var+4\] 或 dword ptr\[eax+ebx\])。**
*   **<con>：表示 8 位、16 位或 32 位常数。 表示 8 位常数。**

###### （1）数据传送指令

**1）mov 指令**：将第二个操作数（寄存器的内容、内存中的内容 或 常数值）复制到第一个操作数（寄存器 或 内存）。但**不能用于直接从内存复制到内存**。

    语法如下：
    	mov <reg>,<reg>			mov <reg>,<mem>		mov <reg>,<con>
    	mov <mem>,<reg>			mov <mem>,<con>
    举例：
    	mov eax,ebx    			# 将 ebx 值复制到 eax
    	mov byte ptr [var], 5   # 将 5 保存到 var 值指示的内存地址的一字节中


**2）push 指令** ：将操作数压入内存的栈，常用于函数调用。ESP 是栈顶，压栈前先将 ESP值减4（栈增长方向与内存地址增长方向相反），然后将操作数压入 ESP 指示的地址。

    语法如下：
    	push <reg32>		push <mem>		push <con32>
    举例：（栈中元素固定为 32 位）
    	push eax		# 将 eax 值压栈
    	push [var]		# 将 var 值指示的内存地址的 4 字节值压栈


**3）pop 指令：** 执行出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4。

    语法如下：
    	pop edi			# 弹出栈顶元素送到 edi
    	pop [ebx]		# 弹出栈顶元素送到 ebx 值指示的内存地址的 4 字节中


###### （2）算术和逻辑运算指令

**1）add / sub 指令**：add 指令将两个操作数相加，相加的结果保存到第一个操作数中。sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中。

    语法如下：
        add	<reg>,<reg> / sub <reg>,<reg>
    	add <reg>,<mem> / sub <reg>,<mem>
        add <reg>,<con> / sub <reg>,<con>
    	add <mem>,<reg> / sub <mem>,<reg>
    	add <mem>,<con> / sub <mem>,<con>
    举例：
        sub eax,10
        add byte ptr [var],10 # 10与var值指示的内存地址的一字节值相加,并将结果
    保存在var值指示的内存地址的字节中


**2）inc/dec 指令**：分别表示将操作数自加 1、自减 1。

    语法如下：
        inc <reg> / dec <reg>
        inc <mem> / dec <mem>
    举例：
        dec eax    # eax 值自减 1
        inc dword ptr [var]    # var值指示的内存地址的4字节值自加 1


**3）imul 指令**：带符号整数乘法指令，有两种格式．a. 两个操作数，将两个操作数相乘，将结果保存在第一个操作数中，**第一个操作数必须为寄存器**；b. 三个操作数，将第二个和第三个操作数相乘，将结果保存在第一个操作数中，**第一个操作数必须为寄存器**。

    语法如下：
        imul <reg32>,<reg32>
    	imul <reg32>,<mem>
    	imul <reg32>,<reg32>,<con>
    	imul <reg32>,<mem>，<con>
    举例：
        imul eax,[var] 		imul esi,edi,25
    乘法操作结果可能溢出，则编译器置溢出标志 OF=1,以使 CPU 调出溢出异常处理程序


**4）idiv 指令**：带符号整数除法指令，它只有一个操作数，即除数，而被除数则为 edx:eax 中的内容（64位整数），操作结果有两部分：商和余数，商送到 eax，余数送到 edx。

    语法如下：
        idiv <reg32>	idiv <mem>
    举例：
        idiv ebx		idiv dword ptr [var]


**5）and/or/xor 指令**：分别是逻辑与、逻辑或、逻辑异或 操作指令，用于操作数的位操作，操作结果放在第一个操作数中。

    语法如下：
        and	<reg>,<reg> / or <reg>,<reg>
    	and <reg>,<mem> / or <reg>,<mem>
        and <reg>,<con> / or <reg>,<con>
    	and <mem>,<reg> / or <mem>,<reg>
    	and <mem>,<con> / or <mem>,<con>
    举例：
        xor edx,edx    # 置edx中的内容为0
        and eax,0fH    # 将eax中的前 28 位全部置为 0，最后 4 位保持不变


**6）not 指令**：位翻转指令，将操作数中的每一位翻转，即 0–>1，1–>0。

    语法如下：
        not <reg>	not <mem>
    举例：
        not byte ptr [var] # 将var值指示的内存地址的一字节的所有位翻转


**7）shl / shr 指令**：逻辑移位指令，shl 为逻辑左移，shr 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。

    语法如下：
        shl / shr <reg>,<con8>
    	shl / shr <mem>,<con8>
    	shl / shr <reg>,<cl>
    	shl / shr <mem>,<cl>
    举例：
        shl eax,1      # 将eax值左移1位，相当于乘以 2
        shr ebx,cl     # 将ebx值右移 n 位(n为 cl 中的值)


**8）neg 指令**：取负指令。

    语法如下：
        neg <reg>		neg <mem>
    举例：
        neg eax    # eax <--- -eax


###### （3）控制流指令

x86 处理器维持着一个指示当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。IP 寄存器不能直接操作，但可以用控制流指令更新。通常用**标签**指示程序中的指令地址，在 x86 汇编代码中，可在任何指令前加入标签。例如，

    		mov esi,[ebp+8]
    begin:  xor ecx,ecx		# 指示第二条指令，控制流指令通过标签就可以实现跳转
        	mov eax,[esi]


**1）jmp 指令：** 控制 IP 转移到 label 所指示的地址（从 label 中取出指令执行）

    语法如下：
    	jmp <label>
    举例：
        jmp begin    # 转跳到 begin 标记的指令执行


**2）jcondition 指令**：条件转移指令，依据 CPU 状态字中的一系列条件状态转移。CPU状态字中包括指示最后一个算术运算结果是否为 0，运算结果是否为负数等。

    语法如下：
        je   <label> 	(jump when equal)
    	jne  <label>	(jump when not equal)
    	jz	 <label>	(jump when 1ast result was zero)
    	jg	 <label>	(jump when greater than)
    	jge	 <label>	(jump when greater than or equal to)
    	jl	 <label>	(jump when less than)
    	jle	 <label>	(jump when less than or equal to)
    举例：
        cmp eax,ebx
        jlc done  # 如果 eax 的值小于等于ebx值,跳转到done指示的指令执行，否则执行下一条指令。


**3）cmp/test 指令**：cmp 指令用于比较两个操作数的值，test 指令对两个操作数进行逐位与运算，这两类指令都不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码。

    语法如下：
        cmp <reg>,<reg> / test <reg>,<reg>
    	cmp <reg>,<mem> / test <reg>,<mem>
    	cmp <mem>,<reg> / test <mem>,<reg>
    	cmp <reg>,<con> / test <reg>,<con>
    举例：
        cmp dword ptr [var],10    #将 var 指示的主存地址的4字节内容，与 10 比较
    	jne loop		# 如果相等则继续顺序执行; 否则跳转到 loop 处执行
    	test eax,eax    # 测试 eax 是否为零
    	jz xxxx         # 为零则置标志 ZF 为 1，转跳到 xxxx 处执行


**4）call/ret 指令**：分别用于实现子程序（过程、函数等）的调用及返回。

    语法如下：
    	call <label>
    	ret


**call 指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。** 当 call 指令结束后，返回调用之前的地址。ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。

#### 4.3.2、选择语句的机器级表示

##### （1）条件码（标志位）

CF

进（借）位标志

最近无符号整数加(减)运算后的进(借)位情况，有进(借)位 CF=1

**ZF**

**零标志**

**最近操作的运算结果是否为0。若结果为0，ZF=1**

**SF**

**符号标志**

**最近的带符号数运算结果的符号。若为负，SF=1**

**OF**

**溢出标志**

**最近的带符号数运算结果是否溢出。若溢出，OF=1**

常见的算术逻辑运算指令（add、sub、imul、or、and、shl、inc、dec、not、sal 等）会设置条件码。但**有两类指令只设置条件码而不改变任何其他寄存器**：cmp 指令和 sub 指令的行为一样，test指令与 and 指令的行为一样，但是它们**只设置条件码，而不更新目的寄存器。**

##### （2）if 语句

**if-else 语句的通用形式如下：**

    if(test_expr) // test_expr 是一个整数表达式，它的取值为 0 (假)
    	then_statement
    e1se
    	else_statement


**翻译成汇编语言：**

    	t = test_expr;
    	if(!t)
    		goto false;
    	then_statement
    	goto done;
    false:
    	else_statement
    done:


#### 4.3.3、参考博客

**（1）[程序的机器级表示](https://blog.csdn.net/u012419550/article/details/120673197)**

**（2）[选择结构语句的机器级表示](https://blog.csdn.net/weixin_44847698/article/details/120456083)**

**（3）[选择和循环语句的机器级表示](https://www.jianshu.com/p/d5882f966f95)**

#### 4.3.4、对应习题

**01、假设 R\[ax\] = FFE8H，R\[bx\] = 7FE6H，执行指令"addw %bx，%ax"后，寄存器的内容和各标志的变化为【R\[ax\] = 7FCEH，OF=0，SF=0，CF=1，ZF=0】。**

解析：由指令格式可知该指令是 AT&T 格式，add 指令的目的寄存器为 ax。add 指令的补码加法过程为 1111 1111 1110 1000+0111 1111 1110 0110 =（1）0111 1111 1100 1110 (7FCEH)，参与加法运算的两个数的符号不同，因此必定不会溢出，OF=0；结果的符号位为0，SF=0；有进位，CF=1 ⨁ \\bigoplus ⨁ 0 = 1；非 0，ZF=0。

* * *

### 4.4、CISC 和 RISC 的基本概念

#### 1）CISC 的主要特点

    指令系统复杂庞大，指令数目一般为 200 条以上。
    指令的长度不固定，指令格式多，寻址方式多。
    可以访存的指令不受限制。
    各种指令使用频度相差很大。
    各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。
    控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。
    难以用优化编译生成高效的目标代码程序。


#### 2）RISC的主要特点

    选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。
    指令长度固定，指令格式种类少，寻址方式种类少。
    只有 Load/Store（取数/存数）指令访存，其余指令的操作都在寄存器之间进行。
    CPU 中通用寄存器的数量相当多。
    RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。
    以硬布线控制为主，不用或少用微程序控制。
    特别重视编译优化工作，以减少程序执行时间。


**RISC 是尽量简化单条指令的功能，复杂指令的功能由简单指令的组合来实现，而增强指令的功能则是 CISC 的特点。**

对比项目

CISC

RISC

**指令系统**

**复杂、庞大**

**简单、精简**

**指令数目**

**一般大于200条**

**一般小于100条**

**指令字长**

**不固定**

**固定**

**可访存指令**

**不加限制**

**只有Load/Store指令**

**各种指令执行时间**

**相差较大**

**绝大多数在一个周期内完成**

**各种指令执行频度**

**相差很大**

**都比较常用**

**通用寄存器数量**

**较少**

**多**

**目标代码**

**难以用优化编译生成高效的目标代码程序**

**采用优化的编译程序，生成代码较为高效**

**控制方式**

**绝大多数为微程序控制**

**绝大多数为组合逻辑控制**

**指令流水线**

**可以通过一定方式实现**

**必须实现**

* * *

### 4.5、简答题

**01、什么是指令？什么是指令系统？为什么要引入指令系统？**

指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。

**02、一般来说，指令分为哪些部分？每部分有什么用处？**

**一条指令通常包括操作码字段和地址码字段两部分**。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。

**03、对于一个指令系统来说，寻址方式多和少有什么影响？**

寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成 CPU 结构的复杂化，也不利于指令流水线的运行。而寻址方式太少虽然能够提高 CPU 的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。

**04、简述各常见指令寻址方式的特点和适用情况。**

**立即寻址**：操作数获取便捷，通常用于给寄存器赋初值。  
**直接寻址**相对于立即寻址，缩短了指令长度。  
**间接寻址**扩大了寻址范围，便于编制程序，易于完成子程序返回，  
**寄存器寻址**的指令字较短，指令执行速度较快。  
**寄存器间接寻址**扩大了寻址范围。  
**基址寻址**扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。  
**变址寻址**主要用于处理数组问题，适合编制循环程序。  
**相对寻址**用于控制程序的执行顺序、转移等。  
**基址寻址和变址寻址的区别**：两种方式有效地址的形成都是**寄存器内容+偏移地址**，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。

**05、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？**

现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如char、int、floal、double)可能是 8位、16位、32位或 64位等，因此可能占用1个、2个、4个或 8个内存单元。也就是说，一个操作数可能有多个内存地址对应。  
**有两种不同的地址指定方式：大端方式和小端方式。**  
**大端方式**：指令中给出的地址是操作数最高有效字节（MSB）所在的地址。  
**小端方式**：指令中给出的地址是操作数最低有效字节（LSB）所在的地址。

**06、采用什么寻址方式时指令码长度最短？采用什么寻址方式时指令码长度最长？**

由于通用寄存器的数量有限，可以用较少的二进制位来编码，所以**采用寄存器寻址方式和寄存器间接寻址方式的指令码长度最短**。因为需要在指令中表示数据和地址，所以**立即寻址方式、直接寻址方式和间接寻址方式的指令码长度最长。**

**07、采用什么寻址方式时执行速度最快？采用什么寻址方式时执行速度最慢？**

由于通用寄存器位于 CPU 内部，无须到内存读取操作数，所以**寄存器寻址方式执行速度最快**。而间接寻址方式需要读内存两次，第一次由操作数的间接地址读到操作数的地址，第二次再由操作数的地址读到操作数，所以**间接寻址方式的执行速度最慢。**

**08、若指令系统采用定长指令码格式，则采用什么寻址方式时执行速度最快？**

若指令系统**采用定长指令码格式**，所有指令（包括采用立即寻址方式的指令）所包含的二进制位数均相同，则**立即寻址方式执行速度最快**，因为读到指令的同时，便立即取得操作数。若采用变长指令码格式，由于要表示一定范围内的立即数，包含立即数的指令通常需要较多的二进制位，取指令时，可能需要不止一次地读内存来完成取指令。因此，**采用变长指令码格式时，寄存器寻址方式执行速度最快。**

* * *

5、[中央处理器总结](https://blog.csdn.net/bay_Tong/article/details/113062382?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165651248916782248515206%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165651248916782248515206&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-4-113062382-null-null.142%5Ev26%5Epc_rank_34,157%5Ev15%5Enew_3&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8&spm=1018.2226.3001.4187)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 5.1、CPU功能和基本结构

**01、运算器的组成部件**：**【算术逻辑单元(ALU)】、【暂存寄存器】、【累加寄存器(ACC)】、【通用寄存器组】、【程序状态字寄存器(PSW)】、【移位器】、【计数器(CT)】。**

**02、控制器的组成部件**：**【程序计数器(PC)】、【指令寄存器(IR)】、【指令译码器】、【存储器地址寄存器(MAR)】、【存储器数据寄存器(MDR)】、【时序系统】、【微操作信号发生器】。**

**03、用户可见的寄存器**：【通用寄存器组】、【程序状态字寄存器】、【程序计数器】。

**04、用户不可见的寄存器**：**【存储器地址寄存器(MAR)】、【存储器数据寄存器(MDR)】、【指令寄存器】。**

**05**、在所谓的 **n位 CPU** 中，n 是指【**数据总线线数**（数据总线的位数与处理器的位数相同）】。

**06**、在一条无条件跳转指令的指令周期内，PC 的值被修改【2】。

解析：**取指周期结束后，PC值自动加1**；执行周期中，PC 值修改为要跳转到的地址，因此在这个  
指令周期内，PC 值被修改两次。

**07**、**程序计数器的位数**取决于【**存储器的容量**】。

**08**、**指令寄存器的位数**取决于【**指令字长**】。

**09**、**CPU 中通用寄存器的位数**取决于【**机器字长**】。

**10**、**间址周期结束时**，CPU 内寄存器 **MDR 中的内容**为【**操作数地址**】。

解析：**间址周期的作用是取操作数的有效地址**，因此间址周期结束后，MDR 中的内容为操作数  
地址。

寄存器

作用

**指令寄存器（IR）**

**存放当前正在执行的指令**

**程序计数器**

**存放下一条指令在主存中的地址，具有自增功能。**

**地址寄存器**

**暂存指令或数据的地址**

**通用寄存器**

**存放操作数和各种地址信息等**

**程序状态字寄存器**

**暂存系统运行状态（状态标志 / 控制标志）**

### 5.2、指令执行过程

指令周期

行为

标志触发器

**取指周期**

**取指令（从主存中取出指令字）**

**FE**

**间址周期**

**取有效地址**

**IND**

**执行周期**

**取操作数**

**EX**

**中断周期**

**保存程序断点**

**INT**

**01**、【时钟周期】是**计算机操作的最小单位时间**，由计算机的主频确定，是主频的倒数。**工作脉冲是控制器的最小时间单位**，起定时触发作用，一个时钟周期有一个工作脉冲。指令周期则可由多个CPU 周期组成。**CPU 周期，即机器周期，包含若干时钟周期。**

**02**、以下叙述中，错误的是【B】。  
A. 指令周期的第一个操作是取指令  
B. 为了进行取指操作，控制器需要得到相应的指令  
C. 取指操作是控制器自动进行的  
D. 指令执行时有些操作是相同或相似的

解析：取指操作是自动进行的，控制器不需要得到相应的指令。

**03**、存储器进行一次读或写操作所需的时间称为存储器的访问时间（或读／写时间），而连续启动两次独立的读或写操作（如连续的两次读操作）所需的最短时间称为存取周期。**机器周期通常由存取周期确定。**

**04、、【控制器】可区分存储单元中存放的是指令还是数据。**

**05、下列说法中，正确的是【（2）（3）】。**  
（1）指令字长等于机器字长的前提下，取指周期等于机器周期  
**（2）指令字长等于存储字长的前提下，取指周期等于机器周期**  
**（3）指令字长和机器字长的长度没有任何关系**  
（4）为了硬件设计方便，指令字长都和存储字长一样大

解析：**指令字长一般都取存储字长的整数倍**，若指令字长等于存储字长的 2 倍，则需要两次访存，取指周期等于机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。**指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，与机器字长没有必然的联系。但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍。**

* * *

### 5.3、数据通路的功能和基本结构

**（1）PC 内容送至 MAR**

    PC---->Bus        PCout有效,PC内容送总线
    Bus--->MAR		  MARin有效,总线内容送MAR


**（2）CPU从主存读取指令**

    PC--->Bus--->MAR		PCout 和 MARin有效,现行指令地址 --->MAR
    I--->R					CU 发读命令
    MEM(MAR)--->MDR			MDRin有效
    MDR--->Bus--->IR		MDRout 和 IRin 有效,现行指令--->IR


**（3）两数相加**

    Ad(IR)--->Bus--->MAR		MDRout 和 MARin有效
    I--->R						CU 发读命令
    MEM--->数据线--->MDR		 操作数从存储器--->数据线--->MDR
    MDR--->Bus--->Y				MDRout 和 Yin 有效，操作数--->Y
    (ACC)+(Y)--->Z				ACCout 和 ALUin 有效，CU 向 ALU 发加命令,结果---> Z
    Z--->ACC					Zout 和 ACCin 有效，结果--->ACC


**01**、对 CPU 而言，数据通路的基本结构分为【总线结构】和【专用数据通路结构】，其中总线结构又分为【单总线结构】、【双总线结构】、【多总线结构】。

**02**、ALU 是一个组合逻辑电路，其运算过程中必须保持**两个输入端的内容不变**。由于**CPU内部**采用**单总线结构**，因此为了得到两个不同的操作数，ALU 的**一个输入端与总线相连**，**另一个输入端需通过一个寄存器与总线相连**。此外，ALU 的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，因此**输出端需通过一个暂存器（用来暂存结果的寄存器）与总线相连。**

**03、CPU内部总线方式的数据通路的特点**：结构简单，实现容易，性能较低，存在较多的冲突现象；**不采用 CPU 内部总线方式的数据通路的特点**：结构复杂，硬件量大，不易实现，性能高，基本不存在数据冲突现象。

**04**、**单总线数据通路**将**所有寄存器的输入输出端都连接在一条公共通路上**，一个时钟内只允许一次操作，无法完成指令的所有操作。

**05**、控制信号是 CU 根据指令操作码发出的信号，对于**单周期处理器来说**，每条指令的执行只有一个时钟周期，而**在一个时钟周期内控制信号并不会变化**；若是**多周期处理器**，则指令的执行需要多个时钟周期，在**每个时钟周期控制器会发出不同信号**。

**06**、指令执行过程中数据所经过的路径，包括路径上的部件，称为数据通路。**ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等**，都是指令执行过程中数据流经的部件，**都属于数据通路的一部分**。数据通路中的数据流动路径由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。

**07、历年大题：**

[2015年统考真题](https://www.nowcoder.com/questionTerminal/9dffdcd18ede4453b40bb07dd98f203b)

[2009年统考真题](https://www.nowcoder.com/questionTerminal/028672e76a464fcb91d8e76b1f6b8891?toCommentId=1753438)

* * *

### [5.4、控制器的功能和工作原理](https://blog.csdn.net/qq_37291934/article/details/100607242)（结合视频学习）

**01**、**取指令阶段**完成的任务是**将现行指令从主存中取出并送至指令寄存器**，这个操作是公共的操作，是每条指令都要进行的，与具体的指令无关，所以**不需要操作码的控制**。

**02**、在**组合逻辑控制器**中，**微操作控制信号**的形成主要与【**指令译码信号和时钟**】信号有关。因为：CU 的输入信号来源如下：（1）经指令译码器译码产生的指令信息；（2）时序系统产生的机器  
周期信号和节拍信号；（3）来自执行单元的反馈信息即标志。前两者是主要因素。

**03**、在**微程序控制器**中，形成**微程序入口地址**的是【**机器指令的操作码字段**】。

解析：**执行公用的取指微程序从主存中取出机器指令**后，由机器指令的操作码字段指出各个微程  
序的入口地址（初始微地址)。

**04**、**微程序控制存储器**用来**存放微程序**，是**微程序控制器的核心部件**，**属于 CPU 的一部分，而不属于主存。**

**05**、**硬布线控制器**需要结合各微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图，因此**时序系统比较复杂**；而**微程序**只需按照节拍的安排，顺序执行微指令，因此**比较简单**。

**06**、**在微程序控制器中**，**控制部件向执行部件发出的控制信号称为微命令**，**微命令执行的操作**  
**称为微操作**。**微指令则是若干微命令的集合，若干微指令的有序集合称为微程序**。**微程序的作用是实现一条对应的机器指令。**

**07**、由**水平型微指令**解释指令的微程序，具有**微指令字较长但微程序短**的特点；**垂直型微指令**其**微指令字较短而微程序较长**的特点。**一条水平型微指令**能**定义并执行几种并行的基本操作**（更充分利用数据通路的并行结构）；**一条垂直型微指令只能定义并执行一种基本操作**。

**08**、若指令系统中具有 **n 种机器指令（n 种操作）**，则**控制存储器中的微程序数至少**是 n+2个（增加的 1个为公共的取指微程序，另一个为对应中断周期的微程序）。

**09、兼容性微命令是指那些可以同时产生、共同完成某些微操作的微命令。**

**10**、微处理器是相对于一些大型处理器而言的，与微程序控制器没有必然联系。不管是采用微程序控制器，还是采用硬布线控制器，微机的 CPU 都是微处理器。直接编码方式中每位代表一个微命令，不需要译码，因此执行效率最高，只是这种方式会使得微指令的位数大大增加。

**11**、**微程序控制方式**采用**编程方式来执行指令**，而**硬布线方式**则采用硬件方式来执行指令，因此**硬布线方式速度较快**。

**uPC无法取代 PC**，因为它只在微程序中指向下一条微指令地址的寄存器。因此它也必然不可能知道这段微程序执行完毕后下一条是什么指令。

**由于每条微指令执行时所发出的控制信号是事先设计好的，不需要改变，因此存放所有控制信号的存储器应为 ROM。**

指令周期是从一条指令启动到下一条指令启动的间隔时间，而 CPU 周期是机器周期，是指令执行中每步操作所需的时间。

**12**、CPU 控制器（**控制部件**）主要由三个部件组成：**指令寄存器、程序计数器和操作控制器**。**状态条件寄存器通常属于运算器的部件**，保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，如运算结果进位标志©、运算结果溢出标志(V)等。**运算器、存储器、外围设备相对控制器来说就是执行部件。**

* * *

**13**、某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用**字段直接编码法**，共有 **33 个微命令**，构成 **5 个互斥类**，分别包含 7、3、12、5 和 6个微命令，则**操作控制字段**至少有【15位】。

解析：**字段直接编码法**将微命令字段分成若干小字段，**互斥性微命令组合在同一字段中**，**相容性**  
**微命令分在不同字段中**，**每个字段还要留出一个状态**，表示本字段不发出任何微命令。5 个互斥类，分别包含 7、3、12、5 和6个微命令，需要 3、2、4、3和 3 位，共 15 位。

* * *

**14**、某计算机采用微程序控制器，共有 **32 条指令**，**公共的取指令微程序包含 2 条微指令**，各指令对应的微程序**平均由 4 条微指令组成**，采用**断定法（下地址字段法）确定下条微指令地址**，则微指令中下地址字段的位数至少是【8位】。

解析：计算机共有 32 条指令，各个指令对应的微程序平均有 4 条微指令，则指令对应的微指令为 32 × 4=128条，而公共微指令还有 2 条，整个系统中微指令的条数共为 128+2=130条，所以需要 ⌈ l o g 2 130 ⌉ \\lceil{log\_2130}\\rceil ⌈log2130⌉ = 8 位才能寻址到 130 条微指令。

**15**、某机**共有 52 个微操作控制信号**，构成 **5 个相斥类的微命令组**，各组分别包含 5、8、2、15、22 个微命令。已知**可判定的外部条件有两个，微指令字长 28 位**。  
1）按**水平型微指令格式设计微指令**，要求微指令的下地址字段直接给出后继微指令地址。  
2）指出**控制存储器的容量**。

解：1）根据 5 个互斥类的微命令组，各组分别包含 5、8、2、15、22个微命令，考虑到**每组必**  
**须增加一种不发命令的情况**，**条件测试字段应包含一种不转移的情况**，则 5 个控制字段分别需给出6、9、3、16、23 种状态，对应 3、4、2、4、5位（共18位），条件测试字段取 2 位。根据微指令字长为 28 位，下地址字段取 28 - 18 - 2 = 8位。

2）根据后继地址字段为 8 位，微指令字长为 28 位，得出控制存储器的容量为 28 × 28位。

* * *

**16**、**主存储器（MM）**就是我们通常所说的主存，它在CPU外，用于**存储指令和数据**，**由 RAM 和 ROM实现**。**控制存储器（CS）**用来**存放**实现指令系统的所有**微指令**，是一种**只读型存储器（ROM实现）**，机器运行时只读不写，在 CPU 的控制器内。**CS按照微指令的地址访问**。

* * *

应用程序员透明

虚拟寄存器、暂存寄存器

**汇编程序员可见**

**PC、基址寄存器、状态/标志寄存器、通用寄存器组**

**汇编程序员透明**

**MAR、MDR、IR、微指令寄存器**

**系统程序员可见**

**虚拟存储器**

* * *

### 5.5、异常和中断机制

**01、异常**

*   **硬故障中断：存储器校验错、总线错误等。**
    
*   **程序性异常：也称 软件中断，如整除 0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等。**
    

**02、中断**

中断是指来自 CPU 外部、与 CPU 执行指令无关的事件引起的中断，包括 I/O 设备发出的 I/O 中断（如**键盘输入、打印机缺纸**等)，或发生某种特殊事件（如用户**按 Esc 键、定时器计数时间到**）等。

**03**、自陷是人为设定的特殊中断机制，不是出现某些异常情况而产生的。

执行到自陷指令时，无条件或有条件地自动调出操作系统内核程序进行执行。

CPU 执行陷阱指令后，会自动地根据不同陷阱类型进行相应的处理，然后返回到陷阱指令的下一条指令执行。

**指令执行结果出现的异常**是**程序性中断**（软件中断)，如运算溢出等。I/O 中断属于外部中断。**机器校验中断属于终止类异常。**

**04**、CPU 检测到异常事件后所做的处理和检测到中断请求后所做的处理**基本是相同的**，但有些地方可能不同。例如，对于故障类异常，因为其断点为发生故障时的指令地址，所以要重新计算PC值，而中断的断点为下条指令地址（即PC值)，因此无须重新计算 PC 值。

**05、以下给出的事件中，无须异常处理程序进行处理的是【B】。**  
A. 缺页故障 B. Cache 缺失 C. 地址越界 D. 除数为 0

**解析**：缺页、地址越界 和 除数为0 都是执行某条指令时发生的故障，需要调出操作系统内核中相  
应的异常处理程序来处理，而 Cache 缺失由 CPU 硬件实现，无须调出异常处理程序进行处理。

* * *

**06**、异常事件在当前指令执行过程中进行检测，中断请求则在当前指令执行后进行检测。下列事件中，**相应处理程序执行后，必须回到当前指令重新执行的是**【B】。  
A. 系统调用 **B. 页缺失** C. DMA传送结束 D. 打印机缺纸

**解析**：外部中断都是在一条指令执行完成后（中断周期）才被检测并处理的。DMA 请求只请求总线的使用权，不影响当前指令的执行，不会导致被中断指令的重新执行。而**缺页中断发生在取指或间址等指令执行过程之中，并且会阻塞整个指令。当缺页中断发生后，必须回到这条指令重新执行，以便重新访存。因此选B。**

* * *

### [5.6、指令流水线](https://blog.csdn.net/qq_44762290/article/details/119730632)

**01、基础知识部分**

**一条指令的执行过程分为 5 个阶段（功能段/流水段）**：【取指（IF）】、【译码/读寄存器（ID）】、【执行/计算地址（EX）】、【访存（MEM）】、【写回（WB）】。

**指令周期由若干机器周期来表示，1 个机器周期又包含若干时钟周期，只有在理想情况下的流水线 CPU 中，才可能实现每个时钟周期开始执行 1 条新指令。**

**流水线设计原则**：**指令流水段个数**以最复杂指令所用的功能段个数为准；**流水段的长度**以**最复杂操作所花的时间为准**。

假设某条指令的 **5 个阶段**所花的时间分别如下：（1）取指：200ps；（2）译码：100ps；（3）执行：150ps；（4）访存：200ps；（5）写回：100ps。该**指令的总执行时间**为 **750ps**。**按照流水线设计原则**，**每个流水段的长度为200ps**，所以每条指令的执行时间为 1ns。

假设某程序中有 N 条指令，**单周期处理机**所用的时间为 N×750 ns，而**流水线处理机所用的时间为（N + 4）× 200 ns。** **（不能缩短单条指令执行时间，但能提高整体效率）**

* * *

**02、流水线性能指标**

**流水线吞吐率（TP）**：在单位时间内流水线所完成的任务数量，或输出结果的数量。

 TP = n T k \\frac{n}{T\_k} Tkn 式中， n 是任务数，Tk 是处理完 n 个任务所用的总时间。

设 k 为流水段的段数，T 为时钟周期。在输入流水线中的任务连续的理想情况下，一条 k 段流水线能在 k + n - 1 个时钟周期内完成 n 个任务。得出流水线的吞吐率为 TP = n ( k + n − 1 ) T \\frac{n}{(k+n-1)T} (k+n−1)Tn

**流水线加速比(S)** ：完成同样一批任务，不使用流水线与使用流水线所用的时间之比。

 S = T 0 T k \\frac{T\_0}{T\_k} TkT0，T0 表示不使用流水线的总时间；Tk 表示使用流水线的总时间。

 S = n k T ( k + n − 1 ) T \\frac{nkT}{(k + n - 1)T} (k+n−1)TnkT = n k k + n − 1 \\frac{nk}{k+n-1} k+n−1nk

**超流水线技术（CPI = 1）**：流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高，因此超流水线技术是通过提高流水线主频的方式来提升流水线性能的。但是，流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。

**多发射流水线** CPU 每个时钟周期可以处理多条指令，CPI<1，相对而言，多发射流水线成本更高，控制更复杂。

**动态流水线**是相对于静态流水线而言的，静态流水线上下段连接方式固定，而动态流水线的连接方式是可变的。即**动态流水线是指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进**  
**行另一种运算**，这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。

* * *

**03**、**空间并行**即**资源重复**，主要指**多个功能部件共同执行同一任务的不同部分**，典型的如**多处理机系统**。**时间并行**即**时间重叠**，**让多个功能部件在时间上相互错开，轮流重叠执行不同任务的相同部分**，因此**流水CPU利用的是时间并行性**。RISC 都采用流水线技术，以提高资源利用率。大部分CISC同样采用了流水线技术。流水 CPU 和多媒体 CPU 无必然联系。

**04、超标量流水线技术**：是指**在 1个时钟周期内 1条流水线可执行 1条以上的指令**。1 条指令分为多段指令，由不同电路单元完成。超标量通过内置多条流水线来同时执行多个处理器，其实质是以空间换取时间\*\*（并非运算操作并行）\*\*。

**05**、设指令由取指、分析、执行 3 个子部件完成，并且每个子部件的时间均为 T，若采用**度为 4的超标量流水线处理机**，连续执行 20 条指令，共需【7T】。

**解析**：这个**超标量流水线处理机可以发送 4 条指令**，所以共需：（3 + (20-4) / 4）T = 7T。

**06**、流水 CPU 是由一系列称为“段”的处理线路组成的。**一个 m 段流水线稳定时的 CPU 的吞吐能力，与 m 个并行部件的 CPU 的吞吐能力相比，【具有同等水平的吞吐能力】。**

**解析**：吞吐能力是指单位时间内完成的指令数。m 段流水线在第 m 个时钟周期后，每个时钟周期都可以完成 1条指令；而 m 个并行部件在 m 个时钟周期后能完成全部的 m 条指令，等价于平均每个时钟周期完成一条指令。因此两者的吞吐能力等同。

**07**、设指令流水线把一条指令分为取指、分析、执行3部分，且3部分的时间分别是 T取指\= 2ns， T分析\= 2ns， T执行\= 1ns，则 100 条指令全部执行完毕需【203ns】。

**解析**：每个功能段的时间设定为取指、分析和执行部分的最长时间 2ns，第一条指令在第 5ns 时执行完毕，其余 99 条指令每隔 2ns 执行完一条，所以 100 条指令全部执行完毕所需的时间为  
（5+99x2)ns=203ns。

**08**、数据在功能部件之间传送的路径被称为数据通路，包括数据通路上流经的部件，如**程序计数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等**。**数据通路由控制部件控制**，控制部件根据每条指令功能的不同生成对数据通路的控制信号。**因此，不包括控制部件。**

**09**、某计算机的指令流水线由 **4 个功能段**组成，指令流经各功能段的时间\*\*（忽略各功能段之间的缓存时间）**分别为 90ns、80ns、70ns和60ns，则该**计算机的 CPU 周期\*\*至少是【90ns】。

**解析**：**时钟周期应以各功能段的最长执行时间为准**，否则用时较长的流水段的功能将不能正确完  
成，因此应选90ns。

**10**、若某计算机最复杂指令的执行需要完成 **5 个子功能**，分别由功能部件 A~E 实现，各功能部件所需时间分别为 80ps、50ps、50ps、70ps和50ps，采用流水线方式执行指令，**流水段寄存器延时为20ps**，则 **CPU 时钟周期**至少为【100】。

**解析**：指令流水线的每个流水段时间单位为时钟周期，题中指令流水线的指令需要用到 A~E 五个  
部件，所以每个流水段时间应取最大部件时间 80ps，此外还有寄存器延时20ps，则 CPU 时钟周期至少是100ps。

* * *

**[流水线的冒险与处理](https://www.cnblogs.com/lfri/p/10053598.html)**

* * *

**11**、现有 4 级流水线，分别完成 **取指令、指令译码并取数、运算、回写**四步操作，假设完成各部操作的时间依次为 100ns、100ns、80ns和50ns。试问：  
**1）** 流水线的操作周期应设计为多少？  
**2）** 若相邻两条指令如下，**发生数据相关（假设在硬件上不采取措施)**，试分析第二条指令要推迟多少时间进行才不会出错。  
ADD R1,R2,R3 # R2+R3->R1  
SUB R4,R1,R5 # R1 -R5->R4  
**3）若在硬件设计上加以改进，至少需要推迟多少时间？**  
解析：**1**）流水线操作的时钟周期 T 应按四步操作中的最长时间来考虑，所以 T=100ns。  
**2**）分析如下：  
首先该两条指令发生写后读相关，且两条指令在流水线中的执行情况如下表所示。

![](https://img-blog.csdnimg.cn/0a5e382a67fb4879862acafb95389754.png)

* * *

![](https://img-blog.csdnimg.cn/cc4568f195a9472e8323eb1357186700.png)

![](https://img-blog.csdnimg.cn/339e2d2601574e379fb1afe8a636df16.png)

![](https://img-blog.csdnimg.cn/237ac0a4295b4654b892a18af98b68a9.png)

![](https://img-blog.csdnimg.cn/a3a1b1a9f13e4a6eac3eb38f3c442665.png)

* * *

### 5.7、多处理器的基本概念

**01**、Flynn 分类法将计算机体系结构分为 SISD、SIMD、MISD 和 MIMD 四类。常规的**单处理器属于 SISD，常规的多处理机属于MIMD。**

**02**、SIMD 结构的计算机通常由一个指令控制部件、多个处理单元组成，不同处理单元执行的同一条指令所处理的数据可以不同。

**03**、**超线程技术**在 CPU 内部仅复制必要的线程资源，共享 CPU 的高速缓存和功能部件，让两个线程可以并行执行，**模拟双核心 CPU**。

**04**、**时间并行是指流水线技术**，**空间并行则是指硬件资源的重复**，空间并行导致了两类并行机的产生，按 FIynn 分类法分为 SIMD 和 MIMD。

**05**、**多核 CPU 的各核心**可以有**独自的 Cache，也可以共享同一个Cache**。只有支持多线程的并行处理程序才能同时在多个核心上运行，发挥多核的优势。**多任务系统又称多道程序系统，可以运行在单核CPU上，宏观上并行，微观上串行。**

* * *

### 5.8、简答题

**01、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？**  
从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。  
从空间上讲，从内存读出的指令流流向控制器（指令寄存器)，从内存读出的数据流流向运算器（通用寄存器）。

**02、什么是指令周期、机器周期和时钟周期？它们之间有何关系？**  
CPU 每取出并执行一条指令所需的全部时间称为指令周期；机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度 = 主存周期；时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 = 计算机主频的倒数。

**03、什么是微指令？它和指令有什么关系？**  
控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令，而一组实现一定操作功能的微命令的组合，构成一条微指令。许多条微指令组成的序列构成微程序，微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。

**04、什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？**  
指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。

**05、流水线越多，并行度就越高。是否流水段越多，指令执行越快？**  
错误，原因如下：  
**1）流水段缓冲之间的额外开销增大**。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。  
**2）流水段间控制逻辑变多、变复杂**。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。

* * *

![](https://img-blog.csdnimg.cn/2f5931e107b44ac2ba70f1eb7976f4df.png)

![](https://img-blog.csdnimg.cn/84c524eed7d841b4b286fc25d4b34564.png)

* * *

![](https://img-blog.csdnimg.cn/5d47d894583d429a82899a9ea0a472ef.png)

* * *

6、[总线系统](https://blog.csdn.net/qq_44709990/article/details/108192155)
---------------------------------------------------------------------

### 6.1、总线概述

**01、基本概念：**

**总线特点：【分时】和【共享】。**

总线特性指【**机械特性**】（尺寸、形状）、【**电气特性**】（传输方向和有效的电平范围）、【**功能特性**】（每根传输线的功能）和【**时间特性**】（信号和时序的关系）。

总线分类：【片内总线】、【系统总线】、【I/O总线】、【通信总线（外部总线）】。

**系统总线（连接各个功能部件：如 CPU、主存和 I/O设备）：**

*   **数据总线**：用来传输各功能部件之间的数据信息，它是**双向传输总线**，其**位数与机器字长、存储字长有关**。
    
*   **地址总线**：用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，它是**单向传输总线**，**地址总线的位数与主存地址空间的大小有关**。
    
*   **控制总线**：传输的是控制信息，包括 CPU 送出的控制命令和主存（或外设）返回 CPU 的反馈信号。
    

**总线标准中属于串行总线的是：【USB】、【RS-232C】、【SATA】、【PCI-Expressx】**。

局部总线：【PCI】、【AGP】、【VESA】。 **总线之间须通过【桥接器相连】。**

**高速设备**采用**局部总线**连接，**可以节省系统的总带宽**。

**串行传输**是指**数据的传输在一条线路上按位进行**，**并行传输**是指**每个数据位有一条单独的传输线，所有的数据位同时进行**。不同信号在同一条信号线上分时传输的方式，称为总线复用方式。

**取指令时，指令是在数据线上传输的。操作数显然在数据线上传输。**

中断类信号用指出中断向量的地址，CPU 响应中断请求后，将中断应答信号 (INTR) 发回数据总线，CPU 从数据总线上读取中断类型号后，查找中断向量表，找到相应的中断处理程序入口。

**握手（应答）信号属于通信联络控制信号，应在控制总线上传输。**

可提高同步总线数据传输率的是【增加总线宽度、支持突发传输、提高总线工作频率】。

* * *

**02**、计算机使用**总线结构便于增减外设**，同时【**减少信息传输线的条数**】；相对于专线结构，其实际上也降低了信息传输的并行性及信息的传输速度。

**03、间址寻址第一次访问内存所得到的信息经系统总线的【数据总线】传送到CPU。**

**解析**：间址寻址首次访问内存所得到的信息是**操作数的有效地址**，该**地址作为数据通过数据总线传送至 CPU，地址总线是用于 CPU 选择主存单元地址和 I/O 端口地址的单向总线，不能回传。**  
地址总线由单向的多根信号线组成，可用于 CPU 向主存、外设传送地址信息；数据总线由双向的多根信号线组成，CPU 可以沿着这些线从主存或外设读入数据，也可以发送数据；控制总线上传输控制信息，包括控制命令和反馈信号等。

* * *

**04**、传输一幅分辨率为 640×480 像素、颜色数量为 65536 的照片（采用无压缩方式），设有效数据传输率为 56kb/s，大约需要的时间是【87.77s】。

**解析**：**65536 =216 色，因此颜色深度为 16 位**，占据的存储空间为 640×480×16 =4915200位。有效传输时间 = 4915200 /（56×103） ≈ \\approx ≈ 87.77s。

* * *

**05**、某同步总线的**时钟频率为 100MHz**，**宽度为 32 位**，地址/数据线复用，每传输一个地址或数据**占用一个时钟周期**。若该总线支持突发（猝发）传输方式，则一次\*\*“主存写”\*\*总线事务传输 128 **位数据所需要的时间至少是**【50ns】。

解析：由于**总线时钟频率为 100MHz**，因此**时钟周期为 10ns**。总线位宽与存储字长都是 32 位，因此**每个时钟周期可传送一个 32 位存储字**。**猝发式发送可以连续传送地址连续的数据**，因此总传送时间为：**传送地址 10ns，传送 128 位数据 40ns，共需50ns。**

* * *

**06**、某同步总线采用数据线和地址线复用方式，其中地址/数据线有 **32** 根，总线**时钟频率为66MHz**，**每个时钟周期传送两次数据**（上升沿和下降沿各传送一次数据），则总线带宽是 528MB/s。

解析：32 根，则一次传送 32B/8 = 4B 的数据，**66MHz 意味着有 66M 个时钟周期（1Hz 代表每秒钟周期震荡 1 次即 1 个时钟周期）**，而每个时钟周期传送两次数据，可知总线每秒传送的最大数据量为 66M×2×4B=528MB。

**总线带宽（最大数据传输率） = 总线宽度 × 总线工作频率（单位为 B / s） 当 总线周期 = N 个时钟周期，则总线工作频率 = 时钟频率 / N。**

总线时钟频率：即机器的时钟频率，它为时钟周期的倒数。

总线工作频率：总线周期的倒数。**指 1s 内传送几次数据**。

**[时钟频率（HZ）与数据传输速率（bit/s）](https://blog.csdn.net/Jahol_Fan/article/details/51831077?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-51831077-blog-103617239.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-51831077-blog-103617239.pc_relevant_vip_default&utm_relevant_index=1)**

* * *

**07**、假定一台计算机采用 **3 通道存储器总线**，配套的内存条型号为 DDR3-1333，即内存条所接插的存储器**总线的工作频率为 1333MHz**，**总线宽度为 64 位**，则存储器总线的总带宽大约是【32GB/s】。

**解析：总线的宽度为 64bit，即 8B，则 3 通道总线的总带宽为 8×1333×3=31.992≈32GB/s。**

**支持三通道 DDR3 内存，理论上内存带宽为单通道系统的三倍。**

* * *

**08**、下列关于总线设计的叙述中，错误的是【A】。  
A. 并行总线传输比串行总线传输速度快（不是绝对的）  
B. 采用信号线复用技术可减少信号线数量  
C. 采用突发传输方式可提高总线数据传输率  
D. 采用分离事务通信方式可提高总线利用率

**解析**：总线复用是指一种信号线在不同的时间传输不同的信息，它可使用较少的线路传输更多的信息，从而节省空间和成本；分离事务通信是总线复用的一种，相比单一的传输线路可以提高总线的利用率。

* * *

**09**、QPI 总线是一种**点对点全工同步串行总线**，**总线上的设备可同时接收和发送信息**，每个方向可同时传输 **20 位信息**（16 位数据 + 4 位校验位），每个 QPI 数据包有 80 位信息，分 2 个时钟周期传送，每个时钟周期传递 2 次。因此，QPI 总线带宽为：每秒传送次数×2B×2。若 QPI 时钟频率为2.4GHz，则总线带宽为【19.2GB/s】。

**解析**：每个时钟周期传送 2 次，故每秒传送的次数 = 时钟频率×2 = 2.4G×2/s。  
总线带宽 = 每秒传送次数 × 2B×2 = 2.4G×2×2B×2/s = 19.2GB/s。

公式中的 “x2B” 是因为每次传输 16 位数据，“×2” 是因为采用点对点全双工总线，两个方向可同时传输信息。

* * *

**10**、**某总线支持二级 Cache 块传输方式，若每块 6 个字，每个字长 4 字节，时钟频率为100MHz。**

1）读操作时，第一个时钟周期接收地址，第二、三个为延时周期，另用 4 个周期传送一个块。读操作的总线传输速率为多少？

2）写操作时，第一个时钟周期接收地址，第二个为延时周期，另用 4 个周期传送一个块，写操作的总线传输速率是多少？

**3）设在全部的传输中，70％ 用于读，30％ 用于写，该总线在本次传输中的平均传输速率是多少？**

**答**：\*\*1）\*\*读操作的时钟周期数：1+2+4=7  
对应的频率：100MHz / 7  
总线宽度： 6x4B = 24B  
所以数据传输率 = 总线宽度 / 读取时间 = 24×（100MHz / 7） = 343MB/s

2）写操作的时钟周期数： 1 + 1 + 4 = 6  
对应的频率： 100MHz / 6  
总线宽度： 6×4B=24B  
所以数据传输率 = 总线宽度 / 写操作时间 = 24(100MHz/6) = 400MB/s

3）平均传输速率 = 1/(0.7/343+0.3/400) = 358MB/s。

公式推导如下：设时钟频率为 C MHz，读操作占用 r 个周期，写操作占用 w 个周期；读周期数据为 aB，写周期则为 bB；读写了 n 次，其中 p1 （百分比）为读，p2 为写。

则 总周期数 = p1 × n × r + p2 × n × w = n(p1 r + p2 w)

总传输数据 = n( p1 a + p2 b) B 总时间 = \[n(p1 r + p2 w) × 1 C M \\frac{1}{CM} CM1 \] s

∴ \\therefore ∴ 平均传输速率 = C ( p 1 a + p 2 b ) p 1 r + p 2 w \\frac{C( p\_1 a + p\_2 b)}{p\_1 r + p\_2 w} p1r+p2wC(p1a+p2b) MB/s

* * *

### 6.2、总线事务和定时

**01**、总线事务包括：【请求操作】、【仲裁操作】、【地址操作】、【数据传输】、【总线释放】。**在异步总线中，传送操作【按需分配时间】。**

**突发（猝发）传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。**

**02、同步通信之所以比异步通信具有较高的传输速率，是因为【D】。**  
**A. 同步通信不需要应答信号且总线长度较短**  
**B. 同步通信用一个公共的时钟信号进行同步**  
**C. 同步通信中，各部件的存取时间较接近**  
D. 以上各项因素的综合结果

**03**．在手术过程中，医生将手伸出，等护士将手术刀递上，待医生握紧后，护士才松手。若把医生和护士视为两个通信模块，上述动作相当于【异步通信的全互锁方式】。

**解析**：由题意可知，医生是主模块，护士是从模块。医生伸出手后（即主模块发出请求信号），等待护士将手术刀递上（主模块等待从模块的回答信号），护士也必须等待医生握紧后才松开手  
（从模块等待主模块的回答信号)，以上整个流程就是异步通信的**全互锁方式**。

**04**、某机器 I/O 设备采用异步串行传送方式传送字符信息，**字符信息格式**为 1 位起始位、7  
位数据位、1 位校验位和 1 位停止位。若要求**每秒传送 480 个字符**，则该设备的**数据传输率**为【4800b/s】。

**解析**：一个字符占用 1+7+1+1 = 10位，因此数据传输率为 10×480 = 4800位/秒。

* * *

**05**、在异步串行传输方式下，起始位为 1 位，数据位为 7 位，偶校验位为 1 位，停止位为 1  
位，假设**每秒传输 1200 比特**，则**有效数据传输率**为【840 b/s】。

**解析**：在这样的一个数据帧中，有效数据位是 7 位，传输过程中发送的代码位共有 1+7+1+1=10  
位，所以有效数据传输率为 1200×7/ 10 = 840 b／s。

* * *

### 6.3、简答题

**01、引入总线结构有什么好处？**  
1）简化系统结构，便于系统设计制造。  
2）大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。  
3）便于接口设计，所有与总线连接的设备均采用类似的接口。  
4）便于系统的扩充、更新与灵活配置，易于实现系统的模块化。  
5）便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。  
6）便于故障诊断和维修，同时也能降低成本。

**02、一个总线在某一时刻可以有多对主从设备进行通信吗？**  
不可以。在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信（即一对一的关系)，或对所有设备进行广播通信（即一对多的关系）。所以一个总线在某一时刻不能有多对主从设备进行通信，否则会发生数据冲突。

**03、同一个总线不能既采用同步方式又采用异步方式通信吗？**  
半同步通信总线可以。这类总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。  
例如，某个采用半同步方式的总线总是从某个时钟开始，在每个时钟到来时，采样 Wait 信号，若无效，则说明数据未准备好，下个时钟到来时，再采样 Wait 信号，直到检测到有效，再去数据线上取数据。PCI 总线也是一种半同步总线，它的所有事件都在时钟下降沿同步，总线设备在时钟开始的上升沿采样总线信号。

* * *

7、[输入输出系统](https://blog.csdn.net/qq_44709990/article/details/108200245)
-----------------------------------------------------------------------

### 7.1、I/O系统基本概念

**01**、**I/O 控制方式**：**【程序查询方式】、【程序中断方式】、【DMA方式（硬件电路实现）】、【通道方式】**。

**02**、在微型机系统中，**I/O 设备通过【设备控制器】与主板的系统总线相连接。**

**03**、I/O 指令是指令系统（CPU系统指令）的一部分，是机器指令的一类，但其为了反映与 I/O 设备交互的特点，格式和其他通用指令相比有所不同。

**04、通道程序存放在主存而非通道中，由通道从主存中取出并执行。通道程序由通道执行，且只能在具有通道的 I/O 系统中执行。**

**05**、打印机从**打字原理的角度**来分，可分为**击打式和非击打式**两种；按照**能否打出汉字来分**，可分为**点阵式打印机**和**活字式打印机**。

**06**、**假定一台计算机的显示存储器用 DRAM 芯片实现，若要求显示分辨率为 1600×1200，颜色深度为 24 位，帧频为 85Hz，显存总带宽的 50％ 用来刷新屏幕，则需要的显存总带宽至少约为【7834Mb/s】。**

**解析：刷新所需带宽 = 分辨率×色深×帧频** = 1600×1200×24bit×85Hz = 3916.8Mb/s，显存总带宽的 50％ 用来刷新屏幕，于是需要的显存总带宽至少为 3916.8 /0.5 = 7833.6Mb/s ≈ \\approx ≈ 7834Mb/s。

**显示存储器(VRAM)：也称新存储器。VRAM 容量 = 分辨率×灰度级位数**  
**VRAM 带宽 = 分辨率 × 灰度级位数 × 帧频**

* * *

### 7.2、I/O接口

**01**、**主机访问 I/O 设备的控制方式可分为【程序查询接口】、【中断接口】和【DMA接口】等**。

**02**、I/O 端口是指接囗电路中可被 CPU 直接访问的寄存器，主要有\*\*【数据端口】、【状态端口】和【控制端口】\*\*，若干端口加上相应的控制逻辑电路组成接口。

**03、在统一编址的方式下，区分存储单元和 I/O 设备是靠【不同的地址码】。**

**04**、**在 I/O 总线的数据线上传输的信息包括【I/O 接口中的命令字】、【I/O 接口中的状态字】、【中断类型号】。**

**解析：I/O 总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的；地址线用以传送与 CPU 交换数据的端口地址；而控制线用以给 I/ O端口发送读／写信号，只是用来对端口进行读/写控制的。**

* * *

**05、下列选项中，不属于 I/O 接口的是【A】。**  
**A. 磁盘驱动器** B. 打印机适配器 C. 网络控制器 D. 可编程中断控制器

**解析**：**I/O 接口**即 I/O 控制器，其功能是**接收主机发送的 I/O 控制信号，并实现主机和外部设备之间的信息交换**。磁盘驱动器是由 磁头、磁盘和读写电路等组成的，也就是我们平常所说的磁盘本身。

* * *

### 7.3、I/O方式

**01**、**中断隐指令**处理步骤：关中断—>保存断点—>引出中断服务程序。程序计数器内容的保护和更新是由【**硬件自动**】完成的。

**02**、**中断判优逻辑和总线仲裁方式相类似，下列说法中正确的是**【（1）（3）（4）】。  
**（1）在总线仲裁方式中，独立请求方式响应时间最快，是以增加控制线数为代价的**  
（2）在总线仲裁方式中，计数器定时查询方式有一根总线请求（BR）和一根设备地址线，若每次计数都从 0 开始，则设备号小的优先级高  
**（3）总线仲裁方式一般是指 I/O 设备争用总线的判优方式，而中断判优方式一般是指 I/O 设备争用 CPU 的判优方式**  
**（4）中断判优逻辑既可以通过硬件实现，又可以通过软件实现**

解析：独立请求方式的每个 I/O 接口都有各自的总线请求和总线同意线，共 2n 根控制线以获得高响应速度，因此（1）正确。**在计数器定时方式下，n 个 I/O 接口需要 ⌈ l o g 2 n ⌉ \\lceil log\_2n\\rceil ⌈log2n⌉ 根设备地址线**，因此(2)错误。总线仲裁方式是总线被争用的判优方式，从设备一般是 I/O 设备，但也可以是硬盘（外存）

* * *

**03**、【中断向量方法】可提高中断源的识别速度。中断向量由向量地址形成部件，即由硬件产生，并且不同的中断源对应不同的中断服务程序，因此通过该方法，可以较快速地识别中断源。  
【中断向量】是中断服务程序的入口地址，【中断向量地址】是内存中存放中断向量的地址，即中断服务程序入口地址的地址。

**04**、当有中断源发出请求时，CPU 可执行相应的中断服务程序，可以**提出中断**的有【（1）（3）（5）】。

（1）外部事件 （2）Cache （3）虚拟存储器失效 （4）浮点数下溢 （5）浮点数上溢

**解析**： Cache完全由硬件实现，不涉及中断层面 **浮点数下溢直接当机器零处理**，不属于中断

内中断是指来自CPU和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、非法指令、用户程序执行特权指令自行中断（INT）和除数为零等。

**外部中断：定时器到时描述（时钟中断）、网络数据包到达等。**

**DMA操作结束、机器出现故障、执行“软中断”指令时都会产生中断请求。**

* * *

**05**、**每条指令周期结束后**，CPU 会统一扫描各个中断源，然后进行判优来决定响应哪个中断源，**而不是在每条指令的执行过程中这样做**。CPU 会在**每个存储周期结束后**检查是否有 **DMA 请求**，而不是在指令执行过程的末尾这样做。**中断服务程序的最后指令**通常是**中断返回指令**，与无条件转移指令不同的是，它不仅要修改 PC 值，而且要将 CPU 中的所有寄存器都恢复到中断前的状态。

* * *

**06、能产生 DMA 请求的总线部件是【具有 DMA 接口的设备】。**

* * *

**07**、**用户程序需要输入/输出时**，需要调用操作系统提供的接口（请求操作系统服务），此时会引起**访管中断**，**系统由用户态转为核心态**。

* * *

**08**、在中断响应周期中，CPU 主要完成的工作是【关中断，保护断点，发中断响应信号并形成向量地址，即执行中断隐指令（允许中断触发器置 0 表示关中断）】。

* * *

**09**、**设置中断屏蔽标志可以改变【多个中断服务程序执行完的次序】。**

* * *

**10**、在 DMA 传送方式中，由**外部设备**向 **DMA 控制器**发出 **DMA 请求信号**，然后**由 DMA 控制器向 CPU 发出总线请求信号**。在 DMA 方式中，DMA 控制器在传送期间有总线控制权，这时 CPU 不能响应 I/O 中断。

* * *

**11**、关于外中断（故障除外）和 DMA，下列说法中正确的是【A】。  
**A. DMA 请求和中断请求同时发生时，响应 DMA 请求**  
B. DMA 请求、非屏蔽中断、可屏蔽中断都要在当前指令结束之后才能被响应  
C. 非屏蔽中断请求优先级最高，可屏蔽中断请求优先级最低  
D. 若不开中断，所有中断请求就不能响应

**解析**：DMA 连接的是高速设备，其优先级高于中断请求，以防止高速设备数据丢失，A正确。  
**DMA 请求的响应时间可以发生在每个机器周期结束时**，只要 CPU 不占用总线；中断请求的响应时间只能发生在每条指令执行完毕，B错误。DMA 的优先级要比外中断（非屏蔽中断、可屏蔽中断）高，C错误。**如果不开中断，内中断和非屏蔽中断仍可响应**，D错误。

* * *

**12**、在 DMA 方式下，数据从内存传送到外设经过的路径是【**内存—>数据总线—>DMAC—>外设**】

**解析**：DMA 方式的数据传送不经过 CPU，但需要经过 DMA 控制器中的数据缓冲寄存器。输入时，数据由外设（如磁盘）先送往 DMA 的数据缓冲寄存器，再通过**数据总线**送到主存。输出时，数据**由主存通过数据总线送到DMA的数据缓冲寄存器**，然后**送到外设**。

* * *

**13**、单级中断系统中，**中断服务程序内**的执行顺序是【**保护现场—>中断事件处理—>恢复现场—>开中断—>中断返回**】。 **（通用寄存器的保护由中断服务程序完成）**

**解析：在单级（或单重）中断系统中，不允许中断嵌套。中断处理过程为：（1）关中断；（2）保存断点；（3）识别中断源；（4）保存现场；（5）中断事件处理：（6）恢复现场：（7）开中断；（8）中断返回。其中，（1）~（3）由硬件完成，（4）~ （8）由中断服务程序完成。**

* * *

**14**、若某设备**中断请求的响应和处理时间为 100ns**，每 **400ns 发出一次中断请求**，中断响应所允许的**最长延迟时间为 50ns**，则在该设备持续工作过程中，CPU 用于该设备的 I/O 时间占整个 CPU 时间的百分比至少是【**25%**】。

解析: 每 400ns发出一次中断请求，而响应和处理时间为 100ns，其中**允许延迟时间**为干扰信息，因为在 50ns 内，无论怎么延迟，每 400ns 还是要花费 100ns 处理中断的，所以该设备的 I/O 时间占整个 CPU 时间的百分比为 100ns/400ns = 25%。

* * *

**15**、若设备采用周期挪用 DMA 方式进行输入和输出，每次 DMA 传送的数据块大小为 512B，相应的 I/O 接口中有一个 32 位数据缓冲寄存器。对于数据输入过程，下列叙述中错误的是【C】。  
A. 每准备好 32 位数据，DMA 控制器就发出一次总线请求  
B. 相对于 CPU，DMA 控制器的总线使用权的优先级更高  
**C. 在整个数据块的传送过程中，CPU 不可以访问主存储器**  
D. 数据块传送结束时，会产生"DMA传送结束”中断请求

解析：**周期挪用法**由 DMA 控制器挪用一个或几个主存周期来访问主存，传送完一个数据字后立即释放总线，是**一种单字传送方式**，**每个字传送完后 CPU 可以访问主存**，选项 C 错误。停止 CPU 访存法则是指在整个数据块的传送过程中，使 CPU 脱离总线，停止访问主存。

* * *

**16**、下列是关于多重中断系统中 CPU 响应中断的叙述，错误的是【A】  
**A. 仅在用户态（执行用户程序）下，CPU 才能检测和响应中断**  
B. CPU 只有在检测到中断请求信号后，才会进入中断响应周期  
C. 进入中断响应周期时，CPU 一定处于中断允许（开中断）状态  
D. 若 CPU 检测到中断请求信号，则一定存在未被屏蔽的中断源请求信号

解析：中断服务程序在内核态下执行，若只能在用户态下检测和响应中断，则显然无法实现多重中断（中断嵌套），A错误。 在多重中断中，CPU 只有在检测到中断请求信号后（中断处理优先级更低的中断请求信号是检测不到的），才会进入中断响应周期。进入中断响应周期时，说明此时 CPU一定处于中断允许状态，否则无法响应该中断。如果所有中断源都被屏蔽（说明该中断的处理优先级最高），则CPU不会检测到任何中断请求信号。

* * *

**17**、假定某计算机的 CPU **主频为 80MHz**，**CPI 为 4**，**平均每条指令访存 1.5 次**，主存与 Cache之间**交换的块大小为 16B**，Cache 的**命中率为 99%**，存储器总线宽带为 **32位**。回答下列问题。  
**1）** 该计算机的 **MIPS 数**是多少？**平均每秒 Cache 缺失的次数**是多少？在不考虑 DMA 传送的情况下，**主存带宽至少达到多少才能满足 CPU 的访存要求**？  
**2）** 假定在 Cache 缺失的情况下访问主存时，存在 **0.0005％ 的缺页率**，则 CPU 平均每秒产生多少次缺页异常？若**页面大小为 4KB**，每次缺页都需要访问磁盘，访问磁盘时 DMA 传送采用周期挪用方式，磁盘 I/O 接口的数据缓冲寄存器为 **32位**，则磁盘 I/O 接口平均每秒发出的 DMA 请求次数至少是多少？  
**3）** CPU 和 DMA 控制器同时要求使用存储器总线时，哪个优先级更高？为什么？  
**4）** 为了提高性能，**主存采用 4体低位交叉存储模式**，工作时**每1／4个存储周期启动一个体**。若每**个体的存储周期为50ns**，则该主存能提供的**最大带宽**是多少？

**解**：**1**）**平均每秒 CPU 执行的指令数为 80M／4=20M，因此 MIPS 数为 20**。**平均每条指令访存**  
**1.5次**，因此**平均每秒 Cache 缺失的次数** = 20M×1.5×（1 - 99％）= **300K**。当 Cache 缺失时，CPU访问主存，主存与Cache之间以块为传送单位，此时**主存带宽**为 16B×300k/1s = 4.8MB/s。在不考虑DMA传送的情况下，主存带宽至少达到 4.8MB/s 才能满足CPU的访存要求。

\*\*2）\*\*题中假定在 Cache 缺失的情况下访问主存，平均每秒产生缺页中断 300K×0.0005％ = 1.5次。因为存储器总线宽度为 32 位，所以每传送32位数据，磁盘控制器发出一次 DMA 请求，因此平均每秒磁盘 DMA 请求的次数至少为 1.5 x 4KB / 4B = 1.5K = 1536。

**3）CPU 和 DMA 控制器同时要求使用存储器总线时，DMA 请求的优先级更高。因为 DMA 请求得不到及时响应，I/O 传输数据可能会丢失。**  
**4）** 4 体交叉存储模式能提供的最大带宽为 4×4B/50ns = 320MB/s。

* * *

**18**、假定计算机的**主频为 500MHz**，**CPI 为 4**，现有设备 A 和 B，其**数据传输率**分别为 **2MB/s** 和 **40MB/s**，对应 I/O 接口中各有一个 **32位 数据缓冲寄存器**。回答下列问题，要求给出计算过程。  
**1）** 若设备 A 采用**定时查询 I/O 方式**，每次 输入／输出 都**至少执行 10 条指令**。设备 A **最多间隔多长时间查询一次才能不丢失数据**？CPU 用于设备 A **输入/输出的时间**占 **CPU 总时间**的百分比至少是多少？  
**2）** 在中断 I/O 方式下，若**每次中断响应和中断处理的总时钟周期数至少为 400**，则设备 B 能否采用中断 I/O 方式？为什么？  
**3）** 若设备 B 采用 DMA 方式，**每次 DMA 传送的数据块大小为 1000B**，CPU 用于 DMA 预处理和后处理的**总时钟周期数为 500**，则 CPU 用于设备 B **输入/输出的时间**占 CPU **总时间的百分比最多是多少？**

**解**：**1）** 程序定时向缓存端口查询数据，由于缓存端口大小有限，**必须在传输完端口大小的数据时访问端口，以防止部分数据未被及时读取而丢失**。设备 A 准备 **32 位数据所用的时间**为 4B/2MB = 2us，所以最多每隔 2us 必须查询一次，**每秒的查询次数**至少是 1s / 2us = 5×105 ，每秒 CPU 用于设备 A 输入/输出的时间至少为 5×105×10×4 = 2×107 个时钟周期，占整个 CPU 时间的百分比至少是 2×107 / 500M = 4％。

**（2）** 中断响应和中断处理的时间为 400×(1/500M) = 0.8us，这时只需判断设备 B 准备 32 位数据要多久，若准备数据的时间小于中断响应和中断处理的时间，则数据会被刷新，造成丢失。经计算，设备 B 准备 32 位数据所用的时间为 4B/40MB = 0.1us，因此设备 B 不适合采用中断 I/O方式。

**（3）** 在 DMA 方式中，只有预处理和后处理需要 CPU 处理，数据的传送过程由 DMA 控制。设备 B **每秒的 DMA 次数**最多为 40MB／1000B = 40000，CPU 用于设备 B 输入/输出的时间最多为40000×500=2×107 个时钟周期，占 CPU 总时间的百分比最多为 2×107 / 500M = 4％。

* * *

### 7.4、简答题

**01、中断响应优先级和中断处理优先级分别指什么？**  
**中断响应优先级**是**由硬件排队线路**或**中断查询程序的查询顺序决定**的，**不可动态改变**；而**中断处理优先级**可以**由中断屏蔽字来改变**，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放)，若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。

**02、向量中断、中断向量、向量地址三个概念是什么关系？**  
**中断向量**：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。  
**向量地址**：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。  
**向量中断**：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。

**03、I/O 设备有哪些编址方式？各有何特点？**  
**统一编址**和**独立编址**。统一编址是在主存地址中划出一定的范围作为 I/O 地址，以便通过访存指令即可实现对 I/O的访问，但主存的容量相应减少。**独立编址**是指 I/O地址和主存是分开的，I/O地址不占主存空间，但访存需专门的 I/O指令。

**04、CPU 响应中断应具备哪些条件？**

*   在CPU内部设置的中断屏蔽触发器必须是开放的。
    
*   外设有中断请求时，中断请求触发器必须处于 “1“ 状态，保持中断请求信号。
    
*   外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至 CPU。  
    具各上述三个条件时，**CPU 在现行指令结束的最后一个状态周期响应中断**。
    

**05、I/O接口的主要功能有哪些？**

**（1）数据格式的转换 （2）与主机和外设通信 （3）I/O操作的控制与定时**

**（4）I/O过程中错误与状态检测（反映I/O设备工作状态的功能）**

* * *

![](https://img-blog.csdnimg.cn/75a7b735e13b451a9bc8f63191364873.png)

![](https://img-blog.csdnimg.cn/06c42be713be4404aaee9c90ddd3c04c.png)

* * *

**07、DMA 方式和中断方式的区别**

*   中断方式是程序的切换，需要**保护和恢复现场**；而 DMA 方式除了**预处理和后处理**，其他时候不占用CPU的任何资源。
    
*   对中断请求的响应**只能发生在每条指令执行完毕时（即指令的执行周期后）**；而对 DMA 请求的响应可以发生在**每个机器周期结束时**（在取指周期、间址周期、执行周期后均可），**只要 CPU 不占用总线就可被响应**。
    
*   中断传送过程需要 CPU 的干预；而 DMA 传送过程不需要 CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。
    
*   DMA 请求的优先级高于中断请求。
    
*   中断方式具有对异常事件的处理能力，而 DMA 方式仅局限于传送数据块的 I/O操作。
    
*   从数据传送来看，中断方式靠程序传送，DMA 方式靠硬件传送。
    
* * *

**08**、**1）** 一个完整的指令周期包括哪些 CPU 工作周期？  
**2）** 中断周期前和中断周期后各是 CPU 的什么工作周期？  
**3）** DMA 周期前和 DMA 周期后各是 CPU 的什么工作周期？

**1）** 一个完整的指令周期包括**取指周期、间址周期、执行周期和中断周期**。其中取指周期和执行周期是每条指令均有的。  
**2）** 中断周期前是执行周期，中断周期后是下一条指令的取指周期。  
**3）** DMA 周期前可以是取指周期、间址周期、执行周期或中断周期，DMA周期后也可以是取指周期、间址周期、执行周期或中断周期。总之，**DMA周期前后都是机器周期**。

* * *